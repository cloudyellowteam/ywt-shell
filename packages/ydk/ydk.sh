#!/bin/bash
# YELLOW TEAM BUNDLE
# {"team":"@ywteam","name":"https://yellowteam.cloud/ydk-shell","version":"0.0.0-dev-0","description":"shell SDK"}
# This file is generated by yellowteam sdk builder. Do not edit this file
# Build date: 2024-05-01T01:05:13+00:00
# Build ID: 387283c
# Build branch: main
# Build tag: 0.0.0-alpha-0-73-g387283c
# Build commit: 387283cee279badbb2a8185b98535835be4d3d65
# Build message: Refactor ydk:try function to redirect echo output to file descriptor 4
# Builder: 74cc1c60799e0a786ac7094b532f01b1
# Bundle File Name: <ydk.sh>
# Bundle Entrypoint: <ydk>
ydk:is() {
    case "$1" in
    fifo-exists)
        [ -p "$2" ] && return 0
        ;;
    fifo-readable)
        [ -p "$2" ] && [ -r "$2" ] && return 0
        ;;
    fifo-writable)
        [ -p "$2" ] && [ -w "$2" ] && return 0
        ;;
    fifo-opened)
        [ -p "$2" ] && lsof "$2" && return 0
        ;;
    descriptor-exists)
            "$2" ] && return 0
        ;;
    descriptor-readable)
        [ -r /proc/$$/fd/"$2" ] && return 0
        ;;
    descriptor-writable)
        [ -w /proc/$$/fd/"$2" ] && return 0
        ;;
    descriptor-opened)
        lsof -p $$ | grep " $2" && return 0
        ;;
    exists)
        [ -e "$2" ] && return 0
        ;;        
    not-defined)
        [ -z "$2" ] && return 0
        [ "$2" == "null" ] && return 0
        ;;
    defined)
        [ -n "$2" ] && return 0
        [ "$2" != "null" ] && return 0
        ;;
    rw)
        [ -r "$2" ] && [ -w "$2" ] && return 0
        ;;
    owner)
        [ -O "$2" ] && return 0
        ;;
    writable)
        [ -w "$2" ] && return 0
        ;;
    readable)
        [ -r "$2" ] && return 0
        ;;
    executable)
        [ -x "$2" ] && return 0
        ;;
    nil)
        [ -z "$2" ] && return 0
        [ "$2" == "null" ] && return 0
        ;;
    number)
        [ -n "$2" ] && [[ "$2" =~ ^[0-9]+$ ]] && return 0
        ;;
    digit)
        [ -n "$2" ] && [[ "${2}" =~ ^[[:digit:]]+$ ]] && return 0
        ;;
    string)
        [ -n "$2" ] && [[ "$2" =~ ^[a-zA-Z0-9_]+$ ]] && return 0
        ;;
    boolean)
        [ -n "$2" ] && [[ "$2" =~ ^(true|false)$ ]] && return 0
        ;;
    date)
        [ -n "$2" ] && [[ "$2" =~ ^[0-9]{4}-[0-9]{2}-[0-9]{2}$ ]] && return 0
        ;;
    url)
        [ -n "$2" ] && [[ "$2" =~ ^https?:// ]] && return 0
        ;;
    json)
        jq -e . <<<"$2" >/dev/null 2>&1 && return 0
        ;;
    fnc | function)
        type -t "$2" >/dev/null 2>&1 && return 0
        ;;
    cmd | command)
        command -v "$2" >/dev/null 2>&1 && return 0
        ;;
    f | file)
        [ -f "$2" ] && return 0
        ;;
    d | dir)
        [ -d "$2" ] && return 0
        ;;
    esac
    return 1
}
ydk:nnf() {
    local IOC_TARGET=${1} && shift && [ -z "$IOC_TARGET" ] && return 1
    IOC_TARGET=${IOC_TARGET#_} && IOC_TARGET=${IOC_TARGET#__} && IOC_TARGET="${IOC_TARGET//_/-5f}" && IOC_TARGET="${IOC_TARGET//-/-2d}" && IOC_TARGET="${IOC_TARGET// /_}"
    local IOC_ARGS=("$@")
    local START_TIME=$(date +%s)
    ydk:is function "ydk:$IOC_TARGET" && IOC_TARGET="ydk:$IOC_TARGET"
    ! ydk:is function "$IOC_TARGET" && return 1
    local IOC_STATUS
    $IOC_TARGET "${IOC_ARGS[@]}" || #1>&3 2>&3 ||
    IOC_STATUS=$? && IOC_STATUS=${IOC_STATUS:-0}    
    local END_TIME=$(date +%s)
    local ELAPSED_TIME=$((END_TIME - START_TIME))
    if [ -n "$IOC_STATUS" ] && [ "$IOC_STATUS" -eq 0 ]; then
        local IOC_RESULT="SUCCESS"
    else
        local IOC_RESULT="FAILED"
    fi
    return "${IOC_STATUS}"
}
ydk:argv() {
    kv() {
        local KEY=${1#--} && KEY=${KEY#-}
        if [[ "$KEY" == *kv=* ]]; then
            local KEY=${KEY#kv=}
            local VALUE=${KEY#*:} && VALUE=${VALUE#*:} && VALUE=${VALUE#=}
            local KEY=${KEY%%:*}
        else
            local KEY=${KEY%%=*} && KEY=${KEY%%:*}
            local VALUE=${1#*=} && VALUE=${VALUE#*:} && VALUE=${VALUE#*=} && VALUE=${VALUE#--} && VALUE=${VALUE#-}
        fi
        [[ "$KEY" == "$VALUE" ]] && VALUE=true
        [[ -z "$VALUE" ]] && VALUE=true
        ! [[ "$VALUE" =~ ^[0-9]+$ ]] && ! [[ "$VALUE" =~ (true|false) ]] && VALUE="\"$VALUE\""
        if jq -e . >/dev/null 2>&1 <<<"$VALUE"; then
            VALUE=$(jq -c . <<<"$VALUE")
        fi
        echo -n "\"$KEY\": $VALUE" >&4
    }
    walk() {
        {
            local WALK_FIRST=true
            echo -n "{"
            while [[ $# -gt 0 ]]; do
                local FLAG="$1"
                [[ "$FLAG" != --* ]] && [[ "$FLAG" != -* ]] && YDK_POSITIONAL_ARGS+=("$1") && shift && continue
                kv "$FLAG" 4>&1
                shift
                echo -n ","
            done #| sed -e 's/,$//'
            echo -n "\"__args\": ["
            WALK_FIRST=true
            for YDK_POSITIONAL_ARGS in "${YDK_POSITIONAL_ARGS[@]}"; do
                echo -n "\"$YDK_POSITIONAL_ARGS\""
                [[ "$WALK_FIRST" == true ]] && echo -n "," && WALK_FIRST=false
            done
            echo -n "]"
            echo -n "}"
            export YDK_POSITIONAL_ARGS
            set -- "${YDK_POSITIONAL_ARGS[@]}"
        } >&4
        return 0
    }
    values() {
        [ -n "$YDK_ARGV" ] && echo "$YDK_ARGV" | jq -c . && return 0
        export YDK_ARGV=$(
            {
                local JSON="{" && local FIRST=true
                while [[ $# -gt 0 ]]; do
                    local FLAG="$1"
                    [[ "$FLAG" != --* ]] && [[ "$FLAG" != -* ]] && YDK_POSITIONAL_ARGS+=("$1") && shift && continue
                    local KEY=${FLAG#--} && KEY=${KEY#-} && KEY=${KEY%%=*} && KEY=${KEY%%:*}
                    local VALUE=${FLAG#*=} && VALUE=${VALUE#*:} && VALUE=${VALUE#*=} && VALUE=${VALUE#--} && VALUE=${VALUE#-}
                    [[ "$KEY" == "$VALUE" ]] && VALUE=true
                    [[ -z "$VALUE" ]] && VALUE=true
                    [[ "$VALUE" != true ]] && [[ "$VALUE" != false ]] && [[ "$VALUE" =~ ^[0-9]+$ ]] && VALUE="\"$VALUE\""
                    [ "$FIRST" == true ] && FIRST=false || JSON+=","
                    JSON+="\"$KEY\":\"$VALUE\"" && shift
                done
                JSON+="}"
                echo "$JSON"
            }
        ) && readonly YDK_ARGV
        echo "$YDK_ARGV" | jq -rc .
        return 0
    }
    form() {
        [ -n "$YDK_FORM" ] && echo "$YDK_FORM" | jq -c . && return 0
        export YDK_FORM=$({
            local JSON="{" && local FIRST=true
            while [[ $# -gt 0 ]]; do
                local PARAM="$1"
                [[ "$PARAM" != kv=* ]] && YDK_POSITIONAL_ARGS+=("$1") && shift && continue
                local KEY=${PARAM#kv=}
                local VALUE=${KEY#*:} && VALUE=${VALUE#*:} && VALUE=${VALUE#=}
                KEY=${KEY%%:*}
                [ "$KEY" == "$VALUE" ] && VALUE=true
                [ -z "$VALUE" ] && VALUE=true
                [ "$FIRST" == true ] && FIRST=false || JSON+=","
                JSON+="\"$KEY\":\"$VALUE\"" && shift
            done
            JSON+="}"
            echo "$JSON"
        }) && readonly YDK_FORM
        echo "$YDK_FORM" | jq -c .
    }
    flags() {
        YDK_FLAGS=$(jq -n '{ "quiet": false, "trace": null, "logger": null, "debug": null, "output": null }')
        while [[ $# -gt 0 ]]; do
            case "$1" in
            -q | --quiet)
                export YDK_QUIET=true #&& readonly YDK_QUIET
                YDK_FLAGS=$(jq -n --argjson flags "$YDK_FLAGS" --arg quiet true '$flags | .quiet=$quiet')
                shift
                ;;
            -t | --trace)
                local VALUE=$(jq -r '.trace' <<<"$YDK_FLAGS")
                [ "$VALUE" == "null" ] && shift && continue
                [ "$VALUE" == true ] && VALUE="/tmp/ywt.trace"
                [ -p "$VALUE" ] && rm -f "$VALUE"
                export YDK_TRACE_FIFO="$VALUE"
                [ ! -p "$YDK_TRACE_FIFO" ] && mkfifo "$YDK_TRACE_FIFO" #&& readonly YDK_TRACE_FIFO
                YDK_LOGS+=("Trace FIFO enabled. In another terminal use 'tail -f $YDK_TRACE_FIFO' to watch logs or 'rapd debugger trace watch $YDK_TRACE_FIFO'.")
                YDK_FLAGS=$(jq -n --argjson flags "$YDK_FLAGS" --arg trace "$VALUE" '$flags | .trace=$trace')
                shift
                ;;
            -l | --logger)
                local VALUE=$(jq -r '.logger' <<<"$YDK_FLAGS")
                [ "$VALUE" == "null" ] && shift && continue
                [ "$VALUE" == true ] && VALUE="/tmp/ywt.logger"
                [ -p "$YDK_LOGGER_FIFO" ] && rm -f "$YDK_LOGGER_FIFO"
                export YDK_LOGGER_FIFO="$VALUE"
                [ ! -p "$YDK_LOGGER_FIFO" ] && mkfifo "$YDK_LOGGER_FIFO" #&& readonly YDK_LOGGER_FIFO
                YDK_LOGS+=("Logger FIFO enabled. In another terminal use 'tail -f $YDK_LOGGER_FIFO' to watch logs or 'rapd logger watch $YDK_LOGGER_FIFO'.")
                YDK_FLAGS=$(jq -n --argjson flags "$YDK_FLAGS" --arg logger "$VALUE" '$flags | .logger=$logger')
                shift
                ;;
            -d | --debug)
                [ "$YDK_DEBUG" == true ] && shift && continue
                YDK_DEBUG=true && #readonly YDK_DEBUG
                    local VALUE=$(jq -r '.debug' <<<"$YDK_FLAGS")
                [ "$VALUE" == "null" ] && shift && continue
                [ "$VALUE" == true ] && VALUE="/tmp/ywt.debugger"
                [ -p "$YDK_DEBUG_FIFO" ] && rm -f "$YDK_DEBUG_FIFO"
                export YDK_DEBUG_FIFO="$VALUE"
                [ ! -p "$YDK_DEBUG_FIFO" ] && mkfifo "$YDK_DEBUG_FIFO" #&& readonly YDK_DEBUG_FIFO
                YDK_LOGS+=("Debug enabled. In another terminal use 'tail -f $YDK_DEBUG_FIFO' to watch logs or 'rapd debugger watch $YDK_DEBUG_FIFO'.")
                YDK_FLAGS=$(jq -n --argjson flags "$YDK_FLAGS" --arg debug "$VALUE" '$flags | .debug=$debug')
                shift
                ;;
            -o | --output)
                local VALUE=$(jq -r '.output' <<<"$YDK_FLAGS")
                [ "$VALUE" == "null" ] && shift && continue
                [ "$VALUE" == true ] && VALUE="/tmp/ywt.output"
                [ -p "$VALUE" ] && rm -f "$VALUE"
                export YDK_OUTPUT_FIFO="$VALUE"
                [ ! -p "$YDK_OUTPUT_FIFO" ] && mkfifo "$YDK_OUTPUT_FIFO" #&& readonly YDK_OUTPUT_FIFO
                YDK_LOGS+=("Output FIFO enabled. In another terminal use 'tail -f $YDK_OUTPUT_FIFO' to watch logs or 'rapd output watch $YDK_OUTPUT_FIFO'.")
                YDK_FLAGS=$(jq -n --argjson flags "$YDK_FLAGS" --arg output "$VALUE" '$flags | .output=$output')
                shift
                ;;
            -p* | --param*)
                YDK_POSITIONAL_ARGS+=("$1")
                shift
                ;;
            *)
                YDK_POSITIONAL_ARGS+=("$1")
                shift
                ;;
            esac
        done
        export YDK_FLAGS # && readonly YDK_FLAGS
        set -- "${YDK_POSITIONAL_ARGS[@]}"
        return 0
    }
    YDK_POSITIONAL_ARGS=()
    ydk:try "$@" 4>&1
    local ARGV_STATUS=$?
    export YDK_POSITIONAL_ARGS
    set -- "${YDK_POSITIONAL_ARGS[@]}"
    return $ARGV_STATUS
}
ydk:analytics() {
    ga() {
        collect() {
            MEASUREMENT_ID="G-9KYCLP5VXR"
            API_SECRET="kwhudb31Q5W7sGQr1SDFFg"
            EVENT_NAME="file_downloaded"
            CLIENT_ID="7947731687"
            BODY='{
                "client_id": "'"$CLIENT_ID"'",
                "user_id": "'"$(whoami | md5sum | awk '{print $1}')"'",
                "non_personalized_ads": false,
                "user_properties":{
                    "group":{
                        "value": "'"$(whoami | md5sum | awk '{print $1}')"'",
                    }
                },
                "events": [{
                    "name": "'"$EVENT_NAME"'",
                    "params": {                        
                        "file_name": "example.zip",
                        "user_category": "premium_user"
                    }
                }]
            }'
            GA4_ENDPOINT="https://www.google-analytics.com/mp/collect?measurement_id=$MEASUREMENT_ID&api_secret=$API_SECRET"
            curl -X POST "$GA4_ENDPOINT" \
                -H "Content-Type: application/json" \
                -H "User-Agent: $YDK_ANALYTICS_USERAGENT" \
                -H "Accept: application/json" \
                -d "$BODY" &
            ydk:log debug "Event sent to Google Analytics"
        }
        collect:v1() {
            TRACKING_ID="G-9KYCLP5VXR"
            CLIENT_ID="7947731687"
            EVENT_CATEGORY="shell_script"
            EVENT_ACTION="execute"
            EVENT_LABEL="example_script"
            EVENT_VALUE="1" # Optional
            GA_ENDPOINT="https://www.google-analytics.com/debug/collect"
            curl -X POST "$GA_ENDPOINT" \
                -d "v=1" \
                -d "tid=$TRACKING_ID" \
                -d "cid=$CLIENT_ID" \
                -d "t=event" \
                -d "ec=$EVENT_CATEGORY" \
                -d "ea=$EVENT_ACTION" \
                -d "el=$EVENT_LABEL" \
                -d "ev=$EVENT_VALUE"
            echo "Event sent to Google Analytics"
        }
        ydk:try "$@" 4>&1
        return $?
    }
    ydk:try "$@" 4>&1
    return $?
}
{
    [[ -z "$YDK_ANALYTICS_USERAGENT" ]] && export YDK_ANALYTICS_USERAGENT=$({
        echo -n "ydk-shell/0.0.0-local-0"
        echo -n " "
        echo -n "(curl 7.68.0; A; B)" # (Windows NT 10.0; Win64; x64)
        echo -n " "
        echo -n "bash/5.0.17(1)-release" # AppleWebKit/537.36
        echo -n " "
        echo -n "GoogleAnalytics/4.0" # (KHTML, like Gecko)
        echo -n " "
        echo -n "Linux/x86_64" # Chrome/123.0.0.0
        echo -n " "
        echo -n "AppleWebKit/537.36" # Safari/537.36
        echo -n " "
        echo -n "Edg/123.0.0.0" # Edg/123.0.0.0
    }) && readonly YDK_ANALYTICS_USERAGENT
    [[ -z "$YDK_ANALYTICS_EVENTS" ]] && declare -a YDK_ANALYTICS_EVENTS=(
        '{"name": "file_downloaded", "params": {"file_name": "example.zip", "user_category": "premium_user"}}'
    ) && readonly YDK_ANALYTICS_EVENTS
}
ydk:assets() {
    [[ -z "$YDK_TEAM_INFO" ]] && {
        local YDK_TEAM_INFO=$(ydk:team info 4>&1)
        readonly YDK_TEAM_INFO
        export YDK_TEAM_INFO
    }
    local YDK_REMOTE_URL=$(jq -r '.repo.raw' <<<"${YDK_TEAM_INFO}" 2>/dev/null)
    local YDK_REMOTE_URL="https://raw.githubusercontent.com/cloudyellowteam/ywt-shell/main"
    [[ -z "$YDK_ASSETS_PATH" ]] && {
        local YDK_ASSETS_PATH="${YDK_PATHS[assets]}"
        readonly YDK_ASSETS_PATH
        export YDK_ASSETS_PATH
        mkdir -p "${YDK_ASSETS_PATH}"
    }
    location(){
        local ASSET="${1}"
        [[ -n "${YDK_ASSETS[${ASSET}]}" ]] && ASSET="${YDK_ASSETS[${ASSET}]}"
        echo "${YDK_ASSETS_PATH}/${ASSET}" >&4
        return 0
    }
    get() {
        local ASSETS=()
        for ASSET in "$@"; do
            [[ -n "${YDK_ASSETS[${ASSET}]}" ]] && ASSET="${YDK_ASSETS[${ASSET}]}"
            local ASSET_URL="${YDK_REMOTE_URL}/assets/${ASSET}"
            local ASSET_FILE="${YDK_ASSETS_PATH}/${ASSET}"
            local ASSET_TMP=$(ydk:temp "download" 4>&1)
            if [[ -f "${ASSET_FILE}" ]]; then
                ydk:log "debug" "Asset already exists: ${ASSET_FILE}"
                ASSETS+=("${ASSET_FILE}")
                continue           
            fi
            ydk:log "debug" "Downloading asset from ${ASSET_URL}"
            if ! curl -f -SsL -o "${ASSET_TMP}" "${ASSET_URL}" 2>/dev/null; then
                ydk:log "ERROR" "Failed to download asset from ${ASSET_URL}"
                return 1
            fi
            if [[ -f "${ASSET_TMP}" ]] || [[ -s "${ASSET_TMP}" ]]; then
                mv "${ASSET_TMP}" "${ASSET_FILE}"
                rm -f "${ASSET_TMP}" >/dev/null 2>&1
            else
                ydk:log "ERROR" "Failed to download asset from ${ASSET_URL}"
                return 1
            fi
            ASSETS+=("${ASSET_FILE}")
        done
        echo "${ASSETS[@]}" | tr ' ' '\n' >&4
        return 0
    }
    download(){
        for ASSET in "${YDK_ASSETS[@]}"; do
            if ! get "${ASSET}" 4>/dev/null 2>&1; then
                ydk:log "ERROR" "Failed to download asset: ${ASSET}"
                continue
            fi
        done
        return 0
    }
    activate() {
        echo "assets package"
    }
    ydk:try "$@" 4>&1
    return $?
}
{
    [[ -z "$YDK_ASSETS" ]] && declare -g -A YDK_ASSETS=(
        ["spinners"]="spinners.json"
        ["emojis"]="emojis.json"
        ["scanners"]="scanners.json"
        ["upm-vendors"]="upm.vendors.json"
    ) && readonly YDK_ASSETS && export YDK_ASSETS
}
ydk:async() {
    local YDK_LOGGER_CONTEXT="async"
    declare -a PIDS=()
    declare -a RESULTS=()
    declare -a ERRORS=()
    declare -a COMMANDS=()
    declare -a START_TIMES=()
    local ASYNC_OUTPUT=$(ydk:temp "async" 4>&1)
    for COMMAND in "$@"; do
        local CMD_OUTPUT=$(ydk:temp "async.out" 4>&1)
        local CMD_ERROR=$(ydk:temp "async.err" 4>&1)
        RESULTS+=("$CMD_OUTPUT")
        ERRORS+=("$CMD_ERROR")
        COMMANDS+=("$COMMAND")
        START_TIMES+=("$(date -u +%s.%N)")
        {
            bash -c "$COMMAND" >"$CMD_OUTPUT" 2>"$CMD_ERROR"
        } &
        PIDS+=("$!")
    done
    ydk:log info "Waiting for ${#PIDS[@]} commands to finish"
    local TASKS_LENGTH=${#PIDS[@]}
    local TASKS_LEFT=${#PIDS[@]}
    local TASKS_DONE=0
    local TASKS_ERROR=0
    local TASKS_ID=1
    for PID_IDX in "${!PIDS[@]}"; do
        local YDK_ASYNC_PID="${PIDS[$PID_IDX]}"
        local YDK_ASYNC_RESULT="${RESULTS[$PID_IDX]}"
        local YDK_ASYNC_ERROR="${ERRORS[$PID_IDX]}"
        local YDK_ASYNC_COMMAND="${COMMANDS[$PID_IDX]}"
        local YDK_ASYNC_STARTED_AT="${START_TIMES[$PID_IDX]}"
        local YDK_ASYNC_COMMAND_NAME=$(echo "$YDK_ASYNC_COMMAND" | awk '{print $1}')
        local YDK_ASYNC_MESSAGE="($YDK_ASYNC_PID) ${YDK_ASYNC_COMMAND_NAME} ${TASKS_ID} of ${TASKS_LENGTH}, remaining ${TASKS_LEFT}, done ${TASKS_DONE}, errors ${TASKS_ERROR}"
        ydk:await spin "$YDK_ASYNC_PID" "Waiting $YDK_ASYNC_MESSAGE" >&1
        local YDK_ASYNC_STATUS=$?
        local YDK_ASYNC_EXIT_CODE="${YDK_ASYNC_STATUS}"
        local YDK_ASYNC_FINISHED_AT=$(date -u +%s.%N)
        local YDK_ASYNC_ELAPSED_TIME=$(awk "BEGIN {printf \"%.2f\", $YDK_ASYNC_FINISHED_AT - $YDK_ASYNC_STARTED_AT}")
        {
            echo -n "{"
            echo -n "\"idx\": ${PID_IDX},"
            echo -n "\"pid\": ${YDK_ASYNC_PID},"
            echo -n "\"started_at\": ${YDK_ASYNC_STARTED_AT},"
            echo -n "\"finished_at\": ${YDK_ASYNC_FINISHED_AT},"
            echo -n "\"elapsed_time\": ${YDK_ASYNC_ELAPSED_TIME:-0},"
            echo -n "\"command\": \"${YDK_ASYNC_COMMAND//\"/\\\"}\","
            echo -n "\"exit_code\": ${YDK_ASYNC_EXIT_CODE},"
            echo -n "\"result\": \"$YDK_ASYNC_RESULT\","
            echo -n "\"error\": \"$YDK_ASYNC_ERROR\""
            echo -n "}"
            echo
        } | jq -c . >>"$ASYNC_OUTPUT"
        TASKS_LEFT=$((TASKS_LEFT - 1))
        TASKS_ID=$((TASKS_ID + 1))
        TASKS_DONE=$((TASKS_DONE + 1))
        [ "$YDK_ASYNC_EXIT_CODE" -gt 0 ] && TASKS_ERROR=$((TASKS_ERROR + 1))
        ydk:log success "Done $YDK_ASYNC_MESSAGE"
        rm -f "$YDK_ASYNC_RESULT" "$YDK_ASYNC_ERROR"
    done
    ydk:log success "All commands executed successfully ${ASYNC_OUTPUT}"
    if jq -se . "$ASYNC_OUTPUT" >/dev/null 2>&1; then
        jq -sc . "$ASYNC_OUTPUT" >&4
    else
        cat "$ASYNC_OUTPUT" >&4
    fi
    rm -f "$ASYNC_OUTPUT"
    return 0
}
ydk:await() {
    local YDK_LOGGER_CONTEXT="await"
    [[ -z "$YDK_AWAIT_SPINNERS_FILE" ]] && local YDK_AWAIT_SPINNERS_FILE="/workspace/rapd-shell/assets/spinners.json" && [[ ! -f "$YDK_AWAIT_SPINNERS_FILE" ]] && YDK_AWAIT_SPINNERS_FILE="$(ydk:assets location spinners 4>&1)"
    [[ -z "$YDK_AWAIT_SPECS" ]] && declare -A YDK_AWAIT_SPECS=(
        ["all"]=".[]"
        ["count"]="keys | length"
        ["names"]="keys | .[]"
        ["by_name"]="to_entries[] | select(.key == \$SPINNER_NAME) | .value | .name = \$SPINNER_NAME"
        ["by_index"]="select(.index == \$SPINNER_INDEX)"
    ) && readonly YDK_AWAIT_SPECS
    __cursor:back() {
        local N=${1:-1}
        echo -en "\033[${N}D" >&1
    }
    spinners() {
        startup() {
            tput civis
        }
        list() {
            jq -c . "$YDK_AWAIT_SPINNERS_FILE" >&4
            return 0
        }
        names() {
            list 4>&1 | jq -cr "${YDK_AWAIT_SPECS[names]}" | tr '\n' ' ' >&4
            return 0
        }
        random() {
            read -r -a SPINNERS_NAMES <<<"$(names 4>&1)"
            local SPINNER_INDEX=$((RANDOM % ${#SPINNERS_NAMES[@]}))
            SPINNER_INDEX=$((RANDOM % ${#SPINNERS_NAMES[@]}))
            local SPINNER_NAME="${SPINNERS_NAMES[$SPINNER_INDEX]}"
            jq -cr \
                --arg SPINNER_NAME "$SPINNER_NAME" \
                "${YDK_AWAIT_SPECS[by_name]}" \
                "$YDK_AWAIT_SPINNERS_FILE" >&4
            return 0
        }
        trap "tput cnorm" EXIT INT TERM
        ydk:try "$@" 4>&1
        return $?
    }
    animation() {
        ICON="●" #  • ●
        ARRAY_ANIMATION=(
            "${BLUE}${ICON}${GREEN}${ICON}${YELLOW}${ICON}${RED}${ICON}${MAGENTA}${ICON}    "
            " ${GREEN}${ICON}${YELLOW}${ICON}${RED}${ICON}${MAGENTA}${ICON}${BLUE}${ICON}   "
            "  ${RED}${ICON}${MAGENTA}${ICON}${YELLOW}${ICON}${BLUE}${ICON}${GREEN}${ICON}  "
            "   ${MAGENTA}${ICON}${BLUE}${ICON}${GREEN}${YELLOW}${ICON}${ICON}${RED}${ICON} "
            "    ${BLUE}${ICON}${GREEN}${ICON}${RED}${ICON}${YELLOW}${ICON}${MAGENTA}${ICON}"
        )
        case $1 in
        start)
            ((column = COLUMNS - ${#2} - 8))
            printf "%${column}s"
            while true; do
                for i in {0..4}; do
                    printf "\b\r\033[2K${ARRAY_ANIMATION[i]} ${NC}${2}"
                    sleep 0.12
                done
                for i in {4..0}; do
                    printf "\b\r\033[2K${ARRAY_ANIMATION[i]} ${NC}${2}"
                    sleep 0.12
                done
                __cursor:back 1
                printf "\b\b\b\b\b\b" >&1
            done
            ;;
        stop)
            if [[ -z ${3} ]]; then
                ydk:log error "Animation not running"
                return 1
            fi
            kill "${3}" >/dev/null 2>&1
            {
                echo -en "\b${NC}  --> ["
                if [[ $2 -eq 0 ]]; then
                    echo -en " ${GREEN}Success${NC} "
                else
                    echo -en " ${RED}Error${NC} "
                fi
                echo -e "${NC}]"
                printf "\b\b\b\b"
            } >&1
            ;;
        *)
            ydk:log error "invalid argument, try again with {start/stop}"
            return 1
            ;;
        esac
        return 0
    }
    spin() {
        local SPINNER_TARGET_PID=$1 && [[ -z "$SPINNER_TARGET_PID" ]] && SPINNER_TARGET_PID=$$
        local SPINNER_MESSAGE="${2:-}"
        local SPINNER=$(spinners random 4>&1)
        local SPINNER_NAME=$(jq -r '.name' <<<"$SPINNER" 2>/dev/null)
        read -r -a SPINNER_FRAMES <<<"$({
            jq -r '.frames | .[]' <<<"$SPINNER" | tr '\n' ' '
        } 2>/dev/null)" 2>/dev/null
        local SPINNER_INTERVAL=$(jq -r '.interval' <<<"$SPINNER" 2>/dev/null)
        local SPINNER_LENGTH=${#SPINNER_FRAMES[@]}
        local SPINNER_INDEX=0
        local SPINNER_MESSAGE="${2:-}"
        while ps a | awk '{print $1}' | grep -q "$SPINNER_TARGET_PID"; do
            local FRAME=${SPINNER_FRAMES[$SPINNER_INDEX]}
            printf " %s  %s\r" "$FRAME" "$SPINNER_MESSAGE" >&1
            SPINNER_INDEX=$(((SPINNER_INDEX + 1) % SPINNER_LENGTH))
            sleep "$((SPINNER_INTERVAL / 500))"
            __cursor:back 1
            printf "\b\b\b\b\b\b" >&1
        done
        printf "\b\b\b\b" >&1
        return 0
    }
    examples() {
        local COMMANDS=()
        read -r -a SPINNERS_NAMES <<<"$(spinners names 4>&1)"
        local SPINNER_INDEX=0
        for SPINNER_NAME in "${SPINNERS_NAMES[@]}"; do
            local MESSAGE="Spinner $SPINNER_NAME ${SPINNER_INDEX} of ${#SPINNERS_NAMES[@]}"
            COMMANDS+=("sleep $(((SPINNER_INDEX + 1) * 2)); echo \"$MESSAGE\"")
            SPINNER_INDEX=$((SPINNER_INDEX + 1))
        done
        ydk:async "${COMMANDS[@]}" 4>&1 >&4
        return $?
    }
    ydk:try "$@" 4>&1
    return $?
}
ydk:cache() {
    ydk:try "$@" 4>&1
    return $?
}
ydk:capabilities() {
    ydk:try "$@" 4>&1
    return $?
}
ydk:checksum() {
    hash(){
        local HASH=${1:-"sha256"}
        local FILE=${2} && [ ! -f "$FILE" ] && echo "File not found: $FILE" && return 1
        local HASH_CMD=""
        case "${HASH}" in
        "sha256")
            HASH_CMD="sha256sum"
            ;;
        "sha512")
            HASH_CMD="sha512sum"
            ;;
        "md5")
            HASH_CMD="md5sum"
            ;;
        "sha1")
            HASH_CMD="sha1sum"
            ;;
        *)
            echo "Unknown hash algorithm: ${HASH}"
            return 1
            ;;
        esac
        ${HASH_CMD} "${FILE}" | awk '{print $1}' >&4
        return $?
    }
    generate() {
        local FILE=${1} && [ ! -f "$FILE" ] && echo "File not found: $FILE" && return 1
        local HASH=${2:-"sha256"}
        hash "${HASH}" "${FILE}" 4>&1 >&4
    }
    verify(){
        local FILE=${1} && [ ! -f "$FILE" ] && echo "File not found: $FILE" && return 1
        local HASH=${2} && [ -z "$HASH" ] && echo "Hash not found" && return 1
        local HASH_TYPE=${3:-"sha256"}
        local FILE_HASH=$(hash "${HASH_TYPE}" "${FILE}" 4>&1)
        [ "$FILE_HASH" == "$HASH" ] && return 0
        ydk:log warn "Hash mismatch: $FILE_HASH != $HASH"
        return 1        
    }
    ydk:try "$@" 4>&1
    return $?
}
ydk:colors() {
    inspect() {
        {
            local COLORS=("${!YDK_COLORS[@]}")
            for COLOR in "${COLORS[@]}"; do
                echo -n "${COLOR}: "
                ydk:colors:"${COLOR,,}" " ${COLOR} " 4>&1 >&1
                echo
            done
        } >&4
    }
    ydk:try "$@" 4>&1
    return $?
}
{
    if [[ -z "$YDK_COLORS" ]]; then
        declare -g -A YDK_COLORS=(
            [NC]="\033[0m"
            [NBG]="\033[49m"
            [BLACK]="\033[0;30m"
            [BLACK_BG]="\033[40m"
            [BRIGHT_BLACK]="\033[1;30m"
            [BRIGHT_BLACK_BG]="\033[100m"
            [DARK_GRAY]="\033[1;30m"
            [DARK_GRAY_BG]="\033[100m"
            [RED]="\033[0;31m"
            [RED_BG]="\033[41m"
            [BRIGHT_RED]="\033[1;31m"
            [GREEN]="\033[0;32m"
            [GREEN_BG]="\033[42m"
            [BRIGHT_GREEN]="\033[1;32m"
            [YELLOW]="\033[0;33m"
            [YELLOW_BG]="\033[43m"
            [BRIGHT_YELLOW]="\033[1;33m"
            [BLUE]="\033[0;34m"
            [BLUE_BG]="\033[44m"
            [BRIGHT_BLUE]="\033[1;34m"
            [PURPLE]="\033[0;35m"
            [PURPLE_BG]="\033[45m"
            [BRIGHT_PURPLE]="\033[1;35m"
            [CYAN]="\033[0;36m"
            [CYAN_BG]="\033[46m"
            [BRIGHT_CYAN]="\033[1;36m"
            [GRAY]="\033[0;37m"
            [GRAY_BG]="\033[47m"
            [BRIGHT_GRAY]="\033[1;37m"
            [WHITE]="\033[0;37m"
            [WHITE_BG]="\033[107m"
            [BRIGHT_WHITE]="\033[1;37m"
        ) && readonly YDK_COLORS
        [[ -n "$NO_COLOR" ]] && [[ "$NO_COLOR" == 1 || "$NO_COLOR" == true ]] && return 0
        for COLOR in "${!YDK_COLORS[@]}"; do
            COLOR_CODE="${YDK_COLORS[$COLOR]}"
            declare -g "${COLOR^^}=${COLOR_CODE}"
            eval "ydk:colors:${COLOR,,}() { echo -en \"${COLOR_CODE}\${*}${NC}${NBG}\" >&1; }"
            export -f "ydk:colors:${COLOR,,}"
        done
    fi
}
ydk:config() {
    ydk:try "$@" 4>&1
    return $?
}
ydk:dates() {
    ydk:try "$@" 4>&1
    return $?
}
ydk:debugger() {
    ydk:try "$@" 4>&1
    return $?
}
ydk:domains() {
    ydk:try "$@" 4>&1
    return $?
}
ydk:dotenv() {
    ydk:try "$@" 4>&1
    return $?
}
ydk:drawer() {
    ydk:try "$@" 4>&1
    return $?
}
ydk:emojis() {
    [[ -z "$YDK_EMOJIS_FILE" ]] && local YDK_EMOJIS_FILE="/workspace/rapd-shell/assets/emojis.json" && [[ ! -f "$YDK_EMOJIS_FILE" ]] && YDK_EMOJIS_FILE="$(ydk:assets location emojis 4>&1)"
    list() {
        local YDK_EMOJIS=$(jq -cr . "$YDK_EMOJIS_FILE" 2>/dev/null)
        jq -cr . <<<"$YDK_EMOJIS" >&4
        return 0
    }
    get() {
        local EMOJI_NAME="$1"
        local EMOJI=$(jq -cr ".[\"$EMOJI_NAME\"]" "$YDK_EMOJIS_FILE" 2>/dev/null)
        echo -n "$EMOJI" >&4
        return 0
    }
    substr() {
        local RAW_STR="$1"
        while IFS= read -r MATCH; do
            local EMOJI_NAME=${MATCH:1:-1} #"${MATCH:1:${#MATCH}-2}"
            local EMOJI_CHAR=$(jq -cr ".[\"$EMOJI_NAME\"]" "$YDK_EMOJIS_FILE" 2>/dev/null)
            [[ -n "$EMOJI_CHAR" ]] && RAW_STR=${RAW_STR//"$MATCH"/"$EMOJI_CHAR"}
        done < <(echo "$RAW_STR" | grep -o ':[a-zA-Z_]\+:')
        echo -n "$RAW_STR" >&4
        return 0
    }
    ydk:try "$@" 4>&1
    return $?
}
ydk:envsubst() {
    ydk:try "$@" 4>&1
    return $?
}
ydk:errors() {
    messages() {
        {
            echo -n "{"
            echo -n "\"errors\": {"
            for YDK_ERROR_CODE in "${!YDK_ERRORS_MESSAGES[@]}"; do
                local YDK_ERROR_MESSAGE="${YDK_ERRORS_MESSAGES[$YDK_ERROR_CODE]}"
                echo -n "\"$YDK_ERROR_CODE\": \"$YDK_ERROR_MESSAGE\","
            done | sed -e 's/,$//'
            echo -n "}"
            echo -n "}"
            echo
        } >&4
        return 0
    }
    message() {
        local YDK_ERROR_CODE="${1:-255}"
        local YDK_ERROR_MESSAGE="${YDK_ERRORS_MESSAGES[$YDK_ERROR_CODE]:-"An error occurred"}"
        echo "$YDK_ERROR_MESSAGE" >&4
        return "$YDK_ERROR_CODE"
    }
    ydk:try "$@" 4>&1
    return $?
}
{
    [[ -z "$YDK_ERRORS_MESSAGES" ]] && declare -g -a YDK_ERRORS_MESSAGES=(
        [0]="Success"
        [1]="Not super-user"
        [2]="Misuse of shell builtins"
        [3]="No such process"
        [4]="Interrupted system call"
        [5]="I/O error"
        [6]="No such device or address"
        [7]="Arg list too long"
        [8]="Exec format error"
        [9]="Bad file number"
        [10]="No children"
        [11]="No more processes"
        [12]="Not enough core"
        [13]="Permission denied"
        [14]="Bad address"
        [15]="Block device required"
        [16]="Mount device busy"
        [17]="File exists"
        [18]="Cross-device link"
        [19]="No such device"
        [20]="Not a directory"
        [21]="Is a directory"
        [22]="Invalid argument"
        [23]="Too many open files in system"
        [24]="Too many open files"
        [25]="Not a typewriter"
        [26]="Text file busy"
        [27]="File too large"
        [28]="No space left on device"
        [29]="Illegal seek"
        [30]="Read only file system"
        [31]="Too many links"
        [32]="Broken pipe"
        [33]="Math arg out of domain of func"
        [34]="Math result not representable"
        [35]="File locking deadlock error"
        [36]="File or path name too long"
        [37]="No record locks available"
        [38]="Function not implemented"
        [39]="Directory not empty"
        [40]="Too many symbolic links"
        [42]="No message of desired type"
        [43]="Identifier removed"
        [44]="Channel number out of range"
        [45]="Level 2 not synchronized"
        [46]="Level 3 halted"
        [47]="Level 3 reset"
        [48]="Link number out of range"
        [49]="Protocol driver not attached"
        [50]="No CSI structure available"
        [51]="Level 2 halted"
        [52]="Invalid exchange"
        [53]="Invalid request descriptor"
        [54]="Exchange full"
        [55]="No anode"
        [56]="Invalid request code"
        [57]="Invalid slot"
        [59]="Bad font file fmt"
        [60]="Device not a stream"
        [61]="No data (for no delay io)"
        [62]="Timer expired"
        [63]="Out of streams resources"
        [64]="Machine is not on the network"
        [65]="Package not installed"
        [66]="The object is remote"
        [67]="The link has been severed"
        [68]="Advertise error"
        [69]="Srmount error"
        [70]="Communication error on send"
        [71]="Protocol error"
        [72]="Multihop attempted"
        [73]="Cross mount point (not really error)"
        [74]="Trying to read unreadable message"
        [75]="Value too large for defined data type"
        [76]="Given log. name not unique"
        [77]="f.d. invalid for this operation"
        [78]="Remote address changed"
        [79]="Can   access a needed shared lib"
        [80]="Accessing a corrupted shared lib"
        [81]=".lib section in a.out corrupted"
        [82]="Attempting to link in too many libs"
        [83]="Attempting to exec a shared library"
        [84]="Illegal byte sequence"
        [86]="Streams pipe error"
        [87]="Too many users"
        [88]="Socket operation on non-socket"
        [89]="Destination address required"
        [90]="Message too long"
        [91]="Protocol wrong type for socket"
        [92]="Protocol not available"
        [93]="Unknown protocol"
        [94]="Socket type not supported"
        [95]="Not supported"
        [96]="Protocol family not supported"
        [97]="Address family not supported by protocol family"
        [98]="Address already in use"
        [99]="Address not available"
        [100]="Network interface is not configured"
        [101]="Network is unreachable"
        [102]="Connection reset by network"
        [103]="Connection aborted"
        [104]="Connection reset by peer"
        [105]="No buffer space available"
        [106]="Socket is already connected"
        [107]="Socket is not connected"
        [108]="Can't send after socket shutdown"
        [109]="Too many references"
        [110]="Connection timed out"
        [111]="Connection refused"
        [112]="Host is down"
        [113]="Host is unreachable"
        [114]="Socket already connected"
        [115]="Connection already in progress"
        [116]="Stale file handle"
        [122]="Quota exceeded"
        [123]="No medium (in tape drive)"
        [125]="Operation canceled"
        [126]="Invoked command cannot execute"
        [127]="Command not found"
        [128]="Invalid exit argument"
        [129]="Hangup"
        [130]="Interrupt/Previous owner died"
        [131]="Quit and dump core/State not recoverable"
        [132]="Illegal instruction"
        [133]="Trace/breakpoint"
        [134]="Process aborted"
        [135]="Bus error"
        [136]="Floating point exception"
        [137]="Kill"
        [138]="User-defined 1"
        [139]="Segmentation violation"
        [140]="User-defined 2"
        [141]="Write to pipe with no one reading"
        [142]="Signal raised by alarm"
        [143]="Termination"
        [145]="Child process terminated"
        [146]="Continue if stopped"
        [147]="Stop executing temporarily"
        [148]="Terminal stop signal"
        [149]="Background process attempting to read from tty"
        [150]="Background process attempting to write to tty"
        [151]="Urgent data available on socket"
        [152]="CPU time limit exceeded"
        [153]="File size limit exceeded"
        [154]="Signal raised by timer counting virtual time"
        [155]="Profiling timer expired"
        [157]="Pollable event"
        [159]="Bad syscall"
        [251]="Not found"
        [252]="Invalid argument"
        [253]="Failed to install"
        [254]="Missing required packages"
        [255]="An error occurred"
    )
    export YDK_ERRORS_MESSAGES
}
ydk:fetch() {
    ydk:try "$@" 4>&1
    return $?
}
ydk:fifo() {
    stdin() {
        [ ! -p /dev/stdin ] && [ ! -t 0 ] && return "$1"
        while IFS= read -r INPUT; do
            echo "$INPUT" >&0
        done
        unset INPUT
    }
    stdout() {
        [ ! -p /dev/stdout ] && [ ! -t 1 ] && return "$1"
        while IFS= read -r OUTPUT; do
            echo "$OUTPUT" >&1
        done
        unset OUTPUT
    }
    stderr() {
        [ ! -p /dev/stderr ] && [ ! -t 2 ] && return "$1"
        while IFS= read -r ERROR; do
            echo "$ERROR" >&2
        done
        unset ERROR
    }
    stdvalue() {
        local STD="${1:-4}"
        [ -e /proc/$$/fd/"$STD" ] && echo "$@" >&"$STD" && return 0
        return 1
    }
    stdio() {
        stdin "$1" && stdout "$1" && stderr "$1"
    }
    descriptor() {
        exists() {
            [ -z "$1" ] && return 1
            [ -e /proc/$$/fd/"$1" ] && return 0 || return 1
        }
        writable() {
            [ -z "$1" ] && return 1
            [ -w /proc/$$/fd/"$1" ] && return 0 || return 1
            { true >&"$1"; } 2>/dev/null && return 0 || return 1
        }
        readable() {
            [ -z "$1" ] && return 1
            [ -r /proc/$$/fd/"$1" ] && return 0 || return 1
            { true <&"$1"; } 2>/dev/null && return 0 || return 1
            read -t 0 <&"$1" && return 0 || return 1
        }
        opened() {
            [ -z "$1" ] && return 1
            [ -e /proc/$$/fd/"$1" ] && return 0 || return 1
            lsof -p $$ | grep " $1" && return 0 || return 1
        }
        ydk:try "$@" 4>&1
        return $?
    }
    exists() {
        [ -p "$1" ] && return 0 || return 1
    }
    create() {
        [ -z "$1" ] && return 1
        mkfifo "$1" && return 0 || return 1
    }
    delete() {
        [ -z "$1" ] && return 1
        rm -f "$1" && return 0 || return 1
    }
    read() {
        [ -z "$1" ] && return 1
        [ -p "$1" ] && cat "$1" && return 0 || return 1
    }
    write() {
        [ -z "$1" ] && return 1
        [ -p "$1" ] && echo "$2" >"$1" && return 0 || return 1
    }
    writable() {
        [ -z "$1" ] && return 1
        [ -w "$1" ] && return 0 || return 1
    }
    readable() {
        [ -z "$1" ] && return 1
        [ -r "$1" ] && return 0 || return 1
    }
    opened() {
        [ -z "$1" ] && return 1
        lsof "$1" && return 0 || return 1
    }
    ydk:try "$@" 4>&1
    return $?
}
ydk:functions() {
    {
        echo -n "{"
        echo -n "\"functions\": ["
        local FUNC_LIST=$(
            declare -F |
                awk '{print $3}' |
                tr ' ' '\n' |
                sort |
                uniq |
                tr '\n' ' ' |
                sed -e 's/ $//'
        )
        for FUNC_NAME in ${FUNC_LIST}; do
            [[ "$FUNC_NAME" == _* ]] && continue
            [[ "$FUNC_NAME" == bats_* ]] && continue
            [[ "$FUNC_NAME" == batslib_* ]] && continue
            [[ "$FUNC_NAME" == assert_* ]] && continue
            [[ ! "$FUNC_NAME" == ydk* ]] && continue
            [[ "$FUNC_NAME" == ydk ]] && continue
            [[ "$FUNC_NAME" == *:*:* ]] && continue
            echo -n "\"${FUNC_NAME}\","
        done | sed -e 's/,$//'
        echo -n "]"
        echo -n "}"
        echo
    } >&4
    return 0
}
ydk:host() {
    ydk:try "$@" 4>&1
    return $?
}
ydk:hrml() {
    ydk:try "$@" 4>&1
    return $?
}
ydk:hron() {
    ydk:try "$@" 4>&1
    return $?
}
ydk:installer() {
    YDK_LOGGER_CONTEXT="installer"
    path() {
        {
            local YDK_PATH_NAME="$1" && [[ -z "$YDK_PATH_NAME" ]] && pwd && return 1
            local YDK_PATH="${YDK_PATHS[$YDK_PATH_NAME]}"
            [[ -z "$YDK_PATH" ]] && pwd && return 1
            [[ "${YDK_PATH:0:1}" == "!" ]] && YDK_PATH="${YDK_PATH:1}"
            [[ ! -d "$YDK_PATH" ]] && echo "$YDK_PATH" && return 1
            echo "$YDK_PATH"
            return 0
        } >&4
    }
    paths() {
        {
            echo -n "{"
            for YDK_PATH_NAME in "${!YDK_PATHS[@]}"; do
                local YDK_PATH="${YDK_PATHS[$YDK_PATH_NAME]}"
                local YDK_PATH="${YDK_PATH//\/\//\/}"
                echo -n "\"$YDK_PATH_NAME\":\"$YDK_PATH\","
            done | sed 's/,$//'
            echo -n "}"
        } >&4
        return 0
    }
    check:path() {
        local YDK_PATH="$1"
        local YDK_PATH="${YDK_PATH//\/\//\/}"
        [[ "${YDK_PATH:0:1}" == "!" ]] && {
            YDK_PATH="${YDK_PATH:1}"
            rm -rf "${YDK_PATH:1}" 2>/dev/null
        }
        [[ ! -d "$YDK_PATH" ]] && {
            mkdir -p "$YDK_PATH" 2>/dev/null
        }
        return 0
    }
    check:paths() {
        for YDK_PATH_NAME in "${!YDK_PATHS[@]}"; do
            local YDK_PATH="${YDK_PATHS[$YDK_PATH_NAME]}"
            check:path "$YDK_PATH"
        done
        return 0
    }
    state() {
        local YDK_STATE_FILE="${YDK_PATHS["var"]}/state.json"
        local YDK_STATE=$(jq -c . <"$YDK_STATE_FILE" 2>/dev/null)
        [[ -z "$YDK_STATE" ]] && echo -n "{}" && return 1
        echo -n "$YDK_STATE" >&4
        return 0
    }
    __installer:pkgmgr() {
        [[ -z "${PACKAGE_MANAGERS[*]}" ]] && {
            ydk:log "ERROR" "No package manager available"
            return 1
        }
        for PACKAGE_MANAGER in "${PACKAGE_MANAGERS[@]}"; do
            command -v "$PACKAGE_MANAGER" >/dev/null && break
        done
        [[ -z "$PACKAGE_MANAGER" ]] && {
            ydk:log "ERROR" "No package manager found"
            return 1
        }
        echo "$PACKAGE_MANAGER" >&4
        return 0
    }
    __installer:upm() {
        local PACKAGE_MANAGER=$(__installer:pkgmgr 4>&1)
        [[ -z "$PACKAGE_MANAGER" ]] && return 1
        local PACKAGES=${YDK_INSTALL_DEPS_MAP["*"]}
        [[ -n "${YDK_INSTALL_DEPS_MAP[$PACKAGE_MANAGER]}" ]] && PACKAGES="${PACKAGES[*]} ${YDK_INSTALL_DEPS_MAP[$PACKAGE_MANAGER]}"
        IFS=" " read -r -a PACKAGES <<<"$PACKAGES"
        ydk:log info "Installing (${#PACKAGES[@]}) packages using $PACKAGE_MANAGER"
        ydk:log debug "${PACKAGES[*]}"
        ydk:await animation "start" "Installing with $PACKAGE_MANAGER" & # >&1
        local ANIMATION_PID=$!
        local INSTALL_STATUS=0
        {
            case "$PACKAGE_MANAGER" in
            apt-get)
                apt-get update && apt-get install -y "${PACKAGES[@]}"
                ;;
            yum)
                yum install -y "${PACKAGES[@]}"
                ;;
            apk)
                apk add --update "${PACKAGES[@]}"
                ;;
            dnf)
                dnf install -y "${PACKAGES[@]}"
                ;;
            zypper)
                zypper install -y "${PACKAGES[@]}"
                ;;
            brew)
                brew install "${PACKAGES[@]}"
                ;;
            pkg)
                pkg install -y "${PACKAGES[@]}"
                ;;
            port)
                port install "${PACKAGES[@]}"
                ;;
            emerge)
                emerge "${PACKAGES[@]}"
                ;;
            opkg)
                opkg install "${PACKAGES[@]}"
                ;;
            pacman)
                pacman -S --noconfirm "${PACKAGES[@]}"
                ;;
            xbps)
                xbps-install -y "${PACKAGES[@]}"
                ;;
            slackpkg)
                slackpkg install "${PACKAGES[@]}"
                ;;
            swupd)
                swupd bundle-add "${PACKAGES[@]}"
                ;;
            eopkg)
                eopkg install -y "${PACKAGES[@]}"
                ;;
            sol)
                sol -i "${PACKAGES[@]}"
                ;;
            tazpkg)
                tazpkg get-install "${PACKAGES[@]}"
                ;;
            *)
                ydk:log "WARN" "Unknown package manager: $PACKAGE_MANAGER"
                return 1
                ;;
            esac
            INSTALL_STATUS=$?
        } >/dev/null 2>&1
        sleep 0.1
        [[ -n "$ANIMATION_PID" ]] && {
            ydk:await animation "stop" "Installing" "$ANIMATION_PID" 
            echo -en "\b\b\b\b\b\b" >&1
            echo >&1
        }
        [[ "$INSTALL_STATUS" -ne 0 ]] && {
            ydk:log "WARN" "Failed to install $* using $PACKAGE_MANAGER"
            return 1
        }
        ydk:log "success" "Installed $* using $PACKAGE_MANAGER"
        return 0
    }
    install() {
        local YDK_INSTALL_DEPS=(
            jq git parallel curl ncurses coreutils gcc g++ libgcc grep util-linux binutils findutils openssl
        )
        ydk:log info "Installing into ${YDK_PATHS[bin]}. Change passing -b /your/path" #>&4
        check:paths
        ! ydk:require "${YDK_DEPENDENCIES[@]}" 4>/dev/null && {
            ydk:log "INFO" "Installing required packages"
            if ! __installer:upm "${YDK_INSTALL_DEPS[@]}" 2>/dev/null; then
                ydk:log "error" "Failed to install ${YDK_INSTALL_DEPS[*]} using $PACKAGE_MANAGER"
            else
                ydk:log info "Packages installed"
            fi
        }
        ydk:log info "Downloding assets"
        if ! ydk:assets download 4>&1 >/dev/null; then
            ydk:log "ERROR" "Failed to download assets"
        fi
        ydk:upm installed 4>&1
        return 0
    }
    __installer:opts() {
        while [[ $# -gt 0 ]]; do
            case "$1" in
            -h | --help)
                shift
                ydk:log info "Installer options: $*"
                exit 0
                ;;
            -b | --bin)
                ydk:log "INFO" "Setting binary path: $2"
                YDK_PATHS["bin"]="${2}"
                shift 2
                ;;
            -l | --lib)
                YDK_PATHS["lib"]="${2}"
                shift 2
                ;;
            -e | --etc)
                YDK_PATHS["etc"]="${2}"
                shift 2
                ;;
            -v | --var)
                YDK_PATHS["var"]="${2}"
                shift 2
                ;;
            -c | --cache)
                YDK_PATHS["cache"]="${2}"
                shift 2
                ;;
            -L | --logs)
                YDK_PATHS["logs"]="${2}"
                shift 2
                ;;
            -r | --runtime)
                YDK_PATHS["runtime"]="${2}"
                shift 2
                ;;
            -d | --data)
                YDK_PATHS["data"]="${2}"
                shift 2
                ;;
            -C | --config)
                YDK_PATHS["config"]="${2}"
                shift 2
                ;;
            -t | --tmp)
                YDK_PATHS["tmp"]="${2}"
                shift 2
                ;;
            -H | --home)
                YDK_PATHS["home"]="${2}"
                shift 2
                ;;
            -s | --share)
                YDK_PATHS["share"]="${2}"
                shift 2
                ;;
            -D | --doc)
                YDK_PATHS["doc"]="${2}"
                shift 2
                ;;
            *)
                if [[ "$1" =~ ^- ]]; then
                    ydk:log "WARN" "Unknown option: $1 $2"
                    shift 2
                else
                    YDK_INSTALLER_OPTS+=("$1")
                    shift
                fi
                ;;
            esac
        done
        set -- "${YDK_INSTALLER_OPTS[@]}"
        [[ "${#YDK_INSTALLER_OPTS[@]}" -eq 0 ]] && {
            ydk:throw 252 "Failed to parse installer options"
            return 1
        }
        return 0
    }
    local YDK_INSTALLER_OPTS=() && __installer:opts "$@" 4>&1
    set -- "${YDK_INSTALLER_OPTS[@]}"
    ydk:try "$@" 4>&1
    return $?
}
{
    [[ -z "${YDK_PATHS[*]}" ]] && declare -g -A YDK_PATHS=(
        ["bin"]="${YDK_CONFIG_PATH_BIN:-"/usr/local/bin/ywteam/${YDK_PACKAGE_NAME}"}"
        ["lib"]="${YDK_CONFIG_PATH_LIB:-"/usr/local/lib/ywteam/${YDK_PACKAGE_NAME}"}"
        ["etc"]="${YDK_CONFIG_PATH_ETC:-"/etc/ywteam/${YDK_PACKAGE_NAME}"}"
        ["var"]="${YDK_CONFIG_PATH_VAR:-"/var/lib/ywteam/${YDK_PACKAGE_NAME}"}"
        ["cache"]="${YDK_CONFIG_PATH_CACHE:-"!/var/cache/ywteam/${YDK_PACKAGE_NAME}"}"
        ["logs"]="${YDK_CONFIG_PATH_LOGS:-"/var/log/ywteam/${YDK_PACKAGE_NAME}"}"
        ["runtime"]="${YDK_CONFIG_PATH_RUNTIME:-"/opt/ywteam/${YDK_PACKAGE_NAME}"}"
        ["data"]="${YDK_CONFIG_PATH_DATA:-"/var/lib/ywteam/${YDK_PACKAGE_NAME}"}"
        ["assets"]="${YDK_CONFIG_PATH_ASSETS:-"/usr/share/ywteam/${YDK_PACKAGE_NAME}/assets"}"
        ["config"]="${YDK_CONFIG_PATH_CONFIG:-"/etc/ywteam/${YDK_PACKAGE_NAME}"}"
        ["tmp"]="${YDK_CONFIG_PATH_TMP:-"/tmp/ywteam/${YDK_PACKAGE_NAME}"}"
        ["home"]="${YDK_CONFIG_PATH_HOME:-"$HOME/ywteam/${YDK_PACKAGE_NAME}"}"
        ["share"]="${YDK_CONFIG_PATH_SHARE:-"/usr/share/ywteam/${YDK_PACKAGE_NAME}"}"
        ["doc"]="${YDK_CONFIG_PATH_DOC:-"/usr/share/ywteam/${YDK_PACKAGE_NAME}/doc"}"
    ) && export YDK_PATHS
    [[ -z "${PACKAGE_MANAGERS[*]}" ]] && declare -g -a PACKAGE_MANAGERS=("apt-get" "yum" "apk" "dnf" "zypper" "brew" "pkg" "port" "emerge" "opkg" "pacman" "xbps" "slackpkg" "swupd" "eopkg" "sol" "tazpkg" "xbps" "xbps-src" "xbps-bin" "xbps-uchroot" "xbps-repo" "xbps-query" "xbps-install" "xbps-remove" "xbps-pkgdb" "xbps-rindex" "xbps-rindex") && readonly PACKAGE_MANAGERS
    [[ -z "${YDK_INSTALL_DEPS_MAP[*]}" ]] && declare -g -A YDK_INSTALL_DEPS_MAP=(
        ["*"]="jq git parallel curl coreutils gcc g++ grep util-linux binutils findutils openssl"
        ["apt-get"]="libncurses-dev bsdmainutils"
        ["apk"]="ncurses libgcc"
    ) && readonly YDK_INSTALL_DEPS_MAP
}
ydk:limits() {
    current() {
        ulimit -a | awk '{print $1 " " $3}' | grep -v "unlimited" | awk '{print $1 " " $2}' | sed -e 's/ /: /' >&4
    }
    set() {
        ulimit -Sn 1024 # Set soft limit
        ulimit -Hn 4096 # Set hard limit
        ulimit -c 0
        ulimit -d 0
        ulimit -f 0
        ulimit -l 64
        ulimit -m 0
        ulimit -n 1024
        ulimit -q 0
        ulimit -s 1024
        ulimit -t 20
        ulimit -u 40
        ulimit -v 4000000
        ulimit -x 0
        ulimit -T 0
        ulimit -I 3
        ulimit -l 64
        ulimit -p 20
        ulimit -i 30
        ulimit -o 40
        ulimit -r 0
        ulimit -e 0
        ulimit -k 0
        ulimit -c 0
        ulimit -f 0
        ulimit -t 20
        ulimit -v 4000000
        ulimit -n 1024
        ulimit -m 0
        ulimit -u 40
        ulimit -s 1024
        ulimit -l 64
        ulimit -p 20
        ulimit -i 30
        ulimit -o 40
        ulimit -r 0
        ulimit -q 0
        ulimit -e 0
        ulimit -k 0
        ulimit -x 0
        ulimit -T 0
        ulimit -I 3
    } >&4
    ydk:try "$@" 4>&1
    return $?
}
ydk:linter() {
    ydk:try "$@" 4>&1
    return $?
}
ydk:logger() {
    ! command -v jq >/dev/null 2>&1 && return 254
    __logger:enabled() {
        local LOG_LEVEL=${1:-info}
        local LOG_LEVEL_IDX=-1
        local LOG_CONFIG_LEVEL=${YDK_DEFAULTS_LOGGER[0]:-output}
        local LOG_CONFIG_LEVEL_IDX=-1
        for YDK_LOGGER_LEVEL_IDX in "${!YDK_LOGGER_LEVELS[@]}"; do
            local LEVEL=${YDK_LOGGER_LEVELS[$YDK_LOGGER_LEVEL_IDX]}
            [[ $LOG_LEVEL == "$LEVEL" ]] && LOG_LEVEL_IDX=$YDK_LOGGER_LEVEL_IDX
            [[ $LOG_CONFIG_LEVEL == "$LEVEL" ]] && LOG_CONFIG_LEVEL_IDX=$YDK_LOGGER_LEVEL_IDX
        done
        [[ $LOG_LEVEL_IDX -lt 0 ]] && return 1
        [[ $LOG_CONFIG_LEVEL_IDX -lt 0 ]] && return 1
        [[ $LOG_LEVEL_IDX -ge $LOG_CONFIG_LEVEL_IDX ]] && return 0
        return 1
    }
    __logger:is:level() {
        local LEVEL=${1:-info}
        for LEVEL_IDX in "${!YDK_LOGGER_LEVELS[@]}"; do
            [[ $LEVEL == "${YDK_LOGGER_LEVELS[$LEVEL_IDX]}" ]] && return 0
        done
        return 1
    }
    __logger:message:sanetize() {
        echo -e "$1" | sed -r "s/\x1B\[[0-9;]*[mK]//g" | sed 's/\x1b\[[0-9;]*m//g' >&4
    }
    __logger:message:truncate() {
        echo -e "$1"
        return 0
        local LOG_MESSAGE=$({
            if jq -e . <<<"$1" 2>/dev/null 1>/dev/null; then
                jq -c . <<<"$1" >&4
            else
                echo "$1" >&4
            fi
        } 4>&1)
        local LOG_CHARS=${2:-70}
        local LOG_MAX_LENGTH=${#LOG_MESSAGE}
        if [[ $LOG_MAX_LENGTH -le $((LOG_CHARS * 2)) ]]; then
            echo -en "$LOG_MESSAGE" >&4
        else
            local LOG_MESSAGE_SANETIZED=$(__logger:message:sanetize "$LOG_MESSAGE" 4>&1)
            local LOG_MESSAGE_START=${LOG_MESSAGE_SANETIZED:0:$LOG_CHARS}
            local LOG_MESSAGE_END=${LOG_MESSAGE_SANETIZED: -$LOG_CHARS}
            echo -e "${LOG_MESSAGE_START:-"Start"}...${LOG_MESSAGE_END:-"End"}" >&4
        fi
        return 0
    }
    __logger:write:file() {
        local LOGGER_OPTS=$1
        local LOG_JSON=$2
        local LOG_FILE=$(jq -r '.file' <<<"$LOGGER_OPTS")
        local LOG_MAXSIZE=$(jq -r '.maxsize' <<<"$LOGGER_OPTS")
        LOG_MAXSIZE=$(echo "$LOG_MAXSIZE" | sed -r 's/([0-9]+)([KMG])/\1 \2/' | awk '{print $1 * 1024^index("KMG", $2)}')
        if [[ -f "$LOG_FILE" ]]; then
            local LOG_FILE_SIZE=$(stat -c %s "$LOG_FILE")
            if [[ $LOG_FILE_SIZE -gt $LOG_MAXSIZE ]]; then
                local LOG_FILE_ROTATE=$(dirname "$LOG_FILE")/$(basename "$LOG_FILE" .log)-$(date +"%Y%m%d%H%M%S").log
                mv "$LOG_FILE" "$LOG_FILE_ROTATE"
                echo -n >"$LOG_FILE"
                echo "$LOG_MAXSIZE = $(stat -c %s "$LOG_FILE")" >&1
                echo "Rotated log file $LOG_FILE to $LOG_FILE_ROTATE" >&1
            fi
        fi
        jq -c . <<<"$LOG_JSON" >>"$LOG_FILE"
        return 0
    }
    __logger:padright() {
        local LOG_MESSAGE=$1
        local LOG_CHARS=${2:-70}
        local LOG_MESSAGE_SANETIZED=$(__logger:message:sanetize "$LOG_MESSAGE" 4>&1)
        local LOG_MAX_LENGTH=${#LOG_MESSAGE_SANETIZED}
        if [[ $LOG_MAX_LENGTH -le $((LOG_CHARS * 2)) ]]; then
            echo -n "${LOG_MESSAGE}${LOG_PADDING:-}" >&4
        else
            local LOG_MESSAGE_START=${LOG_MESSAGE:0:$LOG_CHARS}
            local LOG_MESSAGE_END=${LOG_MESSAGE: -$LOG_CHARS}
            echo -n "${LOG_MESSAGE_START:-"Start"}...${LOG_MESSAGE_END:-"End"}" >&4
        fi
        return 0
    }
    __logger:write:console() {
        local LOG_MESSAGE=$1
        local LOGGER_OPTS=$2
        local LOG_JSON=$3
        if ! jq -c . <<<"$LOG_JSON" 2>/dev/null 1>/dev/null; then
            echo -e "$LOG_JSON" >&1
            return 0
        fi
        if grep -qE ":[a-z_]+:" <<<"$LOG_MESSAGE"; then
            LOG_MESSAGE=$(ydk:emojis substr "$LOG_MESSAGE" 4>&1)
        fi
        local LOG_ENABLED=$(jq -r '.priority.enabled // false' <<<"$LOG_JSON" 2>/dev/null)
        [[ $LOG_ENABLED != "true" ]] && return 0
        local LOG_LEVEL=$(jq -r '.priority.name' <<<"$LOG_JSON" 2>/dev/null || echo "info")
        local LOG_COLOR=$(jq -r '.priority.color' <<<"$LOG_JSON" 2>/dev/null || echo "info") && LOG_COLOR=${LOG_COLOR^^}
        local LOG_ICON=$(jq -r '.priority.icon' <<<"$LOG_JSON" 2>/dev/null || echo "info")
        local LOG_CONTEXT=$(jq -r '.context' <<<"$LOG_JSON" 2>/dev/null || echo "info")
        local LOG_TIMESTAMP=$(jq -r '.timestamp' <<<"$LOG_JSON" 2>/dev/null || echo "info")
        local LOG_PID=$(jq -r '.pid' <<<"$LOG_JSON" 2>/dev/null || echo "info")
        local LOG_ETIME=$(jq -r '.etime' <<<"$LOG_JSON" 2>/dev/null || echo "info")
        echo -e "$({
            echo -n "[${YELLOW}${YDK_BRAND^^}${NC}]" #&& echo -n $'\t'
            echo -n " ${LOG_ICON} "                  #&& echo -n $'\t'
            echo -n "| $(
                __logger:padright "$LOG_MESSAGE" 50 4>&1
            )" && echo -n $'\t\t\t'
            echo -n "${ITALIC}${UNDERLINE}$(__logger:padright "[${LOG_CONTEXT^^}]" 5 4>&1)${NS}" # && echo -n $'\t'
            echo -n "["
            eval "echo -n \"\$${LOG_COLOR:-YELLOW}\""
            echo -n "${BOLD}${LOG_LEVEL^^}${NS}"
            echo -n "${NC}${NS}]"                  # && echo -n $'\t'
            echo -n "[${YELLOW}${LOG_PID}${NC}]"     # && echo -n $'\t'
            echo -n "[${BLUE}$LOG_TIMESTAMP${NC}]" # && echo -n $'\t'
            echo -n "[${DARK_GRAY}$LOG_ETIME${NC}]"
            echo
        })" >&1 # >&1
        return 0
    }
    __logger:write() {
        local LOGGER_OPTS=$1 && shift
        local LOG_LEVEL_NAME=${1} && shift
        local LOG_LEVEL=$(jq -cr ".[] | select(.name == \"$LOG_LEVEL_NAME\") | . // {}" < <(levels 4>&1) 2>/dev/null)
        local LOG_MESSAGE=${*//$'\n'/\\n} && [ -z "$LOG_MESSAGE" ] && LOG_MESSAGE="$# $*"
        local LOG_JSON=$({
            echo -n "{"
            echo -n "\"config\": $(
                jq -c '
                    del(.template) |
                    del(.format) |
                    del(.file) |
                    del(.maxsize)                     
                ' <<<"${LOGGER_OPTS:-"{}"}"
            ),"
            echo -n "\"priority\": $(jq -c . <<<"${LOG_LEVEL:-"{}"}"),"
            echo -n "\"timestamp\": \"$(date -u +"%Y-%m-%dT%H:%M:%SZ")\","
            echo -n "\"host\": \"$(hostname | md5sum | cut -d' ' -f1)\","
            echo -n "\"context\": \"${YDK_LOGGER_CONTEXT:-ydk}\","
            echo -n "\"pid\": $$,"
            echo -n "\"ppid\": $PPID,"
            echo -n "\"etime\": \"$(ydk:etime 4>&1)\","
            echo -n "\"cli\": \"${YDK_CLI_NAME:-}\","
            echo -n "\"name\": \"${YDK_CLI_NAME:-}\","
            echo -n "\"message\": "
            if jq -e . <<<"$LOG_MESSAGE" 2>/dev/null 1>/dev/null; then
                local LOG_WELLFORMATED_MESSAGE=$(jq -c . <<<"$LOG_MESSAGE")
            else
                local LOG_WELLFORMATED_MESSAGE="\"$(__logger:message:sanetize "$LOG_MESSAGE" 4>&1)\""
            fi
            echo -n "${LOG_WELLFORMATED_MESSAGE:-"\"$# $*\""}"
            echo -n "}"
            echo
        })
        {
            __logger:write:file "${LOGGER_OPTS}" "${LOG_JSON}" &                   #4>&1
            __logger:write:console "${LOG_MESSAGE}" "${LOGGER_OPTS}" "${LOG_JSON}" #& #4>&1
        } 4>&1
    }
    defaults() {
        local YDK_LOGGER_DEFAULTS=$({
            echo -n "{"
            echo -n "\"level\": \"${YDK_DEFAULTS_LOGGER[0]}\","
            echo -n "\"template\": \"${YDK_DEFAULTS_LOGGER[1]}\","
            echo -n "\"format\": \"${YDK_DEFAULTS_LOGGER[2]}\","
            echo -n "\"context\": \"${YDK_DEFAULTS_LOGGER[3]:-${YDK_LOGGER_CONTEXT:-ydk}}\","
            echo -n "\"file\": \"${YDK_DEFAULTS_LOGGER[4]}\","
            echo -n "\"maxsize\": \"${YDK_DEFAULTS_LOGGER[5]}\""
            echo -n "}"
        })
        jq -c . <<<"$YDK_LOGGER_DEFAULTS" >&4
        return 0
    }
    levels() {
        {
            echo -n "["
            for YDK_LOGGER_LEVEL_IDX in "${!YDK_LOGGER_LEVELS[@]}"; do
                local LOG_LEVEL=${YDK_LOGGER_LEVELS[$YDK_LOGGER_LEVEL_IDX]}
                echo -n "{"
                echo -n "\"level\": ${YDK_LOGGER_LEVEL_IDX},"
                echo -n "\"name\": \"${LOG_LEVEL}\","
                case $LOG_LEVEL in
                trace)
                    echo -n "\"color\": \"cyan\","
                    echo -n "\"icon\": \"🔍\""
                    ;;
                debug)
                    echo -n "\"color\": \"cyan\","
                    echo -n "\"icon\": \"🐞\""
                    ;;
                info)
                    echo -n "\"color\": \"blue\","
                    echo -n "\"icon\": \"💬\""
                    ;;
                warn)
                    echo -n "\"color\": \"yellow\","
                    echo -n "\"icon\": \"🔔\""
                    ;;
                error)
                    echo -n "\"color\": \"red\","
                    echo -n "\"icon\": \"🚨\""
                    ;;
                success)
                    echo -n "\"color\": \"BRIGHT_GREEN\","
                    echo -n "\"icon\": \"👍\""
                    ;;
                output)
                    echo -n "\"color\": \"green\","
                    echo -n "\"icon\": \"📝\""
                    ;;
                fatal)
                    echo -n "\"color\": \"red\","
                    echo -n "\"icon\": \"💀\""
                    ;;
                panic)
                    echo -n "\"color\": \"red\","
                    echo -n "\"icon\": \"🔥\""
                    ;;
                esac
                echo -n ",\"enabled\":"
                __logger:enabled "$LOG_LEVEL" && echo -n "true" || echo -n "false"
                echo -n "},"
            done | sed -e 's/,$//'
            echo -n "]"
        } >&4
    }
    activate() {
        echo "logger activated" >&1
    }
    local LOGGER_OPTS=$(defaults 4>&1)
    local LOGGER_ARGS=()
    while [[ $# -gt 0 ]]; do
        case $1 in
        -l | --level)
            LOGGER_OPTS=$(jq '. + {"level": "'"$2"'"}' <<<"$LOGGER_OPTS")
            shift 2
            ;;
        -c | --context)
            LOGGER_OPTS=$(jq '. + {"context": "'"$2"'"}' <<<"$LOGGER_OPTS")
            shift 2
            ;;
        -f | --format)
            LOGGER_OPTS=$(jq '. + {"format": "'"$2"'"}' <<<"$LOGGER_OPTS")
            shift 2
            ;;
        -t | --template)
            LOGGER_OPTS=$(jq '. + {"template": "'"$2"'"}' <<<"$YDK_LOGGER_DEFAULTS")
            shift 2
            ;;
        -m | --message)
            LOGGER_OPTS=$(jq '. + {"message": "'"$2"'"}' <<<"$LOGGER_OPTS")
            shift 2
            ;;
        *)
            LOGGER_ARGS+=("$1")
            shift
            ;;
        esac
    done
    set -- "${LOGGER_ARGS[@]}" && unset LOGGER_ARGS
    local LOG_LEVEL_OR_ACTION=${1} && shift
    local LOG_LINES=()
    [[ -p /dev/stdin ]] && while read -r LINE; do LOG_LINES+=("$LINE"); done <&0
    if __logger:is:level "$LOG_LEVEL_OR_ACTION"; then
        __logger:write "${LOGGER_OPTS}" "$LOG_LEVEL_OR_ACTION" "$@" "${LOG_LINES[@]}" 4>&1
        return $?
    else
        ydk:try "$LOG_LEVEL_OR_ACTION" "$@" 4>&1
        return $?
    fi
}
{
    [[ -z "$YDK_DEFAULTS_LOGGER" ]] && declare -g -a YDK_DEFAULTS_LOGGER=(
        [0]="trace"
        [1]="[{{.pid}}] [{{.timestamp}}] {{.icon}} {{.level | ascii_upcase}} {{.context | ascii_upcase }} {{.message}} [{{.etime}}]"
        [2]="text"
        [3]="ydk"
        [4]="/var/log/ydk.log"
        [5]="1M"
    ) && readonly YDK_DEFAULTS_LOGGER
    [[ -z "$YDK_LOGGER_LEVELS" ]] && declare -g -a YDK_LOGGER_LEVELS=(
        [0]="trace"
        [1]="debug"
        [2]="info"
        [3]="warn"
        [4]="error"
        [5]="success"
        [6]="output"
        [7]="fatal"
        [8]="panic"
    ) && readonly YDK_LOGGER_LEVELS
}
ydk:network() {
    ydk:try "$@" 4>&1
    return $?
}
ydk:osint() {
    ydk:try "$@" 4>&1
    return $?
}
ydk:packer() {
    YDK_LOGGER_CONTEXT="packer"
    packer:validate:src-file() {
        local SRC_FILE=${1} && [ ! -f "$SRC_FILE" ] && ydk:log error "Invalid source file ${SRC_FILE}" && return 1
        [[ "$SRC_FILE" != *".cli.sh" ]] && [[ "$SRC_FILE" != *".ydk.sh" ]] && ydk:log error "Invalid file extension" && return 1
        local FILE_EXT="${SRC_FILE##*.}"
        if [[ "$SRC_FILE" != *".sh" ]] || [[ "$FILE_EXT" != "sh" ]]; then
            ydk:log error "Invalid file extension" && return 1
        fi
        local FILENAME=$(basename -- "$SRC_FILE") && FILENAME="${FILENAME%.*}" && FILENAME="${FILENAME%.*}" && [ -z "$FILENAME" ] && ydk:throw 22 "Invalid file name" && return 1
        if ! grep -q "^#!/usr/bin/env bash$" "$SRC_FILE"; then
            ydk:log error "Invalid shebang in source file: ${SRC_FILE}" && return 1
        fi
        local BUNDLE_NAME="${2:-"${FILENAME}.sh"}" && [ -z "$BUNDLE_NAME" ] && ydk:log error "Invalid bundle name" && return 1
        local FILE_BASEPATH=$(dirname -- "$SRC_FILE")
        local FILE_REALPATH=$(realpath -- "$FILE_BASEPATH")
        local FILE_RELATIVEPATH=$(realpath --relative-to="$SRC_FILE" "$FILE_BASEPATH")
        jq -n -c \
            --arg src "$SRC_FILE" \
            --arg name "$FILENAME" \
            --arg bundle "$BUNDLE_NAME" \
            --arg basepath "$FILE_BASEPATH" \
            --arg realpath "$FILE_REALPATH" \
            --arg relativepath "$FILE_RELATIVEPATH" \
            --argjson lib "$({
                find "$FILE_REALPATH" \
                    -type f \
                    -name "*.ydk.sh" \
                    -not -name "*.cli.sh" \
                    -not -name "$FILENAME" \
                    -not -name "$BUNDLE_NAME" \
                    -not -path "$FILE_REALPATH" |
                    sort | jq -R . | jq -s .
            })" \
            '{
                src: $src,
                name: $name,
                bundle: $bundle,
                basepath: $basepath,
                realpath: $realpath,
                relativepath: $relativepath,
                lib: $lib               
            }' >&4
        return 0
    }
    defaults() {
        {
            echo -n "{"
            echo -n "\"expires_at\":\"${YDK_CONFIG_PACKER_EXPIRE_AT:-"${YDK_PACKER_DEFAULTS[expires_at]:-"31/12/2999"}"}\","
            echo -n "\"dist\":\"${YDK_CONFIG_PACKER_DIST:-"${YDK_PACKER_DEFAULTS[dist]:-"./dist"}"}\","
            echo -n "\"release\": $(ydk:team release 4>&1),"
            echo -n "\"team\": $(ydk:team info 4>&1)"
            echo -n "}"
        } | jq -c . >&4
    }
    __packer:inject() {
        local FILE="$1"
        local TABS="${2:-0}"
        [[ ! -f "$FILE" ]] && ydk:log error "$FILE is not a valid file" && return 1
        local TABS_SPACES=$(printf "%${TABS}s")
        {
            grep -v "^#" "$FILE" |
                grep -v "^[[:space:]]*#[^!]" |
                grep -v "^$" |
                grep -v "^#!/usr/bin/env bash$" |
                grep -v "^# shellcheck disable" |
                grep -v "^#"
        } | sed -e "s/^/${TABS_SPACES}/" >&4
        return 0
    }
    pack() {
        local VALIDATION=$(packer:validate:src-file "$1" 4>&1)
        local PACK_DEFAUTLS=$(ydk:packer defaults 4>&1)
        ydk:log info "Bundling source file"        
        local BUNDLE_SRC=$(jq -r '.src' <<<"$VALIDATION")
        local BUNDLE_TMP=$(ydk:temp "bundle" 4>&1)
        echo "#!/bin/bash" >"$BUNDLE_TMP"
        local BUNDLE_ENTRYPOINT_NAME=$(mktemp -u -t "ywt:XXXXXXXXXX") && BUNDLE_ENTRYPOINT_NAME="${BUNDLE_ENTRYPOINT_NAME##*/}"
        {
            ydk:team copyright
            echo "# Builder: $(whoami | md5sum | cut -d' ' -f1)"
            local BUNDLE_NAME=$(jq -r '.name' <<<"$VALIDATION")
            local BUNDLE_IS_SDK=false
            [[ "$BUNDLE_NAME" == "ydk" ]] && BUNDLE_NAME="sdk" && BUNDLE_IS_SDK=true && BUNDLE_ENTRYPOINT_NAME="ydk"
            local BUNDLE_FILE_NAME=$(jq -r '.bundle' <<<"$VALIDATION") && BUNDLE_FILE_NAME=${BUNDLE_FILE_NAME//.sh/.sh}
            echo "# Bundle File Name: <$BUNDLE_FILE_NAME>"
            echo "# Bundle Entrypoint: <${BUNDLE_ENTRYPOINT_NAME}>"
            [[ "$BUNDLE_IS_SDK" == false ]] && {
                echo "curl -sSL https://raw.githubusercontent.com/cloudyellowteam/ywt-shell/main/packages/ydk/ydk.sh"
                echo "# Added YDK CLI"
                echo "source \"ydk.sh\""
                echo "${BUNDLE_ENTRYPOINT_NAME}(){"
                echo -e "\tset -e -o pipefail"
            }
            while read -r DEPENDENCIE; do
                __packer:inject "$DEPENDENCIE" 0 4>&1
            done < <(jq -r '.lib[]' <<<"$VALIDATION")
            __packer:inject "$BUNDLE_SRC" 0 4>&1
            [[ "$BUNDLE_IS_SDK" == false ]] && {
                echo "}"
                echo -e "[[ -z \"\$YDK_PACKAGE_RELEASE_INFO_${BUNDLE_NAME^^}\" ]] && declare -g -A YDK_PACKAGE_RELEASE_INFO_${BUNDLE_NAME^^}=("
                echo -e "\t[\"entrypoint\"]=\"${BUNDLE_ENTRYPOINT_NAME}\""
                echo -e "\t[\"expires_at\"]=\"$(jq -r .expires_at <<<"$PACK_DEFAUTLS")\""
                echo -e "\t[\"release\"]='$(
                    jq -cr '
                    .release
                ' <<<"$PACK_DEFAUTLS"
                )'"
                echo -e "\t[\"team\"]='$(jq -cr .team <<<"$PACK_DEFAUTLS")'"
                echo -e ") && readonly YDK_PACKAGE_RELEASE_INFO _${BUNDLE_NAME^^}&& export YDK_PACKAGE_RELEASE_INFO_${BUNDLE_NAME^^}"
                echo "if [[ \"\$#\" -gt 0 ]]; then"
                echo -e "\t${BUNDLE_ENTRYPOINT_NAME} \"\$@\""
                echo -e "\texit \$?"
                echo "fi"
            }
        } >>"$BUNDLE_TMP"
        local BUNDLE_FULL_PATH="$(jq -r '.realpath' <<<"$VALIDATION")/${BUNDLE_FILE_NAME}"
        rm -f "$BUNDLE_FULL_PATH"
        mv -f "$BUNDLE_TMP" "$BUNDLE_FULL_PATH"
        chmod +x "$BUNDLE_FULL_PATH"
        ydk:log info "Bundle ${BUNDLE_ENTRYPOINT_NAME^^} created. $BUNDLE_FULL_PATH"
        return 0
    }
    ydk:try "$@" 4>&1
    return $?
}
{
    [[ -z "$YDK_PACKER_DEFAULTS" ]] && declare -g -A YDK_PACKER_DEFAULTS=(
        [expires_at]="31/12/2999"
        [dist]="./dist"
    )
}
builder:v2() {
    YWT_LOG_CONTEXT="BUILDER"
    config() {
        local DEFAULT_EXPIRES_AT="${YWT_CONFIG_BUILDER_EXPIRES_AT:-"31/12/2999"}"
        local PATH_DIST=${2:-"${YWT_CONFIG_BUILDER_DIST:-"$(jq -r .path.dist <<<"$YWT_CONFIG")"}"} && readonly PATH_DIST
        local PATH_SRC=${3:-"${YWT_CONFIG_BUILDER_SRC:-"$(jq -r .path.src <<<"$YWT_CONFIG")"}"} && readonly PATH_SRC
        local PATH_SDK=$(jq -r .path.sdk <<<"$YWT_CONFIG") && SDK=$(realpath -- "$PATH_SDK") && readonly PATH_SDK
        local PATH_BIN=$(jq -r .path.bin <<<"$YWT_CONFIG") && readonly PATH_BIN
        {
            echo -n "{"
            echo -n "\"expires\": \"$DEFAULT_EXPIRES_AT\","
            echo -n "\"path/dist\": \"$PATH_DIST\","
            echo -n "\"path/src\": \"$PATH_SRC\","
            echo -n "\"path/sdk\": \"$PATH_SDK\","
            echo -n "\"path/bin\": \"$PATH_BIN\""
            echo -n "}"
        } | jq -c .
    }
    info() {
        {
            echo -n "{"
            echo -n "\"date\": \"$(date -Iseconds)\","
            echo -n "\"id\": \"$(git rev-parse HEAD 2>/dev/null || echo "Unknown")\","
            echo -n "\"branch\": \"$(git rev-parse --abbrev-ref HEAD 2>/dev/null || echo "Unknown")\","
            echo -n "\"tag\": \"$(git describe --tags 2>/dev/null || echo "Unknown")\","
            echo -n "\"commit\": \"$(git rev-parse --short HEAD 2>/dev/null || echo "Unknown")\","
            echo -n "\"author\": \"$(git log -1 --pretty=format:'%an <%ae>' 2>/dev/null || echo "Unknown")\","
            echo -n "\"message\": \"$(git log -1 --pretty=format:'%s' 2>/dev/null || echo "Unknown")\""
            echo -n "}"
        } | jq -c .
    }
    _prepare() {
        while read -r KEY VALUE; do
            [[ "$KEY" =~ ^path/ ]] && [[ ! -d "$VALUE" ]] && mkdir -p "${VALUE}" && echo "Created directory ${VALUE}" | logger verbose
        done < <(jq -r 'to_entries|map("\(.key) \(.value|tostring)")|.[]' <<<"$(config "$@")")
        echo "Directories created" | logger info
    }
    _cleanup() {
        local KEEP_SOURCE="${YWT_CONFIG_BUILDER_KEEP_SOURCE:-false}"
        [[ "$KEEP_SOURCE" == true ]] && echo "Keeping sources" | logger info && return 0
        local CONFIG=$(config "$@")
        local DIST=$(jq -r '.["path/dist"]' <<<"$CONFIG")
        rm -f "${DIST}/"*.sh >/dev/null
        rm -f "${DIST}/"*.c >/dev/null
        echo "Sources removed" | logger info
    }
    _bundle:validate() {
        local CONFIG=$(config "$@")
        local SRC_FILE=${1:?} && [ ! -f "$SRC_FILE" ] && echo "{ \"error\": \"Invalid source file\" }" && return 1
        local FILE_EXT="${SRC_FILE##*.}" && [[ "$FILE_EXT" != "sh" ]] && echo "{ \"error\": \"Invalid file extension\" }" && return 1
        if ! grep -q "^#!/usr/bin/env bash$" "$SRC_FILE"; then
            echo "{ \"error\": \"Invalid shebang\" }" && return 1
            return 1
        fi
        local FILENAME=$(basename -- "$SRC_FILE") && FILENAME="${FILENAME%.*}"
        local BUNDLE_NAME="${2:-"${FILENAME}.sh"}" && [ -z "$BUNDLE_NAME" ] && echo "{ \"error\": \"Invalid bundle name\" }" && return 1
        local FILE_BASEPATH=$(dirname -- "$SRC_FILE")
        local FILE_REALPATH=$(realpath -- "$FILE_BASEPATH")
        local FILE_RELATIVEPATH=$(realpath --relative-to="$SRC_FILE" "$FILE_BASEPATH")
        if [[ ! -d "${FILE_REALPATH}/lib" ]]; then
            echo "{ \"error\": \"${FILE_REALPATH}/lib is not a valid directory\" }" && return 1
        fi
        local SRC_PATH=$(jq -r '.["path/src"]' <<<"$CONFIG")
        local TARGET_FILE="${SRC_PATH}/${BUNDLE_NAME}" && [[ -f "$TARGET_FILE" ]] && rm -f "$TARGET_FILE"
        {
            echo -n "$CONFIG"
            echo -n "{"
            echo -n "\"success\": true,"
            echo -n "\"file\": \"$SRC_FILE\","
            echo -n "\"filename\": \"$FILENAME\","
            echo -n "\"extension\": \"$FILE_EXT\","
            echo -n "\"basepath\": \"$FILE_BASEPATH\","
            echo -n "\"realpath\": \"$FILE_REALPATH\","
            echo -n "\"relativepath\": \"$FILE_RELATIVEPATH\","
            echo -n "\"lib\": \"$FILE_REALPATH/lib\","
            echo -n "\"name\": \"$BUNDLE_NAME\","
            echo -n "\"output\": \"$TARGET_FILE\""
            echo -n "}"
        } | jq -sc '
            .[0] as $config |
            .[1] as $validation |
            {
                config: $config,
                validation: $validation
            }
        '
        return 0
    }
    _bundle:inject() {
        local FILE="$1"
        [[ ! -f "$FILE" ]] && echo "{ \"error\": \"$FILE is not a valid file\" }" && return 0
        grep -v "^#" "$FILE" | grep -v "^[[:space:]]*#[^!]" | grep -v "^$" | grep -v "^#!/usr/bin/env bash$" | grep -v "^# shellcheck disable" | grep -v "^#"
    }
    _bundle:checksum:generate() {
        local TARGET=${1:?}
        local EXPIRES_AT="${2:-$CONFIG_EXPIRES_AT}"
        local FILENAME && FILENAME=$(basename -- "$TARGET") && FILENAME="${FILENAME%.*}"
        local IS_BINARY=false
        LC_ALL=C grep -a '[^[:print:][:space:]]' "$TARGET" >/dev/null && IS_BINARY=true
        echo "{"
        echo "  \"file\": \"$TARGET\","
        echo "  \"expires_at\": \"$EXPIRES_AT\","
        echo "  \"size\": \"$(du -h "$TARGET" | awk '{print $1}' 2>/dev/null)\","
        echo "  \"md5\": \"$(md5sum "$TARGET" | awk '{print $1}' 2>/dev/null)\","
        echo "  \"sha1\": \"$(sha1sum "$TARGET" | awk '{print $1}' 2>/dev/null)\","
        echo "  \"sha256\": \"$(sha256sum "$TARGET" | awk '{print $1}' 2>/dev/null)\","
        echo "  \"sha512\": \"$(sha512sum "$TARGET" | awk '{print $1}' 2>/dev/null)\"",
        echo "  \"created_at\": \"$(date -Iseconds)\"",
        echo "  \"binary\": $IS_BINARY"
        echo "}"
    }
    bundle() {
        local VALIDATION=$(_bundle:validate "$@")
        if ! jq -r '.validation.success' <<<"$VALIDATION" | grep -q true; then
            echo "$VALIDATION" | jq -c .
            return 1
        fi
        _prepare
        _cleanup
        local BUNDLE_FILE=$(jq -r '.validation.output' <<<"$VALIDATION")
        local BUNDLE_LIB_PATH=$(jq -r '.validation.lib' <<<"$VALIDATION")
        local BUNDLE_SRC_PATH=$(jq -r '.config["path/src"]' <<<"$VALIDATION")
        local BUNDLE_OUTPUT_TMP=$(mktemp -u -t "ywt-XXXX")
        echo "#!/bin/bash" >"$BUNDLE_FILE"
        {
            copyright
            while read -r FILE; do
                local FILENAME && FILENAME=$(basename -- "$FILE")
                local RELATIVE_PATH && RELATIVE_PATH=$(realpath --relative-to="$BUNDLE_SRC_PATH" "$FILE")
                local RELATIVE_PATH && RELATIVE_PATH=$(dirname -- "$RELATIVE_PATH")
                echo "# <$FILENAME>"
                _bundle:inject "$FILE"
                echo "# </$FILENAME>"
                {
                    echo -n "{"
                    echo -n "\"file\": \"$FILE\","
                    echo -n "\"path\": \"$RELATIVE_PATH\","
                    echo -n "\"content\": \"$(cat "$FILE" | base64 -w 0)\","
                    echo -n "\"checksum\": $(_bundle:checksum:generate "$FILE")"
                    echo -n "}"
                } >>"$BUNDLE_OUTPUT_TMP"
            done < <(find "$BUNDLE_LIB_PATH" -type f -name "*.ywt.sh" | sort)
            local SRC_FILE=$(jq -r '.validation.file' <<<"$VALIDATION")
            echo "# <$SRC_FILE>"
            _bundle:inject "$SRC_FILE"
            echo "# </$SRC_FILE>"
        } >>"$BUNDLE_FILE"
        echo "Bundle created" | logger info
        cat "$BUNDLE_FILE"
    }
    __nnf "$@" || usage "$?" "builder" "$@" && return 1
    return 0
}
builder:v1() {
    YWT_LOG_CONTEXT="BUILDER"
    local CONFIG_EXPIRES_AT="${YWT_CONFIG_BUILDER_EXPIRES_AT:-"31/12/2999"}"
    local DIST=${2:-"${YWT_CONFIG_BUILDER_DIST:-"$(jq -r .path.dist <<<"$YWT_CONFIG")"}"} && readonly DIST
    local SRC=${3:-"${YWT_CONFIG_BUILDER_SRC:-"$(jq -r .path.src <<<"$YWT_CONFIG")"}"} && readonly SRC
    local SDK=$(jq -r .path.sdk <<<"$YWT_CONFIG") && SDK=$(realpath -- "$SDK") && readonly SDK
    local BIN=$(jq -r .path.bin <<<"$YWT_CONFIG") && readonly BIN
    _prepare() {
        [[ ! -d "$DIST" ]] && mkdir -p "${DIST}"
        rm -fR "${DIST:?}"/*
        [[ ! -d "$BIN" ]] && mkdir -p "${BIN}"
        if ! command -v shc &>/dev/null; then
            colors apply "red" "$YWT_LOG_CONTEXT compiler is not installed, trying install" | logger warn
            apt-get install shc -y || return 1
        fi
        local SHC_INSTALLED && SHC_INSTALLED=$(command -v shc)
        [[ -z "$SHC_INSTALLED" ]] && colors apply "red" "$YWT_LOG_CONTEXT compiler is not installed" | logger error && return 1
        colors apply "green" "$YWT_LOG_CONTEXT Compiler is installed" | logger success
    }
    _cleanup() {
        local KEEP_SOURCE="${YWT_CONFIG_BUILDER_KEEP_SOURCE:-false}"
        [[ "$KEEP_SOURCE" == true ]] && echo "Keeping sources" | logger info && return 0
        rm -f "${DIST}/"*.sh | logger verbose
        rm -f "${DIST}/"*.c | logger verbose
        echo "Sources removed" | logger info
    }
    _stats() {
        local TARGET=${1:?}
        local EXPIRES_AT="${2:-$CONFIG_EXPIRES_AT}"
        local FILENAME && FILENAME=$(basename -- "$TARGET") && FILENAME="${FILENAME%.*}"
        local IS_BINARY=false
        LC_ALL=C grep -a '[^[:print:][:space:]]' "$TARGET" >/dev/null && IS_BINARY=true
        echo "{"
        echo "  \"file\": \"$TARGET\","
        echo "  \"expires_at\": \"$EXPIRES_AT\","
        echo "  \"size\": \"$(du -h "$TARGET" | awk '{print $1}' 2>/dev/null)\","
        echo "  \"md5\": \"$(md5sum "$TARGET" | awk '{print $1}' 2>/dev/null)\","
        echo "  \"sha1\": \"$(sha1sum "$TARGET" | awk '{print $1}' 2>/dev/null)\","
        echo "  \"sha256\": \"$(sha256sum "$TARGET" | awk '{print $1}' 2>/dev/null)\","
        echo "  \"sha512\": \"$(sha512sum "$TARGET" | awk '{print $1}' 2>/dev/null)\"",
        echo "  \"created_at\": \"$(date -Iseconds)\"",
        echo "  \"binary\": $IS_BINARY"
        echo "}"
    }
    __bundle() {
        local SRC_FILE=${1:?} && [ ! -f "$SRC_FILE" ] && echo "Invalid source file" | logger error && return 1
        local FILE_EXT="${SRC_FILE##*.}" && [[ "$FILE_EXT" != "sh" ]] && echo "Invalid file extension" | logger error && return 1
        local FILENAME=$(basename -- "$SRC_FILE") && FILENAME="${FILENAME%.*}"
        local FILE_BASEPATH=$(dirname -- "$SRC_FILE")
        local FILE_REALPATH=$(realpath -- "$FILE_BASEPATH")
        local FILE_RELATIVEPATH=$(realpath --relative-to="$SRC_FILE" "$FILE_BASEPATH")
        local BUNDLE_NAME="${2:-"${FILENAME}.sh"}" && [ -z "$BUNDLE_NAME" ] && echo "Invalid bundle name" | logger error && return 1
        local EXPIRES_AT="${3:-$CONFIG_EXPIRES_AT}" && [ -z "$EXPIRES_AT" ] && EXPIRES_AT="31/12/2999"
        local LIB=${FILE_REALPATH}/lib && [[ ! -d "$LIB" ]] && echo "${LIB} is not a valid directory" | logger error && return 0
        local TARGET_FILE="${SRC}/${BUNDLE_NAME}" && [[ -f "$TARGET_FILE" ]] && rm -f "$TARGET_FILE"
        _inject() {
            local FILE="$1"
            [[ ! -f "$FILE" ]] && echo "$FILE is not a valid file" | logger error && return 0
            grep -v "^#" "$FILE" | grep -v "^$" | grep -v "^#!/usr/bin/env bash"
        }
        {
            echo "#!/bin/bash"
            echo "# shellcheck disable=SC2044,SC2155,SC2317"
            copyright
            while read -r FILE; do
                local FILENAME && FILENAME=$(basename -- "$FILE")
                local RELATIVE_PATH && RELATIVE_PATH=$(realpath --relative-to="$SRC" "$FILE")
                local RELATIVE_PATH && RELATIVE_PATH=$(dirname -- "$RELATIVE_PATH")
                echo -e "# $(_stats "$FILE" "$EXPIRES_AT" | jq -c .)\n"
                _inject "$FILE"
                echo -e "\n# end of $FILENAME\n"
            done < <(find "$LIB" -type f -name "*.ywt.sh" | sort)
            echo -e "# $(_stats "$SRC_FILE" "$EXPIRES_AT" | jq -c .)\n"
            _inject "$SRC_FILE"
            echo -e "\n# end of $SRC_FILE\n"
        } >>"$TARGET_FILE"
        _stats "$TARGET_FILE" "$EXPIRES_AT" | jq -Cc . | logger info
    }
    __build_file() {
        local FILE=$1 && readonly FILE && [[ ! -f "$FILE" ]] && echo "$FILE is not a valid file" | logger error && return 0
        local FILE_DIR=$(dirname -- "$FILE") && readonly FILE_DIR
        local EXPIRES_AT="${2:-$CONFIG_EXPIRES_AT}" && [ -z "$EXPIRES_AT" ] && EXPIRES_AT="31/12/2999"
        local FILENAME && FILENAME=$(basename -- "$FILE") && FILENAME="${FILENAME%.*}"
        colors apply "blue" "Building file ${FILE} valid until ${EXPIRES_AT}" | logger info
        shc -r -f "${FILE}" -e "${EXPIRES_AT}" -m "File expired since ${EXPIRES_AT}, please contact us to renew. $(jq -Cc .yellowteam <<<"$YWT_CONFIG")"
        [ -f "$DIST/$FILENAME.sh" ] && rm -f "$DIST/$FILENAME.sh"
        [ -f "$DIST/$FILENAME.c" ] && rm -f "$DIST/$FILENAME.c"
        [ -f "${BIN}/$FILENAME" ] && rm -f "${BIN}/$FILENAME"
        cp -f "$FILE" "$DIST/$FILENAME.sh"      # /dist/file.sh
        mv -f "${FILE}.x.c" "$DIST/$FILENAME.c" # /dist/file.c
        mv -f "${FILE}.x" "${BIN}/$FILENAME"    # /bin/file
        colors apply "green" "Build done. run ${BIN}/${FILENAME}" | logger success
        jq -Cn \
            --argjson sh "$(_stats "$DIST/$FILENAME.sh" "$EXPIRES_AT")" \
            --argjson c "$(_stats "$DIST/$FILENAME.c" "$EXPIRES_AT")" \
            --argjson bin "$(_stats "${BIN}/$FILENAME" "$EXPIRES_AT")" \
            '{sh: $sh, c: $c, bin: $bin}' | logger info
    }
    _build_sdk() {
        _prepare
        __bundle "$SDK/sdk.sh" "ywt.sh" "31/12/2999"
        __build_file "$SRC/ywt.sh" "31/12/2999"
        return 0
    }
    inspect() {
        jq -r '.path' <<<"$YWT_CONFIG"
    }
    __nnf "$@" || usage "$?" "builder" "$@" && return 1
    return 0
}
ydk:param() {
    ydk:try "$@" 4>&1
    return $?
}
ydk:parse() {
    ydk:try "$@" 4>&1
    return $?
}
ydk:process() {
    inspect() {
        jq -cn \
            --arg pid "$$" \
            --arg etime "$(etime 4>&1)" \
            --argjson cli "$(ydk:cli)" \
            --argjson package "{}" \
            '{ 
                pid: $pid,
                etime: $etime,
                cli: $cli,
                package: $package
            }' >&4
    }
    ydk:try "$@" 4>&1
    return $?
}
ydk:resources() {
    ydk:try "$@" 4>&1
    return $?
}
ydk:scan() {
    ydk:try "$@" 4>&1
    return $?
}
ydk:scap() {
    ydk:try "$@" 4>&1
    return $?
}
ydk:screen() {
    YDK_LOGGER_CONTEXT="screen"
    [[ -z "$YDK_SCREEN_REQUIRE_COLS" ]] && local YDK_SCREEN_REQUIRE_COLS=101 && readonly YDK_SCREEN_REQUIRE_COLS
    [[ -z "$YDK_SCREEN_REQUIRE_ROWS" ]] && local YDK_SCREEN_REQUIRE_ROWS=35 && readonly YDK_SCREEN_REQUIRE_ROWS
    size() {
        {
            if command -v stty &>/dev/null; then
                echo -n "{"
                stty size | {
                    read -r rows cols
                    echo -n "\"from\":\"stty\",\"rows\":$rows,\"cols\":$cols"
                }
                echo -n "}"
            elif command -v tput &>/dev/null; then
                echo -n "{"
                echo -n "\"from\":\"tput\",\"rows\":$(tput lines),\"cols\":$(tput cols)"
                echo -n "}"
            elif [[ -n "$COLUMNS" && -n "$LINES" ]]; then
                echo -n "{\"from\":\"env\",\"rows\":$LINES,\"cols\":$COLUMNS}"
            else
                echo -n "{"
                echo -n "\"\"from\":\"requirement\",rows\":$YDK_SCREEN_REQUIRE_ROWS,\"cols\":$YDK_SCREEN_REQUIRE_COLS"
                echo -n "}"
            fi
        } | jq -c >&4
    }
    defaults() {
        {
            echo -n "{"
            echo -n "\"rows\":$YDK_SCREEN_REQUIRE_ROWS,\"cols\":$YDK_SCREEN_REQUIRE_COLS"
            echo -n "}"
        } | jq -c >&4
    }
    expectSize() {
        local WIDTH=${1:-$YDK_SCREEN_REQUIRE_COLS}
        local HEIGHT=${2:-$YDK_SCREEN_REQUIRE_ROWS}
        local SCREEN_SIZE=$(size 4>&1)
        local CURRENT_WIDTH=$(echo "$SCREEN_SIZE" | jq -r '.cols')
        local CURRENT_HEIGHT=$(echo "$SCREEN_SIZE" | jq -r '.rows')
        if ((CURRENT_WIDTH >= WIDTH && CURRENT_HEIGHT >= HEIGHT)); then
            ydk:log info "Screen size is enough. Required: ${WIDTH}x${HEIGHT}. Actual: ${CURRENT_WIDTH}x${CURRENT_HEIGHT}"
            return 0
        fi
        ydk:log warn "Screen size is not enough. Required: ${WIDTH}x${HEIGHT}. Actual: ${CURRENT_WIDTH}x${CURRENT_HEIGHT}"
        return 1
    }
    align() {
        local ALIGNMENT="$1"
        local CURRENT_WIDTH=$(size 4>&1 | jq -r '.cols')
        while IFS= read -r LINE; do
            local TEXT_LENGHT=${#LINE}
            local SPACES=$((CURRENT_WIDTH - TEXT_LENGHT))
            if [ "$SPACES" -le 0 ]; then
                echo -e "$LINE" >&1
            else
                case "$ALIGNMENT" in
                left)
                    printf "%-${SPACES}s%s\n" "$LINE" "" >&1
                    ;;
                right)
                    printf "%${SPACES}s%s\n" "" "$LINE" >&1
                    ;;
                center)
                    local PADDING=$((SPACES / 2))
                    printf "%${PADDING}s$LINE%${PADDING}s\n" "" "" >&1
                    ;;
                *)
                    echo -e "$LINE" >&1
                    ;;
                esac
            fi
        done
        return 0
    }
    ydk:try "$@" 4>&1
    return $?
}
ydk:secops() {
    YDK_LOGGER_CONTEXT="secops"
    ydk:log info "Continuous Security Operations"
    [[ -z "$YDK_SECOPS_SPECS" ]] && declare -A YDK_SECOPS_SPECS=(
        ["all"]="."
        ["count"]=". | length"
        ["query"]=".[] | select(.name == \$SCANNER_ID or .id == \$SCANNER_ID)"
        ["installed"]="
            .[] | 
            if .id == \$SCANNER_ID then 
                .installed = \$SCANNER_INSTALLED
            else 
                .installed = false
            end"
        ["available"]=".[] | select(.installed == true or .installed == \"true\")"
        ["unavailable"]=".[] | select(.installed == false or .installed == \"false\")"
        ["packages"]=".packages[]"
        ["status-log"]='
            .[1] |
            if .status == 0 then
                "success"
            else
                "error"
            end'
        ["result-summary"]='
            .[0] as $scanner |
            .[1] as $result |
            "/\($scanner.name)/\($scanner.path) done with status \($result.status) in \($result.elapsed_time) seconds. Content type \($result.content.type), at \($result.location)"'
        ["result-output"]='
            .[0] as $scanner |
            .[1] as $result |
            {
                "scanner": $scanner,
                "result": $result
            }'
    ) && readonly YDK_SECOPS_SPECS && export YDK_SECOPS_SPECS
    [[ -z "${YDK_SECOPS_CONFIG[*]}" ]] && declare -A YDK_SECOPS_CONFIG=(
        ["scanners"]="/workspace/rapd-shell/assets/scanners.json"
        ["auto-install"]=true
        ["auto-uninstall"]=false
        ["keep-output"]=false
        ["output-file"]="secops-output"
    ) 
    [[ ! -f "${YDK_SECOPS_CONFIG[scanners]}" ]] && YDK_SECOPS_CONFIG[scanners]=$(ydk:assets location scanners 4>&1)
    scanners() {
        local SCANNERS_FILE="${YDK_SECOPS_CONFIG[scanners]}"
        [ ! -f "$SCANNERS_FILE" ] && echo "[]" >&4 && ydk:log error "No scanners found" && return 1
        list() {
            ydk:log info "$(jq -cr "${YDK_SECOPS_SPECS[count]}" "$SCANNERS_FILE") scanners available"
            {
                while read -r SCANNER && [ -n "$SCANNER" ]; do
                    [ -z "$SCANNER" ] && continue
                    local SCANNER_ID=$(jq -r '.id' <<<"$SCANNER") && [ -z "$SCANNER_ID" ] && continue
                    local SCANNER_NAME=$(jq -r '.name' <<<"$SCANNER") && [ -z "$SCANNER_NAME" ] && continue
                    local SCANNER_INSTALLED=false && command -v "$SCANNER_NAME" 2>/dev/null 1>/dev/null && SCANNER_INSTALLED=true
                    jq -rc \
                        --arg SCANNER_ID "$SCANNER_ID" \
                        --arg SCANNER_INSTALLED "$SCANNER_INSTALLED" \
                        "${YDK_SECOPS_SPECS[installed]}" "$SCANNERS_FILE"
                done < <(jq -c "${YDK_SECOPS_SPECS[all]} | .[]" "$SCANNERS_FILE")
            } | jq -rsc '.' >&4
            ydk:log success "Use 'scanners available' to list available scanners"
            return 0
        }
        get() {
            local SCANNER_ID=$1
            local SCANNER=$(
                jq -cr --arg SCANNER_ID "$SCANNER_ID" "${YDK_SECOPS_SPECS[query]}" <<<"$(list 4>&1)"
            )
            [ -z "$SCANNER" ] && echo "{}" >&4 && ydk:log error "Scanner ${SCANNER_ID} not found" && return 22
            jq -c . <<<"$SCANNER" >&4
            ydk:log success "Scanner found $(jq -cr '.name' <<<"$SCANNER")"
            return 0
        }
        available() {
            local SCANNERS=$(list 4>&1)
            local SCANNERS_INSTALLED=$(jq -cr "${YDK_SECOPS_SPECS[available]}" <<<"$SCANNERS")
            echo "$SCANNERS_INSTALLED" >&4
            local SCANNERS_INSTALLED_COUNT=$(jq -cr "${YDK_SECOPS_SPECS[count]}" <<<"$SCANNERS_INSTALLED") &&
                SCANNERS_INSTALLED_COUNT="${SCANNERS_INSTALLED_COUNT:-0}"
            [[ "$SCANNERS_INSTALLED_COUNT" -eq 0 ]] && ydk:log warn "No scanners available" && return 251
            [[ "$SCANNERS_INSTALLED_COUNT" -gt 0 ]] && ydk:log success "${SCANNERS_INSTALLED_COUNT} scanners available" && return 0
        }
        unavailable() {
            local SCANNERS=$(list 4>&1)
            local SCANNERS_UNINSTALLED=$(jq -cr "${YDK_SECOPS_SPECS[unavailable]}" <<<"$SCANNERS")
            echo "$SCANNERS_UNINSTALLED" >&4
            local SCANNERS_UNINSTALLED_COUNT=$(jq -cr "${YDK_SECOPS_SPECS[count]}" <<<"$SCANNERS_UNINSTALLED") &&
                SCANNERS_UNINSTALLED_COUNT="${SCANNERS_UNINSTALLED_COUNT:-0}"
            ydk:log success "${SCANNERS_UNINSTALLED_COUNT} scanners unavailable"
            return 0
        }
        manager() {
            local YDK_SECOPS_MANAGER_ACTION=$1 && [ -z "$YDK_SECOPS_MANAGER_ACTION" ] && return 22
            shift
            ydk:log info "SecOps Manager $YDK_SECOPS_MANAGER_ACTION"
            for SCANNER_NAME in "$@"; do
                local SCANNER=$(jq -c --arg SCANNER_ID "$SCANNER_NAME" "${YDK_SECOPS_SPECS[query]}" <<<"$(list 4>&1)")
                [ -z "$SCANNER" ] && echo "{}" >&4 && ydk:log error "Scanner ${SCANNER_NAME} not found" && return 22
                local SCANNER_ID=$(jq -r '.id' <<<"$SCANNER") && [ -z "$SCANNER_ID" ] && continue
                read -r -a SCANNER_PACKAGES <<<"$(jq -r '.packages[]' <<<"$SCANNER")" && [ -z "${SCANNER_PACKAGES[*]}" ] && continue
                local SCANNER_INSTALLED=false && command -v "$SCANNER_NAME" 2>/dev/null 1>/dev/null && SCANNER_INSTALLED=true
                ydk:log info "Scanner $SCANNER_NAME is installed: $SCANNER_INSTALLED, packages: ${SCANNER_PACKAGES[*]}"
                case "$YDK_SECOPS_MANAGER_ACTION" in
                install)
                    if [ "$SCANNER_INSTALLED" = false ]; then
                        ydk:upm install "$SCANNER_NAME" 4>&1
                    fi
                    ;;
                uninstall)
                    if [ "$SCANNER_INSTALLED" = true ]; then
                        ydk:upm cli 4>&1
                    fi
                    ;;
                *)
                    ydk:log error "Unsupported action $YDK_SECOPS_MANAGER_ACTION"
                    return 22
                    ;;
                esac
            done
            return 0
        }
        install() {
            if ! manager install "$@"; then
                ydk:log error "Failed to install scanner $SCANNER_NAME"
                return 1
            fi
        }
        uninstall() {
            if ! manager uninstall "$@"; then
                ydk:log error "Failed to uninstall scanner $SCANNER_NAME"
                return 1
            fi
        }
        ydk:try "$@" 4>&1
        return $?
    }
    secops:cli:entrypoint() {
        [ -z "$1" ] && return 22
        local API_SCANNER_NAME=$(cut -d'/' -f1 <<<"$1")
        local API_SCANNER_PATH=${1#"$API_SCANNER_NAME"} && API_SCANNER_PATH=${API_SCANNER_PATH#/}
        [ -z "$API_SCANNER_NAME" ] && return 22
        local API_SCANNER=$({
            if ! scanners get "$API_SCANNER_NAME" 4>&1 >&4; then
                ydk:log error "Scanner $API_SCANNER_NAME not found"
                return 10
            fi
            return 0
        } 4>&1)
        [ -z "$API_SCANNER" ] && return 22
        if ! {
            jq -cr \
                --arg API_SCANNER_NAME "$API_SCANNER_NAME" \
                --arg API_SCANNER_PATH "${API_SCANNER_PATH:-""}" \
                --argjson SCANNER "$(jq -c . <<<"$API_SCANNER")" \
                '
                {
                    "scanner":$SCANNER,
                    "path":$API_SCANNER_PATH,
                    "name":$API_SCANNER_NAME
                }' <<<"{}"
        } 2>/dev/null >&4; then
            ydk:log error "Scanner $SCANNER_CMD endpoint unavailable"
            return 1
        fi
        return 0
    }
    secops:cli:arg() {
        {
            for ARG in "$@"; do
                case "$ARG" in
                *\{\{.*\}\}*)
                    echo -n "$(ydk:interpolate "$ARG" "$@" 4>&1),"
                    ;;
                *) ;;
                esac
                if ydk:is number "$ARG"; then
                    echo -n "$ARG,"
                elif ydk:is boolean "$ARG"; then
                    echo -n "$ARG,"
                elif jq -e . <<<"$ARG" 2>/dev/null 1>/dev/null; then
                    echo -n "$(jq -c . <<<"$ARG"),"
                else
                    echo -n "\"$ARG\","
                fi
            done
        } | sed 's/,$//' >&4
        return $?
    }
    secops:cli:result:issarif() {
        local SCANNER_OUTPUT_FILE=$1
        jq -c '
             .version
             | select(. == "2.1.0")
             | .runs
             | select(. != null)
             | .[]
             | .tool
             | select(. != null)
             | .driver
             | select(. != null)
        ' <<<"$SCANNER_OUTPUT_FILE" 2>/dev/null 1>/dev/null
        return $?
    }
    secops:cli:result:content() {
        local SCANNER_OUTPUT_FILE=$1
        {
            local SCANNER_OUTPUT_TYPE=$({
                if jq -e . "$SCANNER_OUTPUT_FILE" 2>/dev/null 1>/dev/null; then
                    if secops:cli:result:issarif "$SCANNER_OUTPUT_FILE"; then
                        echo -n "sarif"
                    else
                        echo -n "json"
                    fi
                else
                    echo -n "plain"
                fi
            })
            echo -n "{"
            echo -n "\"type\":\"$SCANNER_OUTPUT_TYPE\","
            echo -n "\"data\":"
            case "$SCANNER_OUTPUT_TYPE" in
            "sarif" | "json")
                jq -c . "$SCANNER_OUTPUT_FILE" 2>/dev/null
                ;;
            "plain")
                echo -n "\"$(sed 's/"/\\"/g' <"$SCANNER_OUTPUT_FILE" 2>/dev/null)\""
                ;;
            *)
                echo -n "\"${SCANNER_OUTPUT_FILE}\""
                ;;
            esac
            echo -n "}"
        } | jq -c . >&4
    }
    secops:cli:result() {
        local SCANNER_OUTPUT_FILE=$1
        local SCANNER_STATUS=$2
        local SCANNER_PID=$3
        local SCANNER_START_AT=$4
        local SCANNER_END_AT=$(date +%s)
        local SCANNER_ELAPSED_TIME=$((SCANNER_END_AT - SCANNER_START_AT))
        {
            echo -n "{"
            echo -n "\"status\":$SCANNER_STATUS,"
            echo -n "\"pid\":$SCANNER_PID,"
            echo -n "\"location\":\"$SCANNER_OUTPUT_FILE\","
            echo -n "\"start_at\":$SCANNER_START_AT,"
            echo -n "\"end_at\":$SCANNER_END_AT,"
            echo -n "\"elapsed_time\":$SCANNER_ELAPSED_TIME,"
            echo -n "\"content\": $(secops:cli:result:content "$SCANNER_OUTPUT_FILE" 4>&1)"
            echo -n "}"
        } | jq -c . 2>/dev/null >&4
        return "$SCANNER_STATUS"
    }
    cli() {
        local SCANNER_ENTRYPOINT=$(secops:cli:entrypoint "$@" 4>&1)
        [ -z "$SCANNER_ENTRYPOINT" ] && return 22
        shift
        local SCANNER_CLI=$(jq -r '.scanner.cli' <<<"$SCANNER_ENTRYPOINT")
        [ -z "$SCANNER_CLI" ] && return 22
        local SCANNER_CMD=$(jq -r ".scanner.cli.cmd" <<<"$SCANNER_ENTRYPOINT")
        [ -z "$SCANNER_CMD" ] && return 22
        local SCANNER_NAME=$(jq -r '.name' <<<"$SCANNER_ENTRYPOINT")
        [ -z "$SCANNER_NAME" ] && return 22
        if ! command -v "$SCANNER_CMD" 2>/dev/null 1>/dev/null; then
            ydk:log error "Scanner $SCANNER_CMD is not installed"
            return 1
        fi
        read -r -a SCANNER_CMD_DEFAULT_ARGS <<<"$(jq -r '.scanner.cli.args[]' <<<"$SCANNER_ENTRYPOINT")"
        [ -z "${SCANNER_CMD_DEFAULT_ARGS[*]}" ] && return 22
        local SCANNER_CLI_METADATA=$({
            {
                echo -n "{"
                echo -n "\"scanner\":$(jq -c '.scanner | del(.cli)' <<<"$SCANNER_ENTRYPOINT"),"
                echo -n "\"cmd\":["
                echo -n "\"$SCANNER_CMD\","
                secops:cli:arg "${SCANNER_CMD_DEFAULT_ARGS[@]}" "$@" 4>&1
                echo -n ",\"\""
                echo -n "]"
                echo -n "}"
                return 0
            } >&4
        } 4>&1)
        if ! jq . 2>/dev/null 1>/dev/null <<<"${SCANNER_CLI_METADATA}"; then # >&4; then
            ydk:log error "Scanner $SCANNER_CMD cli unavailable"
            return 1
        fi
        [ -z "$SCANNER_CLI_METADATA" ] && return 22
        readarray -t SCANNER_COMMAND <<<"$(jq -cr '.cmd[]' <<<"$SCANNER_CLI_METADATA")"
        [ -z "${SCANNER_COMMAND[*]}" ] && return 22
        [[ "${#SCANNER_COMMAND[@]}" -eq 0 ]] && return 22
        [[ "${SCANNER_COMMAND[0]}" == "null" ]] && return 22
        local SCANNER_CMD=${SCANNER_COMMAND[0]}
        local SCANNER_CMD_ARGS=("${SCANNER_COMMAND[@]:1}")
        local SCANNER_CLI_OUTPUT=$(ydk:temp "secops-cli-output" 4>&1)
        ydk:log info "Running scanner $SCANNER_CMD ${SCANNER_CMD_ARGS[*]}"
        local SCANNER_CLI_START_AT=$(date +%s)
        $SCANNER_CMD "${SCANNER_CMD_ARGS[@]}" 2>/dev/null 1>"$SCANNER_CLI_OUTPUT"
        local SCANNER_PID=$!
        local SCANNER_STATUS=$?
        local SCANNER_CMD_LOG_ACTION="info"
        [ "$SCANNER_STATUS" -ne 0 ] && SCANNER_CMD_LOG_ACTION="error"
        ydk:log "$SCANNER_CMD_LOG_ACTION" "Scanner $SCANNER_CMD exited with status $SCANNER_STATUS"
        ydk:log output "Results on $SCANNER_CLI_OUTPUT"
        local SCANNER_CLI_RESULT=$(secops:cli:result "$SCANNER_CLI_OUTPUT" "$SCANNER_STATUS" "$SCANNER_PID" "$SCANNER_CLI_START_AT" 4>&1)
        [ -z "$SCANNER_CLI_RESULT" ] && return 22
        jq -c . <<<"$SCANNER_CLI_RESULT" >"$SCANNER_CLI_OUTPUT"
        if [[ "$(type -t ydk:secops:result:"${SCANNER_NAME}" 2>/dev/null)" == "function" ]]; then
            ydk:log debug "Parsing result"
            if ! ydk:secops:result:"${SCANNER_NAME}" "$SCANNER_CLI_OUTPUT" 2>/dev/null; then
                local YDK_SECOPS_RESULT_STATUS=$?
                ydk:log error "($YDK_SECOPS_RESULT_STATUS) Failed to parse result for scanner $SCANNER_NAME"
                return "$YDK_SECOPS_RESULT_STATUS"
            else
                ydk:log success "($YDK_SECOPS_RESULT_STATUS) Parsed result for scanner $SCANNER_NAME"
            fi
        fi
        jq -c . "$SCANNER_CLI_OUTPUT" >&4
        local SCANNER_CLI_OUTPUT_LOG=$(jq -rc '.content.data' "$SCANNER_CLI_OUTPUT" 2>/dev/null)
        SCANNER_CLI_OUTPUT_LOG=$(head -c 70 <<<"$SCANNER_CLI_OUTPUT_LOG" 2>/dev/null)
        ydk:log output "Result Data: $SCANNER_CLI_OUTPUT_LOG"
        return "$SCANNER_STATUS"
    }
    api() {
        __secops:api:validate() {
            local SCANNER_ENTRYPOINT=$(secops:cli:entrypoint "$@" 4>&1)
            [ -z "$SCANNER_ENTRYPOINT" ] && return 22
            shift
            local SCANNER_API=$(jq -cr '.scanner.api' <<<"$SCANNER_ENTRYPOINT")
            [ -z "$SCANNER_API" ] && return 22
            local SCANNER_API_METHODS=$(jq -cr '.' <<<"$SCANNER_API")
            [ -z "$SCANNER_API_METHODS" ] && return 22
            local SCANNER_NAME=$(jq -r '.name' <<<"$SCANNER_ENTRYPOINT")
            [ -z "$SCANNER_NAME" ] && return 22
            local SCANNER_API_PATH=$(jq -r '.path' <<<"$SCANNER_ENTRYPOINT")
            [ -z "$SCANNER_API_PATH" ] && return 22
            jq -c . <<<"$SCANNER_ENTRYPOINT" >&4
            return 0
        }
        endpoints() {
            local SCANNER_ENTRYPOINT=$(__secops:api:validate "$@" 4>&1)
            [ -z "$SCANNER_ENTRYPOINT" ] && return 22
            local SCANNER_API=$(jq -cr '.scanner.api' <<<"$SCANNER_ENTRYPOINT")
            local SCANNER_API_METHODS=$(jq -cr '.' <<<"$SCANNER_API")
            ydk:log info "Scanner API Methods"
            {
                echo -e "Command\tArgs"
                while read -r SCANNER_API_METHOD && [ -n "$SCANNER_API_METHOD" ]; do
                    [ -z "$SCANNER_API_METHOD" ] && continue
                    readarray -t SCANNER_API_METHOD_ARGS <<<"$(jq -cr '.["'"$SCANNER_API_METHOD"'"][]' <<<"$SCANNER_API_METHODS")"
                    [ -z "${SCANNER_API_METHOD_ARGS[*]}" ] && continue
                    echo -n "secops api $(jq -r '.name' <<<"$SCANNER_ENTRYPOINT") fetch "
                    echo -ne "$SCANNER_API_METHOD\t"
                    for ARG_IDX in "${!SCANNER_API_METHOD_ARGS[@]}"; do
                        local ARG_NAME="${SCANNER_API_METHOD_ARGS[ARG_IDX]}"
                        ! [[ $ARG_NAME == *\{\{.*\}\}* ]] && continue
                        ARG_NAME=${ARG_NAME//\{\{./--}
                        ARG_NAME=${ARG_NAME//\}\}/}
                        echo -ne "\t${ARG_NAME}="
                    done
                    echo
                done < <(jq -rc 'keys | .[]' <<<"$SCANNER_API_METHODS")
            } | column -t -s $'\t'
        }
        fetch() {
            local SCANNER_ENTRYPOINT=$(__secops:api:validate "$@" 4>&1)
            [ -z "$SCANNER_ENTRYPOINT" ] && return 22
            local SCANNER_NAME=$(jq -r '.name' <<<"$SCANNER_ENTRYPOINT")
            local SCANNER_API_PATH=$(jq -r '.path' <<<"$SCANNER_ENTRYPOINT")
            local SCANNER_API=$(jq -cr '.scanner.api' <<<"$SCANNER_ENTRYPOINT")
            local SCANNER_API_METHODS=$(jq -cr '.' <<<"$SCANNER_API")
            readarray -t SCANNER_API_METHOD_ARGS <<<"$(jq -cr '.scanner.api["'"$SCANNER_API_PATH"'"][]' <<<"$SCANNER_ENTRYPOINT")"
            for SCANNER_API_METHOD_ARG in "$@"; do
                if [[ $SCANNER_API_METHOD_ARG == --*=* ]]; then
                    local KEY=${SCANNER_API_METHOD_ARG%%=*}
                    local VALUE=${SCANNER_API_METHOD_ARG#*=}
                    KEY=${KEY#--}
                    KEY=${KEY//./}
                    for i in "${!SCANNER_API_METHOD_ARGS[@]}"; do
                        SCANNER_API_METHOD_ARGS[i]=${SCANNER_API_METHOD_ARGS[i]//\{\{.$KEY\}\}/$VALUE}
                    done
                fi
            done
            {
                echo -n "{"
                echo -n "\"args\":["
                for i in "${!SCANNER_API_METHOD_ARGS[@]}"; do
                    if ydk:is number "${SCANNER_API_METHOD_ARGS[i]}"; then
                        echo -n "${SCANNER_API_METHOD_ARGS[i]},"
                    elif ydk:is boolean "${SCANNER_API_METHOD_ARGS[i]}"; then
                        echo -n "${SCANNER_API_METHOD_ARGS[i]},"
                    elif jq -e . <<<"${SCANNER_API_METHOD_ARGS[i]}" 2>/dev/null 1>/dev/null; then
                        echo -n "$(jq -c . <<<"${SCANNER_API_METHOD_ARGS[i]}"),"
                    else
                        echo -n "\"${SCANNER_API_METHOD_ARGS[i]}\","
                    fi
                done | sed 's/,$//'
                echo -n "]"
                echo -n "}"
            } | jq -c \
                --argjson ENTRYPOINT "$SCANNER_ENTRYPOINT" \
                '
                $ENTRYPOINT + .
            ' >&4
            ydk:log info "Running scanner $SCANNER_NAME API"
            ydk:secops cli "$SCANNER_NAME" "${SCANNER_API_METHOD_ARGS[@]}" 4>&1
            return $?
        }
        case "$1" in
        fetch)
            shift
            local API_FETCH=$({
                fetch "$@" 4>&1 >&4
                local API_FETCH_STATUS=$?
                [ "$API_FETCH_STATUS" -ne 0 ] && ydk:log error "($API_FETCH_STATUS) Failed to fetch API"
            } 4>&1)
            [ -z "$API_FETCH" ] && return 22
            jq -cs "${YDK_SECOPS_SPECS["result-output"]}" <<<"$API_FETCH" >&4
            ydk:log -c "${YDK_LOGGER_CONTEXT}:fetch" \
                "$(jq -sr "${YDK_SECOPS_SPECS["status-log"]}" <<<"$API_FETCH" 2>/dev/null)" \
                "$(jq -rs "${YDK_SECOPS_SPECS["result-summary"]}" <<<"$API_FETCH" 2>/dev/null)"
            return 0
            ;;
        endpoints)
            shift
            endpoints "$@" 4>&1
            return $?
            ;;
        *)
            ydk:try "$@" 4>&1
            return $?
            ;;
        esac
    }
    secops:plan:merge() {
        local ASSETS=$1
        if [[ -p /dev/stdin ]]; then
            local ASSETS=$(jq -c '.' /dev/stdin 2>/dev/null)
        elif [[ -f "$ASSETS" ]]; then
            local ASSETS=$(jq -c '.' "$ASSETS" 2>/dev/null)
        else
            local ASSETS=$(jq -c '.' <<<"$ASSETS" 2>/dev/null)
        fi
        if [[ -z "$ASSETS" ]]; then
            ydk:log error "Failed to parse assets"
            return 22
        fi
        local ASSETS_COUNT=$(jq -rc '. | length' <<<"${ASSETS}")
        if [ "${ASSETS_COUNT}" -gt 10 ]; then
            ydk:log error "Multiple assets not supported"
            return 1
        fi
        jq -cn \
            --argjson ASSETS "${ASSETS}" \
            --argjson SCANNERS "$(scanners list 4>&1)" \
            '
            {
                "assets":$ASSETS,
                "scanners":$SCANNERS
            }
            ' >&4
        return 0
    }
    plan() {
        local ASSETS="$1" && [ -z "$ASSETS" ] && return 22
        if ! jq -e . "$ASSETS" 2>/dev/null 1>/dev/null; then
            ydk:log error "Failed to parse assets"
            return 22
        fi
        local SECOPS_PLAN_SCANNERS=$(jq -c "." < <(scanners list 4>&1) 2>/dev/null)
        local SECOPS_PLAN_FILE=$(ydk:temp "secops-plan" 4>&1)
        local SECOPS_PLAN="{}"
        ydk:log info "SecOps Plan ${SECOPS_PLAN_FILE}"
        while read -r ASSET && [ -n "$ASSET" ]; do
            if ! jq -e . <<<"$ASSET" 2>/dev/null 1>/dev/null; then
                ydk:log error "Failed to parse asset"
                continue
            fi
            local ASSET_TYPE=$(jq -r '.type' <<<"$ASSET" 2>/dev/null) && [ -z "$ASSET_TYPE" ] && continue
            ASSET_TYPE="asset/$ASSET_TYPE"
            local SECOPS_PLAN_SCANNER_APIS=$(
                jq -c '
                    .[] |
                    select(.api != null) |
                    .api |
                    to_entries |
                    .[] |
                    select(.key == "'"${ASSET_TYPE}"'") |
                    .
                ' <<<"$SECOPS_PLAN_SCANNERS" 2>/dev/null
            )
            echo "$ASSET_TYPE / $SECOPS_PLAN_SCANNER_APIS" >&1
        done < <(jq -c ".[]" "$ASSETS" 2>/dev/null)
        jq -c . <<<"$SECOPS_PLAN" >"$SECOPS_PLAN_FILE"
        jq -c . "$SECOPS_PLAN_FILE" >&4
        ydk:log success "SecOps Plan ${SECOPS_PLAN_FILE}"
        rm -f "$SECOPS_PLAN_FILE"
        return 0
    }
    secops:opts() {
        while [ "$#" -gt 0 ]; do
            case "$1" in
            -i | auto-install)
                YDK_SECOPS_CONFIG["auto-install"]=true
                ydk:log warn "Auto install enabled"
                ;;
            -u | auto-uninstall)
                YDK_SECOPS_CONFIG["auto-uninstall"]=true
                ydk:log warn "Auto uninstall enabled"
                ;;
            -k | keep-output)
                YDK_SECOPS_CONFIG["keep-output"]=true
                ydk:log warn "Keep output enabled"
                ;;
            -o=* | --output-file=*)
                YDK_SECOPS_CONFIG["output-file"]="${1#*=}"
                ydk:log debug "Output file set to ${YDK_SECOPS_CONFIG["output-file"]}"
                ;;
            *)
                YDK_SECOPS_OPTS+=("$1")
                ;;
            esac
            shift
        done
        return 0
    }
    local YDK_SECOPS_OPTS=() && secops:opts "$@" && set -- "${YDK_SECOPS_OPTS[@]}" && unset YDK_SECOPS_OPTS
    ydk:try "$@" 4>&1
    return $?
}
{
    ydk:secops:result:cloc() {
        echo "ydk:secops:result:cloc $# $*" >&1 # >&4
        return 0
    }
}
ydk:spinner() {
    ydk:try "$@" 4>&1
    return $?
}
ydk:spwan() {
    ydk:try "$@" 4>&1
    return $?
}
ydk:store() {
    ydk:try "$@" 4>&1
    return $?
}
ydk:strings() {
    trim() {
        local STR="$1" && [ -z "$STR" ] && STR="$(cat)" && [ -z "$STR" ] && return 1
        echo "$STR" | awk '{$1=$1};1' | sed 's/^[[:space:]]*//g' | sed 's/[[:space:]]*$//g' >&4
        return 0
    }
    contains() {
        local STR="$1" && [ -z "$STR" ] && STR="$(cat)" && [ -z "$STR" ] && return 1
        local SUB="$2"
        echo "$STR" | grep -- "$SUB" >/dev/null 2>&1
        return $?
    }
    endswith() {
        local STR="$1" && [ -z "$STR" ] && STR="$(cat)" && [ -z "$STR" ] && return 1
        local SUB="$2"
        echo "$STR" | grep -- "$SUB\$" >/dev/null 2>&1
        return $?
    }
    startswith() {
        local STR="$1" && [ -z "$STR" ] && STR="$(cat)" && [ -z "$STR" ] && return 1
        local SUB="$2"
        echo "$STR" | grep -- "^$SUB" >/dev/null 2>&1
        return $?
    }
    lowercase() {
        tr '[:upper:]' '[:lower:]' >&4
    }
    uppercase() {
        tr '[:lower:]' '[:upper:]' >&4
    }
    capitalize() {
        local STR="$1" && [ -z "$STR" ] && STR="$(cat)" && [ -z "$STR" ] && return 1
        echo "$STR" | sed 's/\b\(.\)/\u\1/g' >&4
    }
    reverse() {
        rev "$@" >&4
    }
    count_char() {
        local STR="$1" && [ -z "$STR" ] && STR="$(cat)" && [ -z "$STR" ] && return 1
        local CHAR="$2"
        local COUNT="${#STR}"
        local STRIPPED="${STR//"$CHAR"/}"
        local COUNT_STRIPPED="${#STRIPPED}"
        echo $((COUNT - COUNT_STRIPPED)) >&4
    }
    padleft(){
        local STR="$1" && [ -z "$STR" ] && STR="$(cat)" && [ -z "$STR" ] && return 1
        local LENGTH="$2"
        local CHAR="${3:- }"
        printf "%-${LENGTH}s" "$STR" | tr ' ' "$CHAR" >&4
    }
    padright(){
        local STR="$1" && [ -z "$STR" ] && STR="$(cat)" && [ -z "$STR" ] && return 1
        local LENGTH="$2"
        local CHAR="${3:- }"
        printf "%${LENGTH}s" "$STR" | tr ' ' "$CHAR" >&4
    }
    
    mask() {
        local STR="$1" && [ -z "$STR" ] && STR="$(cat)" && [ -z "$STR" ] && return 1
        local MASK="${2:-*}"
        local LENGTH="${#STR}"
        local MASK_LEN="${#MASK}"
        local MASKED=""
        for ((i = 0; i < LENGTH; i++)); do
            [ "$i" -lt 1 ] && MASKED+="${STR:i:1}" && continue
            [ "$i" -eq $((LENGTH - 1)) ] && MASKED+="${STR:i:1}" && continue
            MASKED+="${MASK:i%MASK_LEN:1}"
        done
        echo "$MASKED" >&4
    }
    sanetize() {
        local STR="$1" && [ -z "$STR" ] && STR="$(cat)" && [ -z "$STR" ] && return 1
        {
            echo -n "$STR" |
                sed -e 's/[^a-zA-Z0-9]/_/g' \
                    -e 's/__*/_/g' \
                    -e 's/^_//g' \
                    -e 's/_$//g' \
                    -r "s/\x1B\[[0-9;]*[mK]//g" |
                sed 's/\x1b\[[0-9;]*m//g'
        } >&4
    }
    ydk:try "$@" 4>&1
    return $?
}
ydk:styles() {
    YWT_LOG_CONTEXT="styles"
    apply() {
        local STYLE=${1:-bold} && STYLE=${STYLE,,}
        local TEXT=${2}
        local KIND=${3:-normal} && KIND=${KIND,,}
        [[ ! $KIND =~ ^(normal|italic|underline|blink|inverse|hidden)$ ]] && KIND=normal
        case $STYLE in
        bold) STYLE=1 ;;
        dim) STYLE=2 ;;
        italic) STYLE=3 ;;
        underline) STYLE=4 ;;
        blink) STYLE=5 ;;
        inverse) STYLE=7 ;;
        hidden) STYLE=8 ;;
        esac
        echo -ne "\e[${STYLE}m${TEXT}\e[0m" >&4
    }
    list() {
        local STYLES=("${!YDK_STYLES[@]}")
        {
            echo -e $'style\techo\tsdk\tcli'
            for STYLE in "${STYLES[@]}"; do
                echo -ne "${STYLE,,}\t"
                echo -ne "${YDK_STYLES[$STYLE]}echo \"\${$STYLE}ydk-shell\${\$NS}\"${YDK_STYLES[NS]}\t"
                echo -ne "$(
                    ydk:styles:"${STYLE,,}" "ydk:styles:${STYLE,,} \"ydk-shell\"" 2>/dev/null
                )\t"
                echo -ne "$(
                    apply "${STYLE,,}" "ydk styles apply ${STYLE,,} \"ydk-shell\"" 4>&1
                )"
                echo
            done
        } | column -t -s $'\t' >&4
    }
    hyperlink() {
        local OSC=$'\e]'
        local BEL=$'\a'
        local SEP=';'
        local PARAM_SEP=':'
        local EQ='='
        local URI=$1
        local TEXT=$2
        local PARAMS=$3
        local PARAM_STR=""
        for PARAM in "${!PARAMS[@]}"; do
            PARAM_STR+="${PARAM}${EQ}${PARAMS[$param]}${PARAM_SEP}"
        done
        PARAM_STR=${PARAM_STR%"$PARAM_SEP"}
        printf "%s8%s%s%s%s%s%s%s8%s%s%s" "$OSC" "$SEP" "$PARAM_STR" "$SEP" "$URI" "$BEL" "$TEXT" "$OSC" "$SEP" "$SEP" "$BEL"
        echo -e "${NS}${NSTL}${NBG}" >&4
    }
    ydk:try "$@" 4>&1
    return $?
}
{
    [[ -z "$YDK_STYLES" ]] && declare -g -A YDK_STYLES=(
        [NS]="\033[0m"
        [BOLD]="\033[1m"
        [DIM]="\033[2m"
        [ITALIC]="\033[3m"
        [UNDERLINE]="\033[4m"
        [BLINK]="\033[5m"
        [INVERSE]="\033[7m"
        [HIDDEN]="\033[8m"
        [STRIKETHROUGH]="\033[9m"
    ) && readonly YDK_STYLES && {
        for STYLE in "${!YDK_STYLES[@]}"; do
            STYLE_CODE="${YDK_STYLES[$STYLE]}"
            declare -g "${STYLE^^}=${STYLE_CODE}"
            eval "ydk:styles:${STYLE,,}() { echo -en \"${STYLE_CODE}\${*}${NS}\"; }"
            export -f "ydk:styles:${STYLE,,}"
        done
    }
}
ydk:tcp() {
    ydk:try "$@" 4>&1
    return $?
}
ydk:team() {
    local YDK_LOGGER_CONTEXT="team"
    release() {
        local YDK_OUTPUT=$({
            echo -n "{"
            echo -n "   \"id\": \"$(git rev-parse --short HEAD 2>/dev/null || echo "Unknown")\","
            echo -n "   \"hash\": \"$(git rev-parse HEAD 2>/dev/null || echo "Unknown")\","
            echo -n "   \"branch\": \"$(git rev-parse --abbrev-ref HEAD 2>/dev/null || echo "Unknown")\","
            echo -n "   \"tag\": \"$(git describe --tags 2>/dev/null || echo "Unknown")\","
            echo -n "   \"message\": \"$(git log -1 --pretty=format:'%s' 2>/dev/null || echo "Unknown")\""
            echo -n "}"
        })
        echo "$YDK_OUTPUT" >&4
        return 0
    }
    info() {
        local YDK_OUTPUT=$({
            echo -n "{"
            echo -n "\"license\": \"MIT\","
            echo -n "\"repo\": {"
            echo -n "\"owner\": \"$YDK_OWNER\","
            echo -n "\"name\": \"$YDK_REPO\","
            echo -n "\"branch\": \"$YDK_BRANCH\","
            echo -n "\"version\": \"$YDK_VERSION\","
            echo -n "\"api\": \"https://api.github.com/repos/$YDK_OWNER/$YDK_REPO\","
            echo -n "\"raw\": \"https://raw.githubusercontent.com/$YDK_OWNER/$YDK_REPO/$YDK_BRANCH\","
            echo -n "\"homepage\": \"${YDK_LINKS[homepage]}\""
            echo -n "},"
            echo -n "\"info\": {"
            echo -n "\"team\": \"${YDK_INFO[team]}\","
            echo -n "\"name\": \"${YDK_INFO[name]}\","
            echo -n "\"version\": \"${YDK_INFO[version]}\","
            echo -n "\"description\": \"${YDK_INFO[description]}\""
            echo -n "},"
            echo -n "\"author\": {"
            echo -n "\"name\": \"${YDK_AUTHOR[name]}\","
            echo -n "\"email\": \"${YDK_AUTHOR[email]}\","
            echo -n "\"uri\": \"${YDK_AUTHOR[uri]}\""
            echo -n "},"
            echo -n "\"build\": {"
            echo -n "   \"name\": \"ydk-shell\","
            echo -n "   \"date\": \"$(date -Iseconds)\""
            echo -n "},"
            echo -n "\"release\": {"
            echo -n "   \"name\": \"ydk-shell\","
            echo -n "   \"date\": \"$(date -Iseconds)\""
            echo -n "}"
            echo -n "}"
        })
        echo "$YDK_OUTPUT" >&4
        return 0
    }
    welcome() {
        local YDK_TEAM_INFO=$(info 4>&1)
        ydk:logger success "$(jq -rc '.info.team + " | " + .info.name + " | " + .info.description + " | " + .info.homepage' <<<"$YDK_TEAM_INFO" 2>/dev/null)"
        ydk:logger info "Need a help? Visit ${YDK_LINKS[docs]} :book:"
        return 0
    }
    copyright() {
        local YDK_TEAM_INFO=$(info 4>&1)
        local YDK_RELEASE_INFO=$(release 4>&1)
        echo "# YELLOW TEAM BUNDLE"
        echo "# $(jq -c .info <<<"$YDK_TEAM_INFO")"
        echo "# This file is generated by yellowteam sdk builder. Do not edit this file"
        echo "# Build date: $(date -Iseconds)"
        echo "# Build ID: $(jq -r .id <<<"$YDK_RELEASE_INFO")"
        echo "# Build branch: $(jq -r .branch <<<"$YDK_RELEASE_INFO")"
        echo "# Build tag: $(jq -r .tag <<<"$YDK_RELEASE_INFO")"
        echo "# Build commit: $(jq -r .hash <<<"$YDK_RELEASE_INFO")"
        echo "# Build message: $(jq -r .message <<<"$YDK_RELEASE_INFO")"
        return 0
    }
    ydk:try "$@" 4>&1
    return $?
}
{
    [[ -z "$YDK_OWNER" ]] && export YDK_OWNER="ywteam" # "cloudyellowteam"
    [[ -z "$YDK_REPO" ]] && export YDK_REPO="ydk-shell" && readonly YDK_REPO
    [[ -z "$YDK_BRANCH" ]] && export YDK_BRANCH="main" && readonly YDK_BRANCH
    [[ -z "$YDK_VERSION" ]] && export YDK_VERSION="0.0.0-dev-0"
    [[ -z "$YDK_LINKS" ]] && declare -g -A YDK_LINKS=(
        ["homepage"]="https://yellowteam.cloud"
        ["api"]="https://api.github.com/repos/${YDK_OWNER}/${YDK_REPO}"
        ["raw"]="https://raw.githubusercontent.com/${YDK_OWNER}/${YDK_REPO}/${YDK_BRANCH}"
        ["bugs"]="https://bugs.yellowteam.cloud"
        ["docs"]="https://docs.yellowteam.cloud"
        ["wiki"]="https://wiki.yellowteam.cloud"
        ["chat"]="https://chat.yellowteam.cloud"
        ["forum"]="https://forum.yellowteam.cloud"
        ["store"]="https://store.yellowteam.cloud"
    ) && readonly YDK_LINKS
    [[ -z "$YDK_INFO" ]] && declare -g -A YDK_INFO=(
        ["team"]="@ywteam"
        ["name"]="https://yellowteam.cloud/ydk-shell"
        ["version"]="$YDK_VERSION"
        ["description"]="shell SDK"
    ) && readonly YDK_INFO
    [[ -z "$YDK_AUTHOR" ]] && declare -g -A YDK_AUTHOR=(
        ["name"]="Raphael Rego"
        ["email"]="hello@raphaelcarlosr.dev"
        ["homepage"]="https://raphaelcarlosr.dev"
    ) && readonly YDK_AUTHOR
}
ydk:tests() {
    ydk:try "$@"
    return $?
}
ydk:timezones() {
    ydk:try "$@" 4>&1
    return $?
}
ydk:upm() {
    local YDK_LOGGER_CONTEXT="upm"
    ydk:require --throw jq 4>/dev/null
    [[ -z "$YDK_UPM_VENDORS_FILE" ]] && local YDK_UPM_VENDORS_FILE="/workspace/rapd-shell/assets/upm.vendors.json" && [[ ! -f "$YDK_UPM_VENDORS_FILE" ]] && YDK_UPM_VENDORS_FILE="$(ydk:assets location "upm-vendors" 4>&1)"
    detect() {
        ydk:require --throw uname awk tr sed 4>/dev/null
        local OS_NAME=$(uname -s | tr '[:upper:]' '[:lower:]')
        local OS_VENDOR=$({
            case $OS_NAME in
            linux)
                local OS_VENDOR_NAME=$(awk -F= '/^NAME/{print $2}' /etc/os-release | tr -d '"' | sed 's/ linux//')
                IFS=" " read -r -a OS_VENDOR_NAME <<<"$OS_VENDOR_NAME"
                local OS_VENDOR=${OS_VENDOR_NAME[0]}
                ;;
            darwin)
                local OS_VENDOR="macos"
                ;;
            cygwin* | mingw* | msys*)
                local OS_VENDOR="windows"
                ;;
            *)
                local OS_VENDOR="unknown"
                ;;
            esac
            OS_VENDOR=${OS_VENDOR,,}
            ydk:logger output "Detecting package managers for $OS_NAME/${OS_VENDOR}"
            echo -n "{"
            echo -n "\"os\":\"$OS_NAME\","
            echo -n "\"vendor\":\"$OS_VENDOR\","
            echo -n "\"managers\":{"
            local IFS=" "
            for PM in ${YDK_UPM_OS_MAP[$OS_VENDOR]}; do
                echo -n "\"$PM\":{ "
                echo -n "\"installed\":$(command -v "$PM" &>/dev/null && echo -n "true" || echo -n "false"),"
                echo -n "\"path\":\"$(command -v "$PM" 2>/dev/null)\","
                echo -n "\"version\":\"$($PM --version 2>/dev/null)\""
                echo -n "},"
            done | sed 's/,$//'
            echo -n "}"
            echo -n "}"
        } | jq -c .)
        ydk:logger output < <(
            jq -rc '
                "\(.os)/\(.vendor). \(.managers | length) package managers detected. \(.managers | keys | join(" "))"
            ' <<<"${OS_VENDOR}"
        )
        jq -c . <<<"${OS_VENDOR}" >&4
        return 0
    }
    vendor() {
        local MANAMGER_NAME=$1
        jq -cr "
            .[] | 
            select(.name == \"$MANAMGER_NAME\") |
            first(.)
        " "${YDK_UPM_VENDORS_FILE}" >&4
    }
    __upm:cli() {
        local YDK_UPM_DETECT=$(detect 4>&1) && [[ -z "$YDK_UPM_DETECT" ]] && ydk:throw 255 "No package manager detected"
        [[ "$(jq -r '.os' <<<"$YDK_UPM_DETECT")" == "unknown" ]] && ydk:throw 255 "Unsupported OS"
        local UPM_MANAGER=$(
            jq -r '
                if .managers != null then
                    .managers | 
                    to_entries[] |
                    select(.value.installed == true) | 
                    first(.key)
                else
                    empty
                end
            ' <<<"$YDK_UPM_DETECT"
        )
        [[ -z "$UPM_MANAGER" ]] && ydk:throw 255 "No package manager found"
        local UPM_MANAGER_VENDOR=$(vendor "$UPM_MANAGER" 4>&1)
        [[ -z "$UPM_MANAGER_VENDOR" ]] && ydk:throw 255 "No package manager vendor found"
        local UPM_MANAGER=$({
            jq -n \
                --argjson DETECT "$YDK_UPM_DETECT" \
                --arg UPM_MANAGER "$UPM_MANAGER" \
                --argjson UPM_VENDOR "$UPM_MANAGER_VENDOR" \
                '{
                os: $DETECT.os,
                vendor: $DETECT.vendor,
                manager: ($UPM_VENDOR + {
                    path: $DETECT.managers[$UPM_MANAGER].path,
                    version: $DETECT.managers[$UPM_MANAGER].version
                }),                
                managers: $DETECT.managers                
            }'
        })
        ydk:log info "Detected package manager $(jq -r '.manager.name' <<<"$UPM_MANAGER")"
        jq -c . <<<"$UPM_MANAGER" >&4
        return 0
    }
    cmd() {
        local UPM_MANAGER_CMD=$1 && [ -z "$UPM_MANAGER_CMD" ] && return 22
        shift
        local YDK_UPM_CLI=$(__upm:cli 4>&1) && [[ -z "$YDK_UPM_CLI" ]] && return 255
        local UPM_MANAGER=$(jq -r '.manager' <<<"$YDK_UPM_CLI") && [[ -z "$UPM_MANAGER" ]] && return 255
        local UPM_MANAGER_NAME=$(jq -r '.name' <<<"$UPM_MANAGER")
        local UPM_MANAGER_VERSION=$(jq -r '.version' <<<"$UPM_MANAGER")
        local UPM_MANAGER_CONFIRM=$(jq -r '.confirm' <<<"$UPM_MANAGER")
        UPM_MANAGER_CONFIRM=${UPM_MANAGER_CONFIRM%%\/*}
        local UPM_MANAGER_COMMAND=$(jq -r '.'"${UPM_MANAGER_CMD}"'' <<<"$UPM_MANAGER")
        UPM_MANAGER_COMMAND=${UPM_MANAGER_COMMAND//\$/}
        [[ -z "$UPM_MANAGER_COMMAND" ]] && return 255
        local UPM_COMMAND="$UPM_MANAGER_COMMAND"
        case $UPM_MANAGER_CMD in
        install | remove | upgrade)
            UPM_COMMAND+=" $UPM_MANAGER_CONFIRM"
            ;;
        list_installed)
            UPM_COMMAND=${UPM_COMMAND%%\/*}
            ;;
        *) ;;
        esac
        $UPM_COMMAND "$@" 2>/dev/null >&4
        ydk:log "$([[ $UPM_CMD_STATUS -eq 0 ]] && echo "success" || echo "error")" "Command  $UPM_MANAGER_NAME:$UPM_MANAGER_VERSION exited with status $UPM_CMD_STATUS" >&1
        return "${UPM_CMD_STATUS:-0}"
    }
    install() {
        cmd install "$@" >&4
        return $?
    }
    uninstall() {
        cmd remove "$@" >&4
        return $?
    }
    upgrade() {
        cmd upgrade "$@" >&4
        return $?
    }
    search() {
        cmd search "$@" >&4
        return $?
    }
    info() {
        cmd info "$@" >&4
        return $?
    }
    update() {
        cmd update_index >&4
        return $?
    }
    upgrade_all() {
        cmd upgrade_all >&4
        return $?
    }
    installed() {
        ydk:log info "Listing installed packages"
        cmd list_installed | awk '{print $1}' | tail -n +2 | sort | column >&4
        return 0
    }
    ydk:try "$@" 4>&1
    return $?
}
{
    declare -g -A YDK_UPM_OS_MAP=(
        [windows]="scoop choco winget"
        [macos]="brew port"
        [ubuntu]="apt"
        [debian]="apt"
        [linuxmint]="apt"
        [pop]="apt"
        [deepin]="apt"
        [elementray]="apt"
        [kali]="apt"
        [raspbian]="apt"
        [aosc]="apt"
        [zorin]="apt"
        [antix]="apt"
        [devuan]="apt"
        [bodhi]="apt"
        [lxle]="apt"
        [sparky]="apt"
        [fedora]="dnf yum"
        [redhat]="dnf yum"
        [rhel]="dnf yum"
        [amzn]="dnf yum"
        [ol]="dnf yum"
        [almalinux]="dnf yum"
        [rocky]="dnf yum"
        [oubes]="dnf yum"
        [centos]="dnf yum"
        [qubes]="dnf yum"
        [eurolinux]="dnf yum"
        [arch]="pacman"
        [manjaro]="pacman"
        [endeavouros]="pacman"
        [arcolinux]="pacman"
        [garuda]="pacman"
        [antergos]="pacman"
        [kaos]="pacman"
        [alpine]="apk"
        [postmarket]="apk"
        [opensuse]="zypper"
        [opensuse - leap]="zypper"
        [opensuse - tumbleweed]="zypper"
        [nixos]="nix-env"
        [gentoo]="emerge"
        [funtoo]="emerge"
        [void]="xbps"
        [mageia]="urpm"
        [slackware]="slackpkg"
        [solus]="eopkg"
        [openwrt]="opkg"
        [nutyx]="cards"
        [crux]="prt-get"
        [freebsd]="pkg"
        [ghostbsd]="pkg"
        [android]="pkg(termux)"
        [haiku]="pkgman"
    )
}
ydk:usage() {
    local YDK_USAGE_STATUS=$?
    [[ $1 =~ ^[0-9]+$ ]] && local YDK_USAGE_STATUS="${1}" && shift
    local YDK_USAGE_MESSAGE="${1:-"command not found"}" && shift
    local YDK_USAGE_COMMAND_ARGS=("$@")
    local YDK_ERROR_MESSAGE="${YDK_ERRORS_MESSAGES[$YDK_USAGE_STATUS]:-"An error occurred"}"
    {
        echo -n "{"
        echo -n "\"error\": true,"
        echo -n "\"status\": $YDK_USAGE_STATUS,"
        echo -n "\"message\": \"${YDK_ERROR_MESSAGE}. ${YDK_USAGE_MESSAGE}\","
        echo -n "\"command\": \"$1\","
        echo -n "\"args\": ["
        for YDK_USAGE_COMMAND_ARG in "${YDK_USAGE_COMMAND_ARGS[@]}"; do
            echo -n "\"${YDK_USAGE_COMMAND_ARG}\","
        done | sed -e 's/,$//'
        echo -n "],"
        echo -n "\"available\": "
        ydk:functions 4>&1 >&1
        echo -n "}"
        echo
    } >&4
    return "$YDK_USAGE_STATUS"
}
ydk:users() {
    ydk:try "$@" 4>&1
    return $?
}
ydk:vault() {
    ydk:try "$@" 4>&1
    return $?
}
ydk:versions() {
    ydk:try "$@" 4>&1
    return $?
}
ydk:watcher() {
    ydk:try "$@" 4>&1
    return $?
}
ydk:worker() {
    ydk:try "$@" 4>&1
    return $?
}
YDK_CLI_ENTRYPOINT="${0}" && readonly YDK_CLI_ENTRYPOINT
YDK_CLI_ARGS=("$@")
export YDK_BRAND="YDK" && readonly YDK_BRAND
export YDK_PACKAGE_NAME="ydk-shell" && readonly YDK_PACKAGE_NAME
export YDK_IS_INSTALL=false && [[ "${1,,}" =~ ^(install|setup|upgrade|uninstall|remove|purge)$ ]] && YDK_IS_INSTALL=true
readonly YDK_IS_INSTALL
set -e -o pipefail
set -e -o errtrace
ydk() {
    local YDK_CLI_NAME=$(basename "${YDK_CLI_ENTRYPOINT}") && readonly YDK_CLI_FILE_NAME
    local YDK_CLI_DIR=$(cd "$(dirname "${YDK_CLI_ENTRYPOINT}")" && pwd) && readonly YDK_CLI_DIR
    local YDK_INITIALIZED=false
    local YDK_BOOTSTRAPED=false
    export YDK_POSITIONAL_ARGS=()
    local YDK_PATH_TMP="/tmp/ywteam/${YDK_PACKAGE_NAME}" && mkdir -p "${YDK_PATH_TMP}"
    local YDK_DEPENDENCIES=(
        "jq" "curl" "sed" "awk" "tr" "sort" "basename" "dirname" "mktemp" "openssl" "column" "ps" "kill" "trap" "mkfifo"
    )
    local YDK_DEPENDENCIES_MISSING=()
    ydk:prgma() {
        local YDK_VERSION="0.0.0-dev-0"
        [ -f "${YDK_CLI_DIR}/VERSION" ] && YDK_VERSION=$(cat "./VERSION")
        local YDK_CLI_BINARY=false
        if command -v file >/dev/null 2>&1; then
            file "${YDK_CLI_ENTRYPOINT}" | grep -q "ELF" && YDK_CLI_BINARY=true
        elif [[ "${BASH_SOURCE[0]}" == "environment" ]]; then
            YDK_CLI_BINARY=true
        fi
        local YDK_CLI=$({
            echo -n "{"
            echo -n "\"brand\": \"${YDK_BRAND}\","
            echo -n "\"package\": \"${YDK_PACKAGE_NAME}\","
            echo -n "\"version\": \"${YDK_VERSION}\","
            echo -n "\"binary\": ${YDK_CLI_BINARY},"
            echo -n "\"cwd\": \"$(pwd)\","
            echo -n "\"entrypoint\": \"${YDK_CLI_ENTRYPOINT}\","
            echo -n "\"name\": \"${YDK_CLI_NAME//.cli.sh/}\","
            echo -n "\"file\": \"${YDK_CLI_NAME}\","
            echo -n "\"path\": \"${YDK_CLI_DIR}\","
            echo -n "\"args\": ["
            for YDK_CLI_ARG in "${YDK_CLI_ARGS[@]}"; do
                echo -n "\"${YDK_CLI_ARG}\","
            done | sed 's/,$//'
            echo -n "],"
            echo -n "\"sources\": ["
            for YDK_BASH_SOURCE in "${BASH_SOURCE[@]}"; do
                YDK_BASH_SOURCE=${YDK_BASH_SOURCE//\"/\\\"}
                echo -n "\"${YDK_BASH_SOURCE}\","
            done | sed 's/,$//'
            echo -n "]"
            echo -n "}"
        })
        echo "$YDK_CLI" >&4
        ydk:log "info" ":shorts: ${YDK_PACKAGE_NAME}@${YDK_VERSION} $([[ "${YDK_CLI_BINARY}" == true ]] && echo "app" || echo "sdk")"
        return 0
    }
    ydk:etime() {
        {
            if grep -q 'Alpine' /etc/os-release; then
                ps -o etime= "$$" | awk -F "[:]" '{ print ($1 * 60) + $2 }' | head -n 1
            else
                ps -o etime= -p "$$" | sed -e 's/^[[:space:]]*//' | sed -e 's/\://' | head -n 1
            fi
        } >&4
    }
    ydk:require() {
        local THROW=false
        [[ "${1,,}" =~ (true|false) ]] && THROW="${1,,}" && shift
        [[ "${1,,}" =~ (--throw|-t) ]] && THROW=true && shift
        local MISSING=0
        for DEPENDENCY in "${@}"; do
            if ! command -v "$DEPENDENCY" >/dev/null 2>&1; then
                YDK_DEPENDENCIES_MISSING+=("${DEPENDENCY}")
                MISSING=1
            fi
        done
        local DETAILS=$({
            echo -n "{"
            echo -n "\"error\":"
            [[ "${#YDK_DEPENDENCIES_MISSING[@]}" -eq 0 ]] && echo -n "false," || echo -n "true,"
            echo -n "\"missing\": ${#YDK_DEPENDENCIES_MISSING[@]},"
            echo -n "\"dependencies\": ["
            for MISSING_DEPENDENCY in "${YDK_DEPENDENCIES_MISSING[@]}"; do
                echo -n "\"${MISSING_DEPENDENCY}\","
            done | sed 's/,$//'
            echo -n "]"
            echo -n "}"
        })
        [[ "$MISSING" -gt 0 ]] && {
            ydk:log error "Missing required packages '${YDK_DEPENDENCIES_MISSING[*]}'. Please install"
            [[ "$THROW" == true ]] && ydk:throw 254 "Missing ${#YDK_DEPENDENCIES[*]} required packages $_"
        }
        echo "$DETAILS" >&4
        return "$MISSING"
    }
    ydk:help() {
        local YDK_USAGE_STATUS=$1
        local YDK_USAGE_COMMAND="${2:-""}"
        local YDK_USAGE_MESSAGE="${3:-""}"
        local YDK_USAGE_COMMANDS=("$@")
        {
            ydk:log "info" "($YDK_USAGE_STATUS) ${YDK_USAGE_MESSAGE}"
            ydk:log "info" "* Usage: ydk $YDK_USAGE_COMMAND ($_)"
            [ "${#YDK_USAGE_COMMANDS[@]}" -gt 0 ] && {
                ydk:log "info" " [commands]"
                for YDK_USAGE_COMMAND in "${YDK_USAGE_COMMANDS[@]}"; do
                    ydk:log "info" " ${YDK_USAGE_COMMAND}"
                done
            }
        } 1>&2 # 1>&2
        return "$YDK_USAGE_STATUS"
    }
    ydk:inject() {
        local ENTRYPOINT_FILE="${1}" && [[ ! -f "${ENTRYPOINT_FILE}" ]] && return 0
        local ENTRYPOINT_NAME=$(basename "${ENTRYPOINT_FILE}")
        local ENTRYPOINT=${ENTRYPOINT_NAME//.ydk.sh/}
        ENTRYPOINT=$(sed 's/^[0-9]*\.//' <<<"$ENTRYPOINT")
        local ENTRYPOINT_TYPE="$(type -t "ydk:$ENTRYPOINT")" && [ -n "$ENTRYPOINT_TYPE" ] && return 0
        if ! [ "$ENTRYPOINT_TYPE" = function ]; then
            source "${ENTRYPOINT_FILE}" activate
            local ENTRYPOINT_TYPE=$(type -t "ydk:$ENTRYPOINT")
        fi
        if ! [ "$ENTRYPOINT_TYPE" = function ]; then
            return 1
        fi
        return 0
    }
    ydk:boostrap() {
        ! ydk:require "find" "sort" && {
            read -r -u 4 REQUIRED_DEPS
            ydk:log error "${REQUIRED_DEPS}"
            ydk:throw 254 "Missing required packages '${YDK_DEPENDENCIES_MISSING[*]}'"
        }
        [ "$YDK_INITIALIZED" == true ] && return 0
        YDK_INITIALIZED=true && readonly YDK_INITIALIZED
        while read -r ENTRYPOINT_FILE; do
            if ! ydk:inject "${ENTRYPOINT_FILE}"; then
                ydk:throw 255 "Failed to load entrypoint: ${ENTRYPOINT_FILE}"
                return 1
            fi
        done < <(
            find "${YDK_CLI_DIR}" \
                -type f -name "*.ydk.sh" \
                -not -name "${YDK_CLI_FILE_NAME}" | sort
        )
        if command -v jq 1>/dev/null 2>/dev/null; then
            while read -r FUNC_NAME; do
                {
                    [[ "$FUNC_NAME" =~ (activate|boostrap|inject|teardown|try|catch|throw|opts) ]] && continue
                    [[ ! "$FUNC_NAME" == "ydk:logger" ]] && continue
                    "$FUNC_NAME" activate >/dev/null 2>&1
                }
            done < <(ydk:functions 4>&1 | jq -r '.functions[]')
        fi
        YDK_BOOTSTRAPED=true && readonly YDK_BOOTSTRAPED
        return 0
    }
    ydk:teardown() {
        local YDK_EXIT_CODE="${1:-$?}"
        local YDK_EXIT_MESSAGES=(
            "${2:-"exit with: ${YDK_EXIT_CODE}"}"
        )
        [[ -n "$YDK_ERRORS_MESSAGES" ]] && YDK_EXIT_MESSAGES+=("${YDK_ERRORS_MESSAGES[$YDK_EXIT_CODE]}. ${YDK_CATH_MESSAGE}")
        local YDK_EXIT_LEVEL="" && [[ "${YDK_EXIT_CODE}" -ne 0 ]] && YDK_EXIT_LEVEL="error" || YDK_EXIT_LEVEL="success"
        local YDK_EXIT_JSON=$({
            if [ "${YDK_EXIT_CODE}" -ne 0 ]; then
                echo -n "{"
                echo -n "\"level\": \"error\","
                echo -n "\"error\": true,"
                echo -n "\"status\": ${YDK_EXIT_CODE},"
                echo -n "\"message\": \"An error occurred, see you later\","
                echo -n "\"report\": \"Please report this issue at: ${YDK_BUGS_REPORT}\""
                echo -n "}"
            else
                echo -n "{"
                echo -n "\"level\": \"success\","
                echo -n "\"error\": false,"
                echo -n "\"status\": ${YDK_EXIT_CODE},"
                echo -n "\"message\": \"Done, ${YDK_EXIT_MESSAGES[*]}, see you later\""
                echo -n "}"
            fi
        })
        rm -f ${YDK_FIFO}
        [[ -n "$YDK_ERRORS_MESSAGES" ]] && YDK_THROW_MESSAGE="${YDK_ERRORS_MESSAGES[$YDK_THROW_STATUS]}. ${YDK_THROW_MESSAGE}"
        ydk:log "$YDK_EXIT_LEVEL" "($YDK_EXIT_CODE) ${YDK_EXIT_MESSAGES[*]}"
        exit "${YDK_EXIT_CODE}"
    }
    ydk:try() {
        ydk:nnf "$@" || {
            YDK_STATUS=$? && YDK_STATUS=${YDK_STATUS:-0}
            [ "$YDK_STATUS" -ne 0 ] && [[ ! "$1" == "activate" ]] && ydk:throw "$YDK_STATUS" "Usage: ydk $*"
            return "${YDK_STATUS}"
        }
    }
    ydk:log() {
        local YDK_LOG_LEVEL="${1:-"INFO"}"
        local YDK_LOG_MESSAGE="${2:-""}"
        __log:show() {
            local YDK_LOG_TIMESTAMP=$(date +"%Y-%m-%d %H:%M:%S")
            echo -e "[${YDK_BRAND}] [$$] [$YDK_LOG_TIMESTAMP] ${YDK_LOG_LEVEL^^} ${YDK_LOG_MESSAGE}" >&1
        }
        if ! command -v jq >/dev/null 2>&1; then
            __log:show
        elif ! ydk:logger "$YDK_LOG_LEVEL" "$YDK_LOG_MESSAGE" 2>/dev/null; then
            __log:show
        fi
        unset -f __log:show
        return 0
    }
    ydk:catch() {
        local YDK_CATH_STATUS="${1:-$?}"
        local YDK_CATH_MESSAGE="${2:-"catch with: ${YDK_CATH_STATUS}"}"
        ydk:log error "($YDK_CATH_STATUS) ${YDK_CATH_MESSAGE} ($_)"
        return "${YDK_CATH_STATUS}"
    }
    ydk:throw() {
        local YDK_THROW_STATUS="${1:-$?}"
        local YDK_THROW_MESSAGE="${2:-"throw with: ${YDK_THROW_STATUS}"}"
        local YDK_TERM="${3:-"ERR"}"
        ydk:teardown "${YDK_THROW_STATUS}" "${YDK_THROW_MESSAGE} ($-) [$_]"
        exit "$YDK_THROW_STATUS"
    }
    ydk:temp() {
        local FILE_SUFFIX="${1}" && [[ -n "$FILE_SUFFIX" ]] && FILE_SUFFIX="${FILE_SUFFIX}"
        mktemp -u -t "${YDK_BRAND,,}.XXXXXXXX" -p "/tmp/ywteam/${YDK_PACKAGE_NAME,,}" --suffix=".$$.${FILE_SUFFIX,,}" >&4
    }
    ydk:opts() {
        local YDK_OPTS=$(ydk:argv walk "$@" 4>&1 | jq -r .)
        IFS=$'\n' read -r -d '' -a YDK_OPTS_ARGS <<<"$(jq -r '.__args[]' <<<"$YDK_OPTS")"
        set -- "${YDK_OPTS_ARGS[@]}"
        return 0
    }
    ydk:configure() {
        if [[ "$YDK_IS_INSTALL" == true ]]; then
            ydk:log info "Installing ydk"
            ydk:installer "$@" 4>&1
            local YDK_INSTALL_STATUS=$?
            ydk:team welcome
            exit "$YDK_INSTALL_STATUS"
        fi
        return 0
    }
    trap 'ydk:catch $? "An unexpected error occurred"' ERR INT TERM
    trap 'ydk:teardown $? "Script exited"' EXIT
    local YDK_FIFO="/tmp/ydk.fifo" && readonly YDK_FIFO
    [[ ! -p "${YDK_FIFO}" ]] && mkfifo "${YDK_FIFO}"
    exec 4<>"${YDK_FIFO}" # exec 4<&- | # exec 4>&1 | # exec 4<&0
    trap 'exec 4>&-; rm -f '"${YDK_FIFO}"'' EXIT
    if ! ydk:boostrap 2>&1; then
        ydk:throw 255 "Failed to boostrap ydk"
    fi
    ydk:configure "$@"
    ! ydk:require "${YDK_DEPENDENCIES[@]}" && ydk:throw 254 "Failed to load dependencies"
    ydk:prgma
    ydk:team welcome
    ydk:try "$@" 4>&1 || YDK_STATUS=$? && YDK_STATUS=${YDK_STATUS:-0}
    exec 4>&-
    rm -f "${YDK_FIFO}"
    return "${YDK_STATUS}"
}
if [[ "$#" -gt 0 ]]; then
    ydk "$@"
    exit $?
fi
