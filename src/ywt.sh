#!/bin/bash
# shellcheck disable=SC2044,SC2155,SC2317
# YELLOW TEAM BUNDLE
# {"name":"@yw-team/yw-sh","version":"0.0.0-alpha.0","author":{"name":"yw-team","email":"raphael@yellowteam.cloud","url":"https://yellowteam.cloud"}}
# This file is generated by yellowteam sdk builder. Do not edit this file
# Build date: 2024-03-12T21:44:03+00:00
# Build ID: f8a2c2c3159a863110d67ad62561dc1b10673177
# Build branch: main
# Build tag: Unknown
# Build commit: f8a2c2c
# Build author: Raphael Carlos Rego <raphaelcarlosr@gmail.com>
# Build message: Refactor code to improve performance and readability
# {"file":"/workspace/rapd-shell/sdk/lib/builder.ywt.sh","expires_at":"31/12/1999","size":"12K","md5":"237226746eead8024e6f26f60f3ad83a","sha1":"e098baaee665bd817ecea49daad258562f6e30a8","sha256":"90ae8cecffbf32c90a2504a0ef79ff9f844c6cdeb34fb1585b37b59e3a7c7b58","sha512":"7e2d5c39e559137036ebfbcf2b312094f5de62f4c3a2d2fc5eddb94c0fb61bc833ebbbb752e62f9e59868fdbb18cbfcaf686bffe1b7196f05248aac86ff6ed7b","created_at":"2024-03-12T21:44:03+00:00","binary":false}

builder() {
    local CONTEXT="[BUILDER] " && readonly CONTEXT
    local CONFIG_EXPIRES_AT="${YWT_CONFIG_BUILDER_EXPIRES_AT:-"31/12/2999"}"
    local DIST=${2:-"${YWT_CONFIG_BUILDER_DIST:-"$(jq -r .path.dist <<<"$YWT_CONFIG")"}"} && readonly DIST
    local SRC=${3:-"${YWT_CONFIG_BUILDER_SRC:-"$(jq -r .path.src <<<"$YWT_CONFIG")"}"} && readonly SRC
    local SDK=$(jq -r .path.sdk <<<"$YWT_CONFIG") && SDK=$(realpath -- "$SDK") && readonly SDK
    local BIN=$(jq -r .path.bin <<<"$YWT_CONFIG") && readonly BIN
    _prepare() {
        [[ ! -d "$DIST" ]] && mkdir -p "${DIST}"
        rm -fR "${DIST:?}"/*
        [[ ! -d "$BIN" ]] && mkdir -p "${BIN}"
        if ! command -v shc &>/dev/null; then
            wysiwyg colorize "red" "$CONTEXT compiler is not installed, trying install" | logger warn
            apt-get install shc -y || return 1
        fi
        local SHC_INSTALLED && SHC_INSTALLED=$(command -v shc)
        [[ -z "$SHC_INSTALLED" ]] && wysiwyg colorize "red" "$CONTEXT compiler is not installed" | logger error && return 1
        wysiwyg colorize "green" "$CONTEXT Compiler is installed" | logger success
    }
    _cleanup() {
        local KEEP_SOURCE="${YWT_CONFIG_BUILDER_KEEP_SOURCE:-false}"
        [[ "$KEEP_SOURCE" == true ]] && echo "Keeping sources" | logger info && return 0
        rm -f "${DIST}/"*.sh | logger verbose
        rm -f "${DIST}/"*.c | logger verbose
        echo "Sources removed" | logger info
    }
    _stats() {
        local TARGET=${1:?}
        local EXPIRES_AT="${2:-$CONFIG_EXPIRES_AT}"
        local FILENAME && FILENAME=$(basename -- "$TARGET") && FILENAME="${FILENAME%.*}"
        local IS_BINARY=false
        LC_ALL=C grep -a '[^[:print:][:space:]]' "$TARGET" >/dev/null && IS_BINARY=true
        echo "{"
        echo "  \"file\": \"$TARGET\","
        echo "  \"expires_at\": \"$EXPIRES_AT\","
        echo "  \"size\": \"$(du -h "$TARGET" | awk '{print $1}' 2>/dev/null)\","
        echo "  \"md5\": \"$(md5sum "$TARGET" | awk '{print $1}' 2>/dev/null)\","
        echo "  \"sha1\": \"$(sha1sum "$TARGET" | awk '{print $1}' 2>/dev/null)\","
        echo "  \"sha256\": \"$(sha256sum "$TARGET" | awk '{print $1}' 2>/dev/null)\","
        echo "  \"sha512\": \"$(sha512sum "$TARGET" | awk '{print $1}' 2>/dev/null)\"",
        echo "  \"created_at\": \"$(date -Iseconds)\"",
        echo "  \"binary\": $IS_BINARY"
        echo "}"
    }
    build_file() {
        local FILE=$1
        [[ ! -f "$FILE" ]] && echo "$FILE is not a valid file" | logger error && return 0
        local EXPIRES_AT="${2:-$CONFIG_EXPIRES_AT}"
        local FILENAME && FILENAME=$(basename -- "$FILE") && FILENAME="${FILENAME%.*}"
        wysiwyg colorize "blue" "Building file ${FILE} valid until ${EXPIRES_AT}" | logger info
        # shc -r -f "${FILE}" -e "${EXPIRES_AT}"
        # cp -f "$FILE" "$DIST/$FILENAME.sh"          # .s = sh source
        # mv -f "${FILE}.x" "${BIN}/$FILENAME"        # .x = executable
        # mv -f "${FILE}.x.c" "${DIST}/$FILENAME.c"   # .c = c source
        # stats "$FILE" "$EXPIRES_AT"
        wysiwyg colorize "green" "Build done. run ${BIN}/${FILENAME}" | logger success
    }
    copywrite() {
        echo "# YELLOW TEAM BUNDLE"
        echo "# $(jq -c .yellowteam <<<"$YWT_CONFIG")"
        echo "# This file is generated by yellowteam sdk builder. Do not edit this file"
        echo "# Build date: $(date -Iseconds)"
        echo "# Build ID: $(git rev-parse HEAD 2>/dev/null || echo "Unknown")"
        echo "# Build branch: $(git rev-parse --abbrev-ref HEAD 2>/dev/null || echo "Unknown")"
        echo "# Build tag: $(git describe --tags 2>/dev/null || echo "Unknown")"
        echo "# Build commit: $(git rev-parse --short HEAD 2>/dev/null || echo "Unknown")"
        echo "# Build author: $(git log -1 --pretty=format:'%an <%ae>' 2>/dev/null || echo "Unknown")"
        echo "# Build message: $(git log -1 --pretty=format:'%s' 2>/dev/null || echo "Unknown")"
    }
    __bundle() {
        local SRC_FILE=${1:?} && [ ! -f "$SRC_FILE" ] && echo "Invalid source file" | logger error && return 1
        local FILE_EXT="${SRC_FILE##*.}" && [[ "$FILE_EXT" != "sh" ]] && echo "Invalid file extension" | logger error && return 1
        local FILENAME=$(basename -- "$SRC_FILE") && FILENAME="${FILENAME%.*}"
        local FILE_BASEPATH=$(dirname -- "$SRC_FILE")
        local FILE_REALPATH=$(realpath -- "$FILE_BASEPATH")
        local FILE_RELATIVEPATH=$(realpath --relative-to="$SRC_FILE" "$FILE_BASEPATH")
        local BUNDLE_NAME="${2:-"${FILENAME}.sh"}" && [ -z "$BUNDLE_NAME" ] && echo "Invalid bundle name" | logger error && return 1
        local EXPIRES_AT="${3:-$CONFIG_EXPIRES_AT}" && [ -z "$EXPIRES_AT" ] && EXPIRES_AT="31/12/2999"
        local LIB=${FILE_REALPATH}/lib && [[ ! -d "$LIB" ]] && echo "${LIB} is not a valid directory" | logger error && return 0
        # local SRC=${3:-"${YWT_CONFIG_BUILDER_SRC:-"$(jq -r .path.src <<<"$YWT_CONFIG")"}"}
        local TARGET_FILE="${SRC}/${BUNDLE_NAME}" && [[ -f "$TARGET_FILE" ]] && rm -f "$TARGET_FILE"
        # {
        #     debug -n "{"
        #     debug -n "\"FILENAME\": \"$FILENAME\","
        #     debug -n "\"FILE_BASEPATH\": \"$FILE_BASEPATH\","
        #     debug -n "\"FILE_REALPATH\": \"$FILE_REALPATH\","
        #     debug -n "\"FILE_RELATIVEPATH\": \"$FILE_RELATIVEPATH\","
        #     debug -n "\"BUNDLE_NAME\": \"$BUNDLE_NAME\","
        #     debug -n "\"EXPIRES_AT\": \"$EXPIRES_AT\","
        #     debug -n "\"LIB\": \"$LIB\","
        #     debug -n "\"TARGET_FILE\": \"$TARGET_FILE\","
        #     debug -n "}"
        # }
        _inject() {
            local FILE="$1"
            [[ ! -f "$FILE" ]] && echo "$FILE is not a valid file" | logger error && return 0
            grep -v "^#" "$FILE" | grep -v "^$" | grep -v "^#!/usr/bin/env bash"
        }
        {
            echo "#!/bin/bash"
            echo "# shellcheck disable=SC2044,SC2155,SC2317"
            copywrite
            while read -r FILE; do
                local FILENAME && FILENAME=$(basename -- "$FILE")
                local RELATIVE_PATH && RELATIVE_PATH=$(realpath --relative-to="$SRC" "$FILE")
                local RELATIVE_PATH && RELATIVE_PATH=$(dirname -- "$RELATIVE_PATH")
                echo -e "# $(_stats "$FILE" "$EXPIRES_AT" | jq -c .)\n"
                _inject "$FILE"
                echo -e "\n# end of $FILENAME\n"
            done < <(find "$LIB" -type f -name "*.ywt.sh" | sort)
            # echo "Packaging ${GREEN}${SRC_FILE}${NC}" | logger debug
            echo -e "# $(_stats "$SRC_FILE" "$EXPIRES_AT" | jq -c .)\n"
            _inject "$SRC_FILE"
            echo -e "\n# end of $SRC_FILE\n"
            # echo -e "\nif [ \"\$#\" -gt 0 ]; then $FILENAME \"\$@\"; fi"
        } >>"$TARGET_FILE"
        _stats "$TARGET_FILE" "$EXPIRES_AT" | jq -Cc . | logger info
    }
    __build_file() {
        local FILE=$1 && readonly FILE && [[ ! -f "$FILE" ]] && echo "$FILE is not a valid file" | logger error && return 0
        local FILE_DIR=$(dirname -- "$FILE") && readonly FILE_DIR
        # local EXPIRES_AT="${2:-$CONFIG_EXPIRES_AT}" && [ -z "$EXPIRES_AT" ] && EXPIRES_AT="31/12/2999"
        EXPIRES_AT="31/12/9999"
        local FILENAME && FILENAME=$(basename -- "$FILE") && FILENAME="${FILENAME%.*}"
        wysiwyg colorize "blue" "Building file ${FILE} valid until ${EXPIRES_AT}" | logger info
        shc -r -f "${FILE}" -e "${EXPIRES_AT}"
        # .s = sh source | .c = c source | .x = executable
        [ -f "$DIST/$FILENAME.sh" ] && rm -f "$DIST/$FILENAME.sh"
        [ -f "$DIST/$FILENAME.c" ] && rm -f "$DIST/$FILENAME.c"
        [ -f "${BIN}/$FILENAME" ] && rm -f "${BIN}/$FILENAME"
        cp -f "$FILE" "$DIST/$FILENAME.sh"      # /dist/file.sh
        mv -f "${FILE}.x.c" "$DIST/$FILENAME.c" # /dist/file.c
        mv -f "${FILE}.x" "${BIN}/$FILENAME"    # /bin/file
        # mv -f "${FILE}.x.c" "${DIST}/$FILENAME.c"           # ./file.c
        wysiwyg colorize "green" "Build done. run ${BIN}/${FILENAME}" | logger success
        jq -Cn \
            --argjson sh "$(_stats "$DIST/$FILENAME.sh" "$EXPIRES_AT")" \
            --argjson c "$(_stats "$DIST/$FILENAME.c" "$EXPIRES_AT")" \
            --argjson bin "$(_stats "${BIN}/$FILENAME" "$EXPIRES_AT")" \
            '{sh: $sh, c: $c, bin: $bin}' | logger info
    }
    _build_sdk() {
        _prepare
        __bundle "$SDK/sdk.sh" "ywt.sh" "31/12/1999"
        __build_file "$SRC/ywt.sh" "31/12/1999"
        return 0
    }
    inspect() {
        jq -r '.path' <<<"$YWT_CONFIG"
    }
    # if nnf "$@"; then return 0; fi
    nnf "$@" || usage "$?" "builder" "$@" && return 1
    return 0
}
(
    export -f builder
)

# end of builder.ywt.sh

# {"file":"/workspace/rapd-shell/sdk/lib/colors.ywt.sh","expires_at":"31/12/1999","size":"8.0K","md5":"89e4caad83e5d931fb5abf39ab66b316","sha1":"c31fef017f74308f32c84117609f49814f1e72b6","sha256":"628aa7206518d5a6612204c3216223edcc6b47a926216f3cb7a1f427cf513a3f","sha512":"b8addea4df01e4def131d5e90d7da6102eb35bca35022ad7baaa0443d0e756811f84b3de10b72ad7d68ec8d4c15ad5cdbec4c390dc53bc10fad79f79f4a53c9f","created_at":"2024-03-12T21:44:03+00:00","binary":false}

wysiwyg() {
    rainbow() {
        local TEXT=${1:-$YWT_CMD_FILE} && shift
        local COLORS=("${@}") && [ ${#COLORS[@]} -eq 0 ] && COLORS=("${YWT_COLORS[@]}")
        local COLOR_COUNT=${#COLORS[@]}
        local LENGTH=${#TEXT}
        local INDEX=0
        for ((i = 0; i < LENGTH; i++)); do
            local CHAR=${TEXT:$i:1}
            local COLOR=${COLORS[$INDEX]}
            local COLOR_CODE=$(colorize "$COLOR" "$CHAR")
            echo -n "$COLOR_CODE"
            INDEX=$((INDEX + 1))
            [[ $INDEX -ge $COLOR_COUNT ]] && INDEX=0
        done
        echo
    }
    style() {
        local STYLE=${1:-bold} && STYLE=${STYLE,,}
        local TEXT=${2}
        local KIND=${3:-normal} && KIND=${KIND,,}
        [[ ! $KIND =~ ^(normal|italic|underline|blink|inverse|hidden)$ ]] && KIND=normal
        case $STYLE in
        bold) STYLE=1 ;;
        dim) STYLE=2 ;;
        italic) STYLE=3 ;;
        underline) STYLE=4 ;;
        blink) STYLE=5 ;;
        inverse) STYLE=7 ;;
        hidden) STYLE=8 ;;
        esac
        echo -e "\e[${STYLE}m${TEXT}\e[0m"
    }
    colorize() {
        local VAR=${1:-"NC"} && VAR=${VAR^^}
        local VARS=("${YWT_COLORS[@]}" "${YWT_STYLE[@]}")
        local IS_VALID=false
        for ITEM in "${VARS[@]}"; do
            [[ "${ITEM^^}" == "${VAR}" ]] && IS_VALID=true && break
        done
        [[ "$IS_VALID" == false ]] && VAR="NC"
        local KIND=fg
        [[ $VAR =~ bg$ ]] && KIND="bg"
        [[ $VAR =~ ^(bold|dim|italic|underline|blink|inverse|hidden)$ ]] && KIND=style
        VAR=${VAR//-/_}
        local COLOR=${VAR%%-*}
        [[ $KIND == "bg" || $KIND == "bg" ]] && COLOR=$((COLOR + 10))
        local TEXT=${2} # && while read -r LINE; do echo -e "$LINE"; done <<<"$TEXT"
        echo -e "\e[${!VAR}${TEXT}\e[0m${NC}"
        return 0
        # local COLOR=${1:-white} && COLOR=${COLOR,,}
        # local TEXT=${2}
        # local KIND=${3:-foreground} && KIND=${KIND,,}
        # [[ ! $KIND =~ ^(foreground|background|fg|bg)$ ]] && KIND=foreground
        # case $COLOR in
        # black) COLOR=30 ;;
        # bright-black) COLOR=90 ;;
        # red) COLOR=31 ;;
        # bright-red) COLOR=91 ;;
        # green) COLOR=32 ;;
        # bright-green) COLOR=92 ;;
        # yellow) COLOR=33 ;;
        # bright-yellow) COLOR=93 ;;
        # blue) COLOR=34 ;;
        # bright-blue) COLOR=94 ;;
        # magenta) COLOR=35 ;;
        # bright-magenta) COLOR=95 ;;
        # cyan) COLOR=36 ;;
        # bright-cyan) COLOR=96 ;;
        # white) COLOR=37 ;;
        # bright-white) COLOR=97 ;;
        # gray) COLOR=90 ;;
        # bright-gray) COLOR=37 ;;
        # purple) COLOR=35 ;;
        # bright-purple) COLOR=95 ;;
        # esac
        # [[ $KIND == "background" || $KIND == "bg" ]] && COLOR=$((COLOR + 10))
        # echo -e "\e[${COLOR}m${TEXT}\e[0m"
    }
    hyperlink() {
        local OSC=$'\e]'
        local BEL=$'\a'
        local SEP=';'
        local PARAM_SEP=':'
        local EQ='='        
        local URI=$1
        local TEXT=$2
        local PARAMS=$3
        local PARAM_STR=""
        for PARAM in "${!PARAMS[@]}"; do
            PARAM_STR+="${PARAM}${EQ}${PARAMS[$param]}${PARAM_SEP}"
        done
        # Remove the trailing PARAM_SEP
        PARAM_STR=${PARAM_STR%"$PARAM_SEP"}
        printf "%s8%s%s%s%s%s%s%s8%s%s%s" "$OSC" "$SEP" "$PARAM_STR" "$SEP" "$URI" "$BEL" "$TEXT" "$OSC" "$SEP" "$SEP" "$BEL"
        echo -en "${NC}${NSTL}${NBG}"
        # local TEXT=${1}
        # local URL=${2}
        # echo -e "\e]8;;${URL}\e\\${TEXT}\e]8;;\e\\"
    }
    nnf "$@" || usage "$?" "$@" && return 1
}
(
    export -f wysiwyg
)
export YWT_COLORS=(
    black black-bg bright-black dark-gray dark-gray-bg red red-bg bright-red green green-bg bright-green yellow yellow-bg bright-yellow blue blue-bg bright-blue purple purple-bg bright-purple cyan cyan-bg bright-cyan gray gray-bg bright-gray white white-bg bright-white
) && readonly YWT_COLORS
export YWT_STYLE=(
    bold dim italic underline blink inverse hidden
) && readonly YWT_STYLE
export BLACK=$'\033[0;30m' && readonly BLACK
export BLACK_BG=$'\033[40m' && readonly BLACK_BG
export BRIGHT_BLACK=$'\033[1;30m' && readonly BRIGHT_BLACK
export DARK_GRAY=$'\033[1;30m' && readonly DARK_GRAY
export DARK_GRAY_BG=$'\033[100m' && readonly DARK_GRAY_BG
export RED=$'\033[0;31m' && readonly RED
export RED_BG=$'\033[41m' && readonly RED_BG
export BRIGHT_RED=$'\033[1;31m' && readonly BRIGHT_RED
export GREEN=$'\033[0;32m' && readonly GREEN
export GREEN_BG=$'\033[42m' && readonly GREEN_BG
export BRIGHT_GREEN=$'\033[1;32m' && readonly BRIGHT_GREEN
export YELLOW=$'\033[0;33m' && readonly YELLOW
export YELLOW_BG=$'\033[43m' && readonly YELLOW_BG
export BRIGHT_YELLOW=$'\033[1;33m' && readonly BRIGHT_YELLOW
export BLUE=$'\033[0;34m' # export BLUE=$'\e[34m' && readonly BLUE
export BLUE_BG=$'\033[44m' && readonly BLUE_BG
export BRIGHT_BLUE=$'\033[1;34m' && readonly BRIGHT_BLUE
export PURPLE=$'\033[0;35m' && readonly PURPLE
export PURPLE_BG=$'\033[45m' && readonly PURPLE_BG
export BRIGHT_PURPLE=$'\033[1;35m' && readonly BRIGHT_PURPLE
export CYAN=$'\033[0;36m' && readonly CYAN
export CYAN_BG=$'\033[46m' && readonly CYAN_BG
export BRIGHT_CYAN=$'\033[1;36m' && readonly BRIGHT_CYAN
export GRAY=$'\033[0;37m' && readonly GRAY
export GRAY_BG=$'\033[47m' && readonly GRAY_BG
export BRIGHT_GRAY=$'\033[1;37m' && readonly BRIGHT_GRAY
export WHITE=$'\033[0;37m' && readonly WHITE
export WHITE_BG=$'\033[107m' && readonly WHITE_BG
export BRIGHT_WHITE=$'\033[1;37m' && readonly BRIGHT_WHITE
export BOLD=$'\033[1m' && readonly BOLD
export DIM=$'\033[2m' && readonly DIM
export ITALIC=$'\033[3m' && readonly ITALIC
export UNDERLINE=$'\033[4m' && readonly UNDERLINE
export BLINK=$'\033[5m' && readonly BLINK
export INVERSE=$'\033[7m' && readonly INVERSE
export HIDDEN=$'\033[8m' && readonly HIDDEN
export STRICKETHROUGH=$'\033[9m' && readonly STRICKETHROUGH
export NC=$'\033[0m' && readonly NC
export NBG=$'\033[49m' && readonly NBG
export NSTL=$'\033[24m' && readonly NSTL

# end of colors.ywt.sh

# {"file":"/workspace/rapd-shell/sdk/lib/config.ywt.sh","expires_at":"31/12/1999","size":"4.0K","md5":"c03cf1246a39e5aec99fdd1a7e1650a0","sha1":"6ec247ea15de23c8e78b70099acc9293da7ef614","sha256":"654b710a82288ee189ee8ac32cb0deb64ea3578944f8fd808dba317caab0415c","sha512":"a4208559c139efc62942a8ae722d9b6f43586de7973244f120be1edbce2a753dc4328914e69cf1d26ca22be473e0124f9c8f381dde4d535cbc2bb5188fb47471","created_at":"2024-03-12T21:44:04+00:00","binary":false}

config() {
    usage() {
        echo "usage: config"
    }
    nnf "$@" || usage "$?" "$@" && return 1
    return 0
    # local YWT_PATH_ROOT=$(dirname -- "$YWT_PATH_SRC")
    # local RADP_PROJECT_ROOT=$(dirname -- "$YWT_PATH_ROOT")
    # local YWT_PATH_TMP="${YWT_CONFIG_PATH_TMP:-"$(dirname -- "$(mktemp -d -u)")"}/ywt"
    # local YWT_PACKAGE=$(jq -c <"$YWT_PATH_SRC/package.json" 2>/dev/null)
    # local PACKAGES=$(find "$YWT_PATH_SRC/packages" -mindepth 1 -maxdepth 1 -type d -printf '%P\n' | jq -R -s -c 'split("\n") | map(select(length > 0))')
    # echo "{
    #         \"package\": $YWT_PACKAGE,
    #         \"env\": $(dotenv "$YWT_PATH_SRC/.env"),
    #         \"path\": $(paths),
    #         \"tools\": $(tools),
    #         \"packages\": $PACKAGES,
    #         \"program\": $(program "$@"),
    #         \"process\": $(process "$@"),
    #         \"hostinfo\": $(hostinfo),
    #         \"networkinfo\": $(networkinfo),
    #         \"userinfo\": $(userinfo),
    #         \"flags\": $(flags "$@"),
    #         \"params\": $(params "$@")
    #     }" | jq .
    # return 0
}
(
    export -f config
)

# end of config.ywt.sh

# {"file":"/workspace/rapd-shell/sdk/lib/dotenv.ywt.sh","expires_at":"31/12/1999","size":"4.0K","md5":"6cf46fb33a32e3db857e7baf8cb9dd54","sha1":"55491920e44d1b4903dc2354170097c3ba39da6c","sha256":"917a375086f0caff461386138abde73fa769dc6e3ffc522af2233fdcb67798bb","sha512":"09b13836eb1e832c06dd14c3ef20108064757e12a18bfa2d2e5b2dc8e7b581e7a60a5558830da474800e0c228b0c23ac1ff24d69f9db39b30fbcd9da194dcc12","created_at":"2024-03-12T21:44:04+00:00","binary":false}

dotenv() {
    load() {
        local FILE=${1}
        [ ! -f "$FILE" ] && logger error "File $FILE not found" && return 1
        # check if envsubst is available
        local CONTENT=$(cat "$FILE")
        # if ! command -v envsubst >/dev/null 2>&1; then
        #     logger warn "envsubst not found, using cat"
        #     local CONTENT=$(cat "$FILE")
        # else
        #     local CONTENT=$(envsubst "$@" <"$FILE") && [ -z "$CONTENT" ] && CONTENT=$(cat "$FILE")
        # fi
        [ -z "$CONTENT" ] && logger info "File $FILE is empty" && return 0
        local NS=${YWT_PROJECT_NAMESPACE:-YWT} && [ -n "$2" ] && NS="${NS}_${2^^}"
        local INJECT=${3:-false}
        local QUIET=${4:-true}
        local JSON="{"
        # logger info "Reading env file $file"
        # trap 'handle_error' ERR
        while IFS= read -r LINE || [ -n "$LINE" ]; do
            IFS='=' read -r KEY VALUE <<<"$LINE"
            [[ -z "$LINE" || -z "$KEY" || "$KEY" =~ ^#.*$ || "$VAR" =~ ^#.*$ ]] && continue
            [[ $INJECT == true ]] && export "${NS^^}_${KEY}"="$VALUE" # || echo "${NS^^}_${KEY}=$VALUE" >>"$YWT_PATH_TMP/.env" # eval "export ${NS^^}_${VAR}"
            JSON="$JSON\"${NS^^}_${KEY}\":\"${VALUE}\","
            [[ $QUIET == false ]] && logger debug "Setting ${NS^^}_${KEY}=$VALUE"
        done <<<"$CONTENT"
        JSON="${JSON%,}"
        JSON="$JSON}"
        echo "$JSON"
    }
    nnf "$@" || usage "$?" "$@" && return 1
}
(
    export -f dotenv
)

# end of dotenv.ywt.sh

# {"file":"/workspace/rapd-shell/sdk/lib/host.ywt.sh","expires_at":"31/12/1999","size":"4.0K","md5":"6dd878a297c5ed72287387f6401b12a5","sha1":"d3c9b09efa08c83ad3b83a3e8a7a7b6b469f1bab","sha256":"57bb8bad279cecf90d8df4666e2d7e3f097827181118cbd6a584e33b4c879755","sha512":"8423b82351d088de94dde399d21da46f49566f774a59b765f1d6f05eb4893f4205f1b5b931503ce1a2bfa08baf750c965bcb7ef91c3f4e1cf7d3ed644b3e6a80","created_at":"2024-03-12T21:44:04+00:00","binary":false}

host() {
    info() {
        local HOSTNAME=$(hostname)
        local OS=$(uname -s)
        local KERNEL=$(uname -r)
        local ARCH=$(uname -m)
        local CPU=$(lscpu | grep "Model name" | cut -d: -f2 | xargs)
        local MEM=$(free -h | awk '/^Mem:/ {print $2}')
        local DISK=$(df -h / | awk '/\// {print $2}')
        echo "{
            \"hostname\": \"$HOSTNAME\",
            \"os\": \"$OS\",
            \"kernel\": \"$KERNEL\",
            \"arch\": \"$ARCH\",
            \"cpu\": \"$CPU\",
            \"mem\": \"$MEM\",
            \"disk\": \"$DISK\"
        }"
    }
    nnf "$@" || usage "$?" "$@" && return 1
}

# end of host.ywt.sh

# {"file":"/workspace/rapd-shell/sdk/lib/logger.ywt.sh","expires_at":"31/12/1999","size":"4.0K","md5":"8642aab9c705581b79004831ff8fe214","sha1":"cdfd2ec70f14a706bb4b82255787e6ed5c572946","sha256":"1b44c1b221de8cde81a3c88520ff5da5b4e4843389289b7b046fb402292d05ea","sha512":"91e9e9ef4e3d7c5e2205263a6074316e96e1c5083e3b4aa3028978772342fc5affd857e7224afdf1eb403320c55c5d69227cf6c45befd351fdff445f118056f4","created_at":"2024-03-12T21:44:04+00:00","binary":false}

logger() {
    error() {
        log "error" "$*"
    }
    warn() {
        log "warn" "$*"
    }
    info() {
        log "info" "$*"
    }
    debug() {
        log "debug" "$*"
    }
    success() {
        log "info" "$*"
    }
    _log_level() {
        local LEVEL=${1:-info} && [[ ! $LEVEL =~ ^(debug|info|warn|error)$ ]] && LEVEL=info
        local COLOR=white
        case $LEVEL in
        debug) COLOR=cyan ;;
        info) COLOR=green ;;
        warn) COLOR=yellow ;;
        error) COLOR=red ;;
        esac
        LEVEL=$(printf "%-5s" "$LEVEL")
        echo -n "$(wysiwyg colorize "yellow" "[$YWT_CMD_NAME]") "
        echo -n "$(wysiwyg colorize "bright-black" "[$$]" "fg") "
        # echo -n "$(style "underline" "[$(etime)]" "fg") "
        echo -n "$(wysiwyg colorize "blue" "[$(date +"%Y-%m-%d %H:%M:%S")]" "fg") "
        echo -n "$(wysiwyg colorize "$COLOR" "$(wysiwyg style bold "[${LEVEL^^}]")" "fg") "
        echo -n " "
    }
    _log_message() {
        local MESSAGE=${1:-}
        local LINES=()
        [[ -n "$MESSAGE" ]] && LINES+=("$MESSAGE")
        [[ -p /dev/stdin ]] && while read -r LINE; do LINES+=("$LINE"); done <&0
        MESSAGE="${LINES[*]//$'\n'/$'\n' }"
        echo -n "$MESSAGE"
    }
    log() {
        local IS_JSON=${3:-false}
        _log_level "$1"
        [[ $IS_JSON == false ]] && _log_message "$2"
        [[ $IS_JSON == true ]] && jq -cC . <<<"$(_log_message "$2")"
        # elapsed time
        echo -n " $(wysiwyg colorize "bright-black" "[$(wysiwyg style "underline" "$(etime)")]" "fg")"
    }
    if nnf "$@"; then return 0; fi
    usage "$?" "$@" && return 1
}
(
    export -f logger
)

# end of logger.ywt.sh

# {"file":"/workspace/rapd-shell/sdk/lib/network.ywt.sh","expires_at":"31/12/1999","size":"4.0K","md5":"e52230f554f27f0be25ff975f42f842f","sha1":"4a22695bde8ff6c7b8c73b8cac839c3b58901243","sha256":"e0ff9f6471dd9b5a399e9201cbaf67a6d6cd5c49180bd1ac7641b73396f56ed6","sha512":"10db2c6c75315c0e175a63736ba7ab0892c8f4437708e152b72b8218b7c52d9fa1af3201b36aa8cb13ceff24ba7605caf5e143ed97938eac93522712efa49933","created_at":"2024-03-12T21:44:04+00:00","binary":false}

network() {
    info() {
        local IP=$(hostname -I | awk '{print $1}')
        local MAC=""
        local GATEWAY=""
        if command -v ip >/dev/null 2>&1; then
            GATEWAY=$(ip route | awk '/default/ {print $3}')
            MAC=$(ip link show | awk '/link\/ether/ {print $2}')
        fi
        local DNS=$(awk '/nameserver/ {print $2}' </etc/resolv.conf)
        local PUBLIC_IP=$(curl -s ifconfig.me)
        echo "{
            \"ip\": \"$IP\",
            \"mac\": \"$MAC\",
            \"gateway\": \"$GATEWAY\",
            \"dns\": \"$DNS\",
            \"public_ip\": \"$PUBLIC_IP\"
        }"
    }
    nnf "$@" || usage "$?" "$@" && return 1
}
(
    export -f network
)

# end of network.ywt.sh

# {"file":"/workspace/rapd-shell/sdk/lib/process.ywt.sh","expires_at":"31/12/1999","size":"4.0K","md5":"3f7ec0ff7ca8dd227815c32466c97886","sha1":"ceaf7ba81ee22f94ca9771658e37834245cc58c4","sha256":"8f5891a86ae03d00c2c4474594cfbc146cd0909f53baa31f86f1e0a639a74527","sha512":"c66ed03540adcdeb6ed48c7f0b70eaa9e0f110444e08f29ff484652856c0e9f192ab0ccb741f9b8c344dee07df740317b4bc565a7c70333bf4f103e56cccd4d8","created_at":"2024-03-12T21:44:04+00:00","binary":false}

process() {
    local YWT_CMD_PROCESS=$$ && readonly YWT_CMD_PROCESS
    local YWT_CMD_FILE=$0 && readonly YWT_CMD_FILE
    local YWT_CMD_ARGS=$* && readonly YWT_CMD_ARGS
    local YWT_CMD_ARGS_LEN=$# && readonly YWT_CMD_ARGS_LEN
    local YWT_IS_BINARY=false
    LC_ALL=C grep -a '[^[:print:][:space:]]' "$YWT_CMD_FILE" >/dev/null && YWT_IS_BINARY=true
    info() {
        local FILE="$YWT_CMD_FILE"
        echo "{
            \"pid\": \"$YWT_CMD_PROCESS\",
            \"file\": \"$FILE\",        
            \"args\": \"$YWT_CMD_ARGS\",
            \"args_len\": \"$YWT_CMD_ARGS_LEN\",
            \"name\": \"$YWT_CMD_NAME\",
            \"initialized\": \"$YWT_INITIALIZED\",
            \"binary\": \"$YWT_IS_BINARY\"
        }"
    }
    nnf "$@" || usage "$?" "process" "$@" && return 1
    return 0
}
(
    export -f process
)

# end of process.ywt.sh

# {"file":"/workspace/rapd-shell/sdk/lib/spinner.ywt.sh","expires_at":"31/12/1999","size":"4.0K","md5":"1813045fdf36b7bd00e17c73c1caf9fd","sha1":"417a8f6a36286d8a98d298378a1b88ca0cc3fda3","sha256":"a4822e6bb1294aa6c70f8a02fbb451f551835d348e0e89554e60a7d9e8775310","sha512":"2f522e98a60a16d7d8d17b140b4f1b0f7a5c5b6e8fe6877d9ad77cee9e03dd1e8bebc11762e990ec198aa5215e04b1678d5099daf5ca7a95e294010fc61ba558","created_at":"2024-03-12T21:44:04+00:00","binary":false}

spinner() {
    local pid=$1
    local delay=0.75
    local spinstr='|/-\'
    while ps a | awk '{print $1}' | grep -q "$pid"; do
        local temp=${spinstr#?}
        printf " [%c]  " "$spinstr"
        local spinstr=$temp${spinstr%"$temp"}
        sleep $delay
        printf "\b\b\b\b\b\b"
    done
    printf "    \b\b\b\b"
    # local CMD="$*"
    # local SPIN='-\|/'
    # local PID=$(spwan "$CMD")
    # logger info "Spinning PID: $PID"
    # local i=1
    # while true; do
    #     printf "\b%s" "${SPIN:i++%${#SPIN}:1}"
    #     sleep .1
    # done
    # # while kill -0 "$PID" 2>/dev/null; do
    # #     i=$(((i + 1) % 4))
    # #     printf "\r%s" "${SPIN:$i:1}"
    # #     sleep .1
    # # done
    # # printf "\r"
    # # spin() {
    # #     local PID=$(spwan "$CMD")
    # #     logger info "Spinning PID: $PID"
    # #     local i=1
    # #     while true; do
    # #         printf "\b%s" "${SPIN:i++%${#SPIN}:1}"
    # #         sleep .1
    # #     done
    # #     # while kill -0 "$PID" 2>/dev/null; do
    # #     #     i=$(((i + 1) % 4))
    # #     #     printf "\r%s" "${SPIN:$i:1}"
    # #     #     sleep .1
    # #     # done
    # #     # printf "\r"
    # # }
    # # spin & local SPIN_PID=$!
    # # wait "$SPIN_PID"
    # # kill "$SPIN_PID"
    # # local PID_INDEX=$(echo "${YWT_PIDS[@]}" | grep -n "$PID" | cut -d: -f1)
    # # [ -n "$PID_INDEX" ] && unset "YWT_PIDS[$PID_INDEX]"
}
(
    export -f spinner
)

# end of spinner.ywt.sh

# {"file":"/workspace/rapd-shell/sdk/lib/spwan.ywt.sh","expires_at":"31/12/1999","size":"4.0K","md5":"e712411c32dcd066cea0b03f72fe3938","sha1":"c326d75e1c5804ef11b46c9f29a42387acf3d537","sha256":"918217430075e94427c333ee33d10c5c41802f0c66ae80093b9aa106453f6641","sha512":"d73d26af89d7af255fa94eb77b43dd36df38c73a8cc8b0b38af27e1c70b8a9f1bf8dbe3b5eb1b1afa48e98e0547200366b5195872369f4e2bc68dafe3f79da8f","created_at":"2024-03-12T21:44:04+00:00","binary":false}

spwan() {
    [ -z "$YWT_PIDS" ] && declare -a YWT_PIDS && readonly YWT_PIDS
    run() {
        local CMD="$*"
        $CMD &
        YWT_PIDS+=($!)
        echo $!
        return 0
    }
    nnf "$@" || usage "$?" "$@" && return 1
}
(
    export -f spwan
)

# end of spwan.ywt.sh

# {"file":"/workspace/rapd-shell/sdk/lib/user.ywt.sh","expires_at":"31/12/1999","size":"4.0K","md5":"7a21504409726894684561dd9d2f0c8c","sha1":"2ec698e7b07523f0932b6b40f6d448d3def00259","sha256":"c0c0898eee4b30cdcd4bed7dd98b360718e07e7fdd77faf619353a0f445f5642","sha512":"1989b1858b99966bbc626a1991099e19b80562670df8172faf9bbd79dc7da0c7411a69a194f6aa005d7384e698fb8e119b1122d84f1e98ed7348d296d9e784de","created_at":"2024-03-12T21:44:04+00:00","binary":false}

user() {
    info() {
        local USER=$(whoami)
        local GROUP=$(id -gn)
        local USERID=$(id -u)
        local GROUPID=$(id -g)
        local HOME=~
        local SHELL="$SHELL"
        local SUDO=$(sudo -nv 2>&1 | grep "may run sudo" || true) && SUDO=${SUDO:-false}
        echo "{
            \"user\": \"$USER\",
            \"group\": \"$GROUP\",
            \"uid\": \"$USERID\",
            \"gid\": \"$GROUPID\",
            \"home\": \"$HOME\",
            \"shell\": \"$SHELL\",
            \"sudo\": \"$SUDO\"
        }"
    }
    runAsRoot() {
        local CMD="$*"
        if [ "$EUID" -ne 0 ] && [ "$YWT_CONFIG_USE_SUDO" = "true" ]; then
            CMD="sudo $CMD"
        fi
        $CMD
    }
    nnf "$@" || usage "$?" "$@" && return 1
}
(
    export -f user
)

# end of user.ywt.sh

# {"file":"/workspace/rapd-shell/sdk/sdk.sh","expires_at":"31/12/1999","size":"8.0K","md5":"69816263aafc73da5d7da20f215c2c45","sha1":"687549ee6e25443541435ebab1c48e92f467827b","sha256":"d0d7f090feeea1b65f6a84d7b64f7ffd1819f7daf87a1b989693a16f0b1e4f0a","sha512":"56504f75a398377f8c2b0093c00c72c4b31c07613afcf3dafd1e6ffdf3059081e53f448320f46d35f726b5ddb7c2e356cc77d62b7f2f3d7a32d0223cf4682310","created_at":"2024-03-12T21:44:04+00:00","binary":false}

sdk() {
    set -e -o pipefail
    local YWT_FIFO="/tmp/ywt.$$.fifo" && [ ! -p "$YWT_FIFO" ] && mkfifo "$YWT_FIFO"
    trap 'fail $? "An error occurred"' EXIT ERR INT TERM
    fail() {
        local RESULT=${1:$?} && shift
        [[ "$RESULT" -eq 0 ]] && return 0
        local MESSAGE=${1:-"An error occurred"} && shift
        rm -f "$YWT_FIFO"
        local ERROR && ERROR=$(jq -n --arg result "$RESULT" --arg message "$MESSAGE" --arg caller "${FUNCNAME[*]}" --arg args "$* ($!)" '{result: $result, message: $message, caller: $caller, args: $args}')
        logger error "$ERROR"
        kill -s EXIT $$ 2>/dev/null
        # echo "$MESSAGE" 1>&2
    }
    throw() {
        local ERROR_CODE=${1:$?} && shift
        local MESSAGE=${1:-"An error occurred"} && shift
        fail "$ERROR_CODE" "$MESSAGE"
    }
    # local YWT_CMD_NAME && YWT_CMD_NAME=$(basename -- "$0") && YWT_CMD_NAME="${YWT_CMD_NAME%.*}" && readonly YWT_CMD_NAME
    local YWT_CMD_NAME=ywt
    local YWT_INITIALIZED=false
    local YWT_DEBUG=${YWT_CONFIG_DEBUG:-false}
    debug() {
        [ -z "$YWT_DEBUG" ] || [ "$YWT_DEBUG" == false ] && return 0
        [ -z "$*" ] && return 1
        (echo "DEBUG: $*" >$YWT_FIFO) &
        true
    }
    etime() {
        ps -o etime= "$$" | sed -e 's/^[[:space:]]*//' | sed -e 's/\://'
    }
    paths() {
        local CMD && CMD=$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd) && readonly CMD
        local SDK="${CMD}"
        local PROJECT && PROJECT=$(dirname -- "$SDK") && PROJECT=$(realpath -- "$PROJECT") && readonly PROJECT
        local WORKSPACE && WORKSPACE=$(dirname -- "$PROJECT") && WORKSPACE=$(realpath -- "$WORKSPACE") && readonly WORKSPACE
        local TMP="${YWT_CONFIG_PATH_TMP:-"$(dirname -- "$(mktemp -d -u)")"}/${YWT_CMD_NAME}"
        echo -n "{"
        echo -n "\"cmd\":\"$CMD\","
        echo -n "\"workspace\":\"$WORKSPACE\","
        echo -n "\"project\":\"$PROJECT\","
        echo -n "\"sdk\":\"$SDK\"",
        echo -n "\"lib\":\"$SDK/lib\"",
        echo -n "\"src\":\"$PROJECT/src\"",
        echo -n "\"extensions\":\"$PROJECT/extensions\"",
        echo -n "\"packages\":\"$PROJECT/packages\"",
        echo -n "\"scripts\":\"$PROJECT/scripts\"",
        echo -n "\"tools\":\"$PROJECT/tools\"",
        echo -n "\"cli\":\"$PROJECT/cli\"",
        echo -n "\"apps\":\"$PROJECT/apps\"",
        echo -n "\"tests\":\"$PROJECT/tests\"",
        echo -n "\"bin\":\"$PROJECT/bin\"",
        echo -n "\"dist\":\"$PROJECT/dist\"",
        echo -n "\"tmp\":\"$TMP\"",
        echo -n "\"logs\":\"${YWT_CONFIG_PATH_LOGS:-"/var/log/$YWT_CMD_NAME"}\"",
        echo -n "\"cache\":\"${YWT_CONFIG_PATH_CACHE:-"/var/cache/${YWT_CMD_NAME}"}\"",
        echo -n "\"data\":\"${YWT_CONFIG_PATH_DATA:-"/var/lib/$YWT_CMD_NAME"}\"",
        echo -n "\"etc\":\"${YWT_CONFIG_PATH_ETC:-"/etc/$YWT_CMD_NAME"}\"",
        echo -n "\"pwd\":\"${YWT_CONFIG_PATH_CWD:-"${PWD}"}\""
        echo -n "}"
        echo ""
    }
    resources() {
        local TYPE=${1:-} && [ -z "$TYPE" ] && echo "Resource type not defined" && return 1
        local RESOURCE_PATH && RESOURCE_PATH=$(jq -r ".$TYPE" <<<"$YWT_PATHS")
        [ ! -d "$RESOURCE_PATH" ] && echo "Resource $TYPE not found" && return 1
        find "$RESOURCE_PATH" -mindepth 1 -maxdepth 1 -type d -printf '%P\n' | jq -R -s -c 'split("\n") | map(select(length > 0))'
    }
    appinfo() {
        local YWT_PACKAGE && YWT_PACKAGE=$(jq -c <"./package.json" 2>/dev/null)
        echo "$YWT_PACKAGE"
    }
    welcome() {
        # $(jq -r '.yellowteam' <<<"$YWT")
        local NAME && NAME=$(jq -r '.name' <<<"$YWT_APPINFO") && readonly NAME
        local VERSION && VERSION=$(jq -r '.version' <<<"$YWT_APPINFO") && readonly VERSION
        wysiwyg hyperlink "https://yellowteam.cloud" "$(wysiwyg colorize "yellow" "${NAME}@${VERSION} | Cloud Yellow Team | https://yellowteam.cloud")" | logger info
        # "Yellow Team"
        # ?utm_source=yellowteam&utm_medium=cli&utm_campaign=yellowteam
    }
    is_function() {
        local FUNC=${1:-} && [ -n "$(type -t "$FUNC")" ] && [ "$(type -t "$FUNC")" = function ]
    }
    [ -z "$YWT_PATHS" ] && local YWT_PATHS && YWT_PATHS=$(paths) && readonly YWT_PATHS
    [ -z "$YWT_APPINFO" ] && local YWT_APPINFO && YWT_APPINFO=$(appinfo) && readonly YWT_APPINFO
    # [ -z "$YWT_PROCESS" ] && local YWT_PROCESS && YWT_PROCESS=$(process) && readonly YWT_PROCESS
    bootstrap() {
        [ "$YWT_INITIALIZED" == true ] && return 0
        YWT_INITIALIZED=true
        # --argjson process "$YWT_PROCESS" \
        # return array of resources
        # resources packages
        # resources tools
        # resources scripts
        # resources extensions
        inject
        export YWT_CONFIG && YWT_CONFIG=$(
            jq -n \
                --argjson package "$YWT_APPINFO" \
                --argjson path "$YWT_PATHS" \
                --argjson process "$(process info)" \
                '{yellowteam: $package, path: $path, process: $process}'
        ) && readonly YWT_CONFIG
        debug "$(jq . <<<"$YWT_CONFIG")"
        # logger info "$(wysiwyg colorize "yellow" "$(jq -r '.yellowteam' <<<"$YWT") https://yellowteam.cloud")"
        export YWT_PATHS && readonly YWT_PATHS
        welcome
    }
    inspect() {
        jq -r '.' <<<"$YWT_CONFIG"
    }
    inject() {
        local LIB && LIB=$(jq -r '.lib' <<<"$YWT_PATHS") && readonly LIB && [ ! -d "$LIB" ] && return 0
        debug "Injecting libraries from $LIB"
        while read -r FILE; do
            local FILE_NAME && FILE_NAME=$(basename -- "$FILE") && FILE_NAME="${FILE_NAME%.*}" && FILE_NAME=$(echo "$FILE_NAME" | tr '[:upper:]' '[:lower:]')
            is_function "$FILE_NAME" && continue
            # shellcheck source=/dev/null # echo "source $FILE" 1>&2 &&
            [ -f "$FILE" ] && source "$FILE"
        done < <(find "$LIB" -type f -name "*.ywt.sh" | sort)
    }
    verbose() {
        echo "$1" 1>&2
    }
    nnf() {
        local FUNC=${1} #&& shift
        [ -z "$FUNC" ] && return 1
        local ARGS=("${@:2}") # local ARGS=("${@}")
        if [ -n "$(type -t "$FUNC")" ] && [ "$(type -t "$FUNC")" = function ]; then
            # echo "Running $FUNC with args: ${ARGS[*]}" 1>&2
            exec 3>&1
            trap 'exec 3>&-' EXIT
            local STATUS
            # $FUNC "${ARGS[@]}"
            local OUTPUT && OUTPUT=$($FUNC "${ARGS[@]}" 1>&3) # 2>&1
            STATUS=$?
            [ $STATUS -eq 0 ] && STATUS=success || STATUS=error
            #debug "Function $FUNC status: $STATUS" # 1>&2
            exec 3>&-
            echo "$OUTPUT" # && echo "$OUTPUT" 1>&2
            # (echo "$OUTPUT" >$YWT_FIFO) & true
        else
            # echo "Function $FUNC not found" | logger error
            return 1
        fi
    }
    usage() {
        local ERROR_CODE=${1:-0} && shift
        local CONTEXT=${1:-}
        local FUNC_LIST && FUNC_LIST=$(declare -F | awk '{print $3}') && FUNC_LIST=${FUNC_LIST[*]} && FUNC_LIST=$(echo "$FUNC_LIST" | sed -e 's/ /\n/g' | grep -v '^_' | sort | tr '\n' ' ' | sed -e 's/ $//')
        [ -z "$CONTEXT" ] && CONTEXT="sdk"
        [ -z "$*" ] && return 0
        echo "usage: ywt [$CONTEXT] [args] $*" | logger info
        echo "Available functions: (${YELLOW}${FUNC_LIST}${NC})" | logger info
        # for FUNC in $FUNC_LIST; do
        #     [[ "$FUNC" == _* ]] && continue
        #     echo "  $FUNC" | logger info
        # done
        return "$ERROR_CODE"
    }
    [ "$YWT_DEBUG" == true ] && (
        tail -f "$YWT_FIFO" | while IFS= read -r LINE || [ -n "$LINE" ]; do
            [ -z "$YWT_DEBUG" ] || [ "$YWT_DEBUG" == false ] && continue
            if [ -n "$(type -t "logger")" ] && [ "$(type -t "$FUNC")" = function ]; then
                #logger debug "$LINE" #1>&2
                echo "logger - $LINE" #1>&2
            else
                echo "echo - $LINE" #1>&2
            fi
        done
    ) &
    true
    bootstrap
    # bootstrap
    logger debug "${YELLOW}yw-sh${NC} ${GREEN}$*${NC}"
    if nnf "$@"; then return 0; fi
    usage "$?" "$@" && return 1
    # logger log info "SDK paths: $PATHS"
}
(
    export -f sdk
)
if [ "$#" -gt 0 ]; then sdk "$@"; fi

# end of /workspace/rapd-shell/sdk/sdk.sh

