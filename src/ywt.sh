#!/bin/bash
# shellcheck disable=SC2044,SC2155,SC2317
# YELLOW TEAM BUNDLE
# {"name":"@yw-team/yw-sh","description":"Yellow Team Shell SDK","version":"0.0.0-alpha.0","license":"MIT","homepage":"https://yellowteam.cloud","repository":{"type":"git","url":""},"bugs":{"url":"https://bugs.yellowteam.cloud"},"author":{"name":"Raphael Rego","email":"raphael@yellowteam.cloud","url":"https://raphaelcarlosr.dev"}}
# This file is generated by yellowteam sdk builder. Do not edit this file
# Build date: 2024-03-14T16:29:41+00:00
# Build ID: f92073f0d9ed162dea296dba83ef3ca67b51eb0d
# Build branch: main
# Build tag: Unknown
# Build commit: f92073f
# Build author: Raphael Carlos Rego <raphaelcarlosr@gmail.com>
# Build message: Update tests and SDK script
# {"file":"/workspace/rapd-shell/sdk/lib/builder.ywt.sh","expires_at":"31/12/2999","size":"12K","md5":"9817de35452c99434447a75264bc0975","sha1":"fbef893dd7aea4cccc13c51be4cdc6d89a710aed","sha256":"1ce6a70bcfefc1c6fb002f26b8d65b1d5c23cf1e461b05f4448cda9a1d6ab643","sha512":"efce44f1e9a8526bb3e7a78269eae1dbc9a89cca246d3ad15ef0f36f7b768089045409fb8fd2ff8f2ae112b3cffb45f052ca94b72db2a081fddbc0074b7053be","created_at":"2024-03-14T16:29:41+00:00","binary":false}

builder() {
    YWT_LOG_CONTEXT="BUILDER"
    local CONFIG_EXPIRES_AT="${YWT_CONFIG_BUILDER_EXPIRES_AT:-"31/12/2999"}"
    local DIST=${2:-"${YWT_CONFIG_BUILDER_DIST:-"$(jq -r .path.dist <<<"$YWT_CONFIG")"}"} && readonly DIST
    local SRC=${3:-"${YWT_CONFIG_BUILDER_SRC:-"$(jq -r .path.src <<<"$YWT_CONFIG")"}"} && readonly SRC
    local SDK=$(jq -r .path.sdk <<<"$YWT_CONFIG") && SDK=$(realpath -- "$SDK") && readonly SDK
    local BIN=$(jq -r .path.bin <<<"$YWT_CONFIG") && readonly BIN
    _prepare() {
        [[ ! -d "$DIST" ]] && mkdir -p "${DIST}"
        rm -fR "${DIST:?}"/*
        [[ ! -d "$BIN" ]] && mkdir -p "${BIN}"
        if ! command -v shc &>/dev/null; then
            colors apply "red" "$YWT_LOG_CONTEXT compiler is not installed, trying install" | logger warn
            apt-get install shc -y || return 1
        fi
        local SHC_INSTALLED && SHC_INSTALLED=$(command -v shc)
        [[ -z "$SHC_INSTALLED" ]] && colors apply "red" "$YWT_LOG_CONTEXT compiler is not installed" | logger error && return 1
        colors apply "green" "$YWT_LOG_CONTEXT Compiler is installed" | logger success
    }
    _cleanup() {
        local KEEP_SOURCE="${YWT_CONFIG_BUILDER_KEEP_SOURCE:-false}"
        [[ "$KEEP_SOURCE" == true ]] && echo "Keeping sources" | logger info && return 0
        rm -f "${DIST}/"*.sh | logger verbose
        rm -f "${DIST}/"*.c | logger verbose
        echo "Sources removed" | logger info
    }
    _stats() {
        local TARGET=${1:?}
        local EXPIRES_AT="${2:-$CONFIG_EXPIRES_AT}"
        local FILENAME && FILENAME=$(basename -- "$TARGET") && FILENAME="${FILENAME%.*}"
        local IS_BINARY=false
        LC_ALL=C grep -a '[^[:print:][:space:]]' "$TARGET" >/dev/null && IS_BINARY=true
        echo "{"
        echo "  \"file\": \"$TARGET\","
        echo "  \"expires_at\": \"$EXPIRES_AT\","
        echo "  \"size\": \"$(du -h "$TARGET" | awk '{print $1}' 2>/dev/null)\","
        echo "  \"md5\": \"$(md5sum "$TARGET" | awk '{print $1}' 2>/dev/null)\","
        echo "  \"sha1\": \"$(sha1sum "$TARGET" | awk '{print $1}' 2>/dev/null)\","
        echo "  \"sha256\": \"$(sha256sum "$TARGET" | awk '{print $1}' 2>/dev/null)\","
        echo "  \"sha512\": \"$(sha512sum "$TARGET" | awk '{print $1}' 2>/dev/null)\"",
        echo "  \"created_at\": \"$(date -Iseconds)\"",
        echo "  \"binary\": $IS_BINARY"
        echo "}"
    }
    __bundle() {
        local SRC_FILE=${1:?} && [ ! -f "$SRC_FILE" ] && echo "Invalid source file" | logger error && return 1
        local FILE_EXT="${SRC_FILE##*.}" && [[ "$FILE_EXT" != "sh" ]] && echo "Invalid file extension" | logger error && return 1
        local FILENAME=$(basename -- "$SRC_FILE") && FILENAME="${FILENAME%.*}"
        local FILE_BASEPATH=$(dirname -- "$SRC_FILE")
        local FILE_REALPATH=$(realpath -- "$FILE_BASEPATH")
        local FILE_RELATIVEPATH=$(realpath --relative-to="$SRC_FILE" "$FILE_BASEPATH")
        local BUNDLE_NAME="${2:-"${FILENAME}.sh"}" && [ -z "$BUNDLE_NAME" ] && echo "Invalid bundle name" | logger error && return 1
        local EXPIRES_AT="${3:-$CONFIG_EXPIRES_AT}" && [ -z "$EXPIRES_AT" ] && EXPIRES_AT="31/12/2999"
        local LIB=${FILE_REALPATH}/lib && [[ ! -d "$LIB" ]] && echo "${LIB} is not a valid directory" | logger error && return 0
        # local SRC=${3:-"${YWT_CONFIG_BUILDER_SRC:-"$(jq -r .path.src <<<"$YWT_CONFIG")"}"}
        local TARGET_FILE="${SRC}/${BUNDLE_NAME}" && [[ -f "$TARGET_FILE" ]] && rm -f "$TARGET_FILE"
        # {
        #     debug -n "{"
        #     debug -n "\"FILENAME\": \"$FILENAME\","
        #     debug -n "\"FILE_BASEPATH\": \"$FILE_BASEPATH\","
        #     debug -n "\"FILE_REALPATH\": \"$FILE_REALPATH\","
        #     debug -n "\"FILE_RELATIVEPATH\": \"$FILE_RELATIVEPATH\","
        #     debug -n "\"BUNDLE_NAME\": \"$BUNDLE_NAME\","
        #     debug -n "\"EXPIRES_AT\": \"$EXPIRES_AT\","
        #     debug -n "\"LIB\": \"$LIB\","
        #     debug -n "\"TARGET_FILE\": \"$TARGET_FILE\","
        #     debug -n "}"
        # }
        _inject() {
            local FILE="$1"
            [[ ! -f "$FILE" ]] && echo "$FILE is not a valid file" | logger error && return 0
            grep -v "^#" "$FILE" | grep -v "^$" | grep -v "^#!/usr/bin/env bash"
        }
        {
            echo "#!/bin/bash"
            echo "# shellcheck disable=SC2044,SC2155,SC2317"
            copyright
            while read -r FILE; do
                local FILENAME && FILENAME=$(basename -- "$FILE")
                local RELATIVE_PATH && RELATIVE_PATH=$(realpath --relative-to="$SRC" "$FILE")
                local RELATIVE_PATH && RELATIVE_PATH=$(dirname -- "$RELATIVE_PATH")
                echo -e "# $(_stats "$FILE" "$EXPIRES_AT" | jq -c .)\n"
                _inject "$FILE"
                echo -e "\n# end of $FILENAME\n"
            done < <(find "$LIB" -type f -name "*.ywt.sh" | sort)
            # echo "Packaging ${GREEN}${SRC_FILE}${NC}" | logger debug
            echo -e "# $(_stats "$SRC_FILE" "$EXPIRES_AT" | jq -c .)\n"
            _inject "$SRC_FILE"
            echo -e "\n# end of $SRC_FILE\n"
            # echo -e "\nif [ \"\$#\" -gt 0 ]; then $FILENAME \"\$@\"; fi"
        } >>"$TARGET_FILE"
        _stats "$TARGET_FILE" "$EXPIRES_AT" | jq -Cc . | logger info
    }
    __build_file() {
        local FILE=$1 && readonly FILE && [[ ! -f "$FILE" ]] && echo "$FILE is not a valid file" | logger error && return 0
        local FILE_DIR=$(dirname -- "$FILE") && readonly FILE_DIR
        local EXPIRES_AT="${2:-$CONFIG_EXPIRES_AT}" && [ -z "$EXPIRES_AT" ] && EXPIRES_AT="31/12/2999"
        # EXPIRES_AT="31/12/9999"
        local FILENAME && FILENAME=$(basename -- "$FILE") && FILENAME="${FILENAME%.*}"
        colors apply "blue" "Building file ${FILE} valid until ${EXPIRES_AT}" | logger info
        # -e %s  Expiration date in dd/mm/yyyy format [none]
        # -m %s  Message to display upon expiration ["Please contact your provider"]
        # -f %s  File name of the script to compile
        # -i %s  Inline option for the shell interpreter i.e: -e
        # -x %s  eXec command, as a printf format i.e: exec('%s',@ARGV);
        # -l %s  Last shell option i.e: --
        # -o %s  output filename
        # -r     Relax security. Make a redistributable binary
        # -v     Verbose compilation
        # -S     Switch ON setuid for root callable programs [OFF]
        # -D     Switch ON debug exec calls [OFF]
        # -U     Make binary untraceable [no]
        # -H     Hardening : extra security protection [no]
        #     Require bourne shell (sh) and parameters are not supported
        # -C     Display license and exit
        # -A     Display abstract and exit
        # -B     Compile for busybox
        # -h     Display help and exit
        shc -r -f "${FILE}" -e "${EXPIRES_AT}" -m "File expired since ${EXPIRES_AT}, please contact us to renew. $(jq -Cc .yellowteam <<<"$YWT_CONFIG")"
        # .s = sh source | .c = c source | .x = executable
        [ -f "$DIST/$FILENAME.sh" ] && rm -f "$DIST/$FILENAME.sh"
        [ -f "$DIST/$FILENAME.c" ] && rm -f "$DIST/$FILENAME.c"
        [ -f "${BIN}/$FILENAME" ] && rm -f "${BIN}/$FILENAME"
        cp -f "$FILE" "$DIST/$FILENAME.sh"      # /dist/file.sh
        mv -f "${FILE}.x.c" "$DIST/$FILENAME.c" # /dist/file.c
        mv -f "${FILE}.x" "${BIN}/$FILENAME"    # /bin/file
        # mv -f "${FILE}.x.c" "${DIST}/$FILENAME.c"           # ./file.c
        colors apply "green" "Build done. run ${BIN}/${FILENAME}" | logger success
        jq -Cn \
            --argjson sh "$(_stats "$DIST/$FILENAME.sh" "$EXPIRES_AT")" \
            --argjson c "$(_stats "$DIST/$FILENAME.c" "$EXPIRES_AT")" \
            --argjson bin "$(_stats "${BIN}/$FILENAME" "$EXPIRES_AT")" \
            '{sh: $sh, c: $c, bin: $bin}' | logger info
    }
    _build_sdk() {
        _prepare
        __bundle "$SDK/sdk.sh" "ywt.sh" "31/12/2999"
        # sed -i -e 's/# binary injection/text/g' "$SRC/ywt.sh"
        __build_file "$SRC/ywt.sh" "31/12/2999"
        return 0
    }
    inspect() {
        jq -r '.path' <<<"$YWT_CONFIG"
    }   
    _nnf "$@" || usage "$?" "builder" "$@" && return 1
    return 0
}
(
    export -f builder
)

# end of builder.ywt.sh

# {"file":"/workspace/rapd-shell/sdk/lib/colors.ywt.sh","expires_at":"31/12/2999","size":"8.0K","md5":"464f47ddceba3a0f90d349db76c68748","sha1":"72f9b9425dc1b72460307cda38c209a919d90ed1","sha256":"2e47a311ef78c56edc2879b02a2d2a18c1b490ba9c8d2deb9df3a06c2652c000","sha512":"e6271ac8b21529354a77e9721b56049af98f0740cbc38166f2a0b72c1ed702dcbe8b9cab04f6ddd8d02aed6027e062d2a4279034641d9172bbc76d5a24fbfee7","created_at":"2024-03-14T16:29:42+00:00","binary":false}

colors() {
    YWT_LOG_CONTEXT="colors"
    rainbow() {
        local TEXT=${1:-$YWT_CMD_FILE} && shift
        local COLORS=("${@}") && [ ${#COLORS[@]} -eq 0 ] && COLORS=("${YWT_COLORS[@]}")
        local COLOR_COUNT=${#COLORS[@]}
        local LENGTH=${#TEXT}
        local INDEX=0
        for ((i = 0; i < LENGTH; i++)); do
            local CHAR=${TEXT:$i:1}
            local COLOR=${COLORS[$INDEX]}
            local COLOR_CODE=$(colorize "$COLOR" "$CHAR")
            echo -n "$COLOR_CODE"
            INDEX=$((INDEX + 1))
            [[ $INDEX -ge $COLOR_COUNT ]] && INDEX=0
        done
        echo
    }
    apply() {
        local VAR=${1:-"NC"} && VAR=${VAR^^}
        local VARS=("${YWT_COLORS[@]}" "${YWT_STYLE[@]}")
        local IS_VALID=false
        for ITEM in "${VARS[@]}"; do
            [[ "${ITEM^^}" == "${VAR}" ]] && IS_VALID=true && break
        done
        [[ "$IS_VALID" == false ]] && VAR="NC"
        local KIND=fg
        [[ $VAR =~ bg$ ]] && KIND="bg"
        [[ $VAR =~ ^(bold|dim|italic|underline|blink|inverse|hidden)$ ]] && KIND=style
        VAR=${VAR//-/_}
        local COLOR=${VAR%%-*}
        [[ $KIND == "bg" || $KIND == "bg" ]] && COLOR=$((COLOR + 10))
        local TEXT=${2} # && while read -r LINE; do echo -e "$LINE"; done <<<"$TEXT"
        echo -e "\e[${!VAR}${TEXT}\e[0m${NC}"
        return 0
        # local COLOR=${1:-white} && COLOR=${COLOR,,}
        # local TEXT=${2}
        # local KIND=${3:-foreground} && KIND=${KIND,,}
        # [[ ! $KIND =~ ^(foreground|background|fg|bg)$ ]] && KIND=foreground
        # case $COLOR in
        # black) COLOR=30 ;;
        # bright-black) COLOR=90 ;;
        # red) COLOR=31 ;;
        # bright-red) COLOR=91 ;;
        # green) COLOR=32 ;;
        # bright-green) COLOR=92 ;;
        # yellow) COLOR=33 ;;
        # bright-yellow) COLOR=93 ;;
        # blue) COLOR=34 ;;
        # bright-blue) COLOR=94 ;;
        # magenta) COLOR=35 ;;
        # bright-magenta) COLOR=95 ;;
        # cyan) COLOR=36 ;;
        # bright-cyan) COLOR=96 ;;
        # white) COLOR=37 ;;
        # bright-white) COLOR=97 ;;
        # gray) COLOR=90 ;;
        # bright-gray) COLOR=37 ;;
        # purple) COLOR=35 ;;
        # bright-purple) COLOR=95 ;;
        # esac
        # [[ $KIND == "background" || $KIND == "bg" ]] && COLOR=$((COLOR + 10))
        # echo -e "\e[${COLOR}m${TEXT}\e[0m"
    }
    hyperlink() {
        local OSC=$'\e]'
        local BEL=$'\a'
        local SEP=';'
        local PARAM_SEP=':'
        local EQ='='        
        local URI=$1
        local TEXT=$2
        local PARAMS=$3
        local PARAM_STR=""
        for PARAM in "${!PARAMS[@]}"; do
            PARAM_STR+="${PARAM}${EQ}${PARAMS[$param]}${PARAM_SEP}"
        done
        # Remove the trailing PARAM_SEP
        PARAM_STR=${PARAM_STR%"$PARAM_SEP"}
        printf "%s8%s%s%s%s%s%s%s8%s%s%s" "$OSC" "$SEP" "$PARAM_STR" "$SEP" "$URI" "$BEL" "$TEXT" "$OSC" "$SEP" "$SEP" "$BEL"
        echo -en "${NC}${NSTL}${NBG}"
        # local TEXT=${1}
        # local URL=${2}
        # echo -e "\e]8;;${URL}\e\\${TEXT}\e]8;;\e\\"
    }
    _nnf "$@" || usage "$?" "$@" && return 1
}
(
    export -f colors
)
export YWT_COLORS=(
    black black-bg bright-black dark-gray dark-gray-bg red red-bg bright-red green green-bg bright-green yellow yellow-bg bright-yellow blue blue-bg bright-blue purple purple-bg bright-purple cyan cyan-bg bright-cyan gray gray-bg bright-gray white white-bg bright-white
) && readonly YWT_COLORS
export BLACK=$'\033[0;30m' && readonly BLACK
export BLACK_BG=$'\033[40m' && readonly BLACK_BG
export BRIGHT_BLACK=$'\033[1;30m' && readonly BRIGHT_BLACK
export DARK_GRAY=$'\033[1;30m' && readonly DARK_GRAY
export DARK_GRAY_BG=$'\033[100m' && readonly DARK_GRAY_BG
export RED=$'\033[0;31m' && readonly RED
export RED_BG=$'\033[41m' && readonly RED_BG
export BRIGHT_RED=$'\033[1;31m' && readonly BRIGHT_RED
export GREEN=$'\033[0;32m' && readonly GREEN
export GREEN_BG=$'\033[42m' && readonly GREEN_BG
export BRIGHT_GREEN=$'\033[1;32m' && readonly BRIGHT_GREEN
export YELLOW=$'\033[0;33m' && readonly YELLOW
export YELLOW_BG=$'\033[43m' && readonly YELLOW_BG
export BRIGHT_YELLOW=$'\033[1;33m' && readonly BRIGHT_YELLOW
export BLUE=$'\033[0;34m' # export BLUE=$'\e[34m' && readonly BLUE
export BLUE_BG=$'\033[44m' && readonly BLUE_BG
export BRIGHT_BLUE=$'\033[1;34m' && readonly BRIGHT_BLUE
export PURPLE=$'\033[0;35m' && readonly PURPLE
export PURPLE_BG=$'\033[45m' && readonly PURPLE_BG
export BRIGHT_PURPLE=$'\033[1;35m' && readonly BRIGHT_PURPLE
export CYAN=$'\033[0;36m' && readonly CYAN
export CYAN_BG=$'\033[46m' && readonly CYAN_BG
export BRIGHT_CYAN=$'\033[1;36m' && readonly BRIGHT_CYAN
export GRAY=$'\033[0;37m' && readonly GRAY
export GRAY_BG=$'\033[47m' && readonly GRAY_BG
export BRIGHT_GRAY=$'\033[1;37m' && readonly BRIGHT_GRAY
export WHITE=$'\033[0;37m' && readonly WHITE
export WHITE_BG=$'\033[107m' && readonly WHITE_BG
export BRIGHT_WHITE=$'\033[1;37m' && readonly BRIGHT_WHITE
export NC=$'\033[0m' && readonly NC
export NBG=$'\033[49m' && readonly NBG

# end of colors.ywt.sh

# {"file":"/workspace/rapd-shell/sdk/lib/config.ywt.sh","expires_at":"31/12/2999","size":"4.0K","md5":"097a2abcee1d1bc08c85b149aff23f0a","sha1":"7f151f79c042ae39624d60ad0196b37cdadf2c7c","sha256":"a4a9f530206070cdc4d24168fc7e4837959e5d895e811497a2954467a938b0c6","sha512":"cf7bbb2df2c19b5bdd02c1a8a9e76630f0d69c8c45d550f7c8c061529b6708c445b13630e64ee383e83b922ced5ccab713779414858813f97464169acb730004","created_at":"2024-03-14T16:29:42+00:00","binary":false}

config() {
    usage() {
        echo "usage: config"
    }
    _nnf "$@" || usage "$?" "$@" && return 1
    return 0
    # local YWT_PATH_ROOT=$(dirname -- "$YWT_PATH_SRC")
    # local RADP_PROJECT_ROOT=$(dirname -- "$YWT_PATH_ROOT")
    # local YWT_PATH_TMP="${YWT_CONFIG_PATH_TMP:-"$(dirname -- "$(mktemp -d -u)")"}/ywt"
    # local YWT_PACKAGE=$(jq -c <"$YWT_PATH_SRC/package.json" 2>/dev/null)
    # local PACKAGES=$(find "$YWT_PATH_SRC/packages" -mindepth 1 -maxdepth 1 -type d -printf '%P\n' | jq -R -s -c 'split("\n") | map(select(length > 0))')
    # echo "{
    #         \"package\": $YWT_PACKAGE,
    #         \"env\": $(dotenv "$YWT_PATH_SRC/.env"),
    #         \"path\": $(paths),
    #         \"tools\": $(tools),
    #         \"packages\": $PACKAGES,
    #         \"program\": $(program "$@"),
    #         \"process\": $(process "$@"),
    #         \"hostinfo\": $(hostinfo),
    #         \"networkinfo\": $(networkinfo),
    #         \"userinfo\": $(userinfo),
    #         \"flags\": $(flags "$@"),
    #         \"params\": $(params "$@")
    #     }" | jq .
    # return 0
}
(
    export -f config
)

# end of config.ywt.sh

# {"file":"/workspace/rapd-shell/sdk/lib/debugger.ywt.sh","expires_at":"31/12/2999","size":"4.0K","md5":"22636179a7a03f5c02c8f6e40464529c","sha1":"f6732eb857218b6cb185a4d4e82455d19ef2f65e","sha256":"7269dad1bf3b6a6ff94e9caac13ced3a5c25cabe0cf0c615254fb9b8168d86c2","sha512":"3a9cfc32d95fe669f2aa42b364d96fd34c32b082dc7e9d2e437a8ee9c083db973e0940a3ce010c0e3c8d2140644cb5d74beaf10d1bb72e55a85f248dbff2fcc8","created_at":"2024-03-14T16:29:42+00:00","binary":false}

debugger() {
    YWT_LOG_CONTEXT="debugger"
    _listen() {
        # listen to YWT_FIFO
        while read -r line; do
            echo "Received: $line" 1>&2
        done <"$YWT_FIFO"
        # [ "$YWT_DEBUG" == true ] && (
        #     tail -f "$YWT_FIFO" | while IFS= read -r LINE || [ -n "$LINE" ]; do
        #         [ -z "$YWT_DEBUG" ] || [ "$YWT_DEBUG" == false ] && continue
        #         if [ -n "$(type -t "logger")" ] && [ "$(type -t "$FUNC")" = function ]; then
        #             #logger debug "$LINE" #1>&2
        #             echo "logger - $LINE" #1>&2
        #         else
        #             echo "echo - $LINE" #1>&2
        #         fi
        #     done
        # ) &
    }
    _verbose() {
        echo "$1" 1>&2
    }
    if ioc _nnf "$@"; then return 0; fi
    usage "$?" "debugger" "$@" && return 1
}

# end of debugger.ywt.sh

# {"file":"/workspace/rapd-shell/sdk/lib/dotenv.ywt.sh","expires_at":"31/12/2999","size":"4.0K","md5":"b3c3f262e22dd06826fb99c550fbdd71","sha1":"b6800fcf08cef2b01b1047466790ad269da0928e","sha256":"de1038cc5934f86a3b58f3c4d48c8a2791da9514628d53aa95057edff3fd7a1a","sha512":"96f6d1fd12ebe345e79414e81485bfa158ad3c46add419a47d0e206ca13ee066e19a58a3a4f26756673feee993f9e48556d3bc1f73edf7da2363db97a19d5b34","created_at":"2024-03-14T16:29:42+00:00","binary":false}

dotenv() {
    load() {
        local FILE=${1}
        [ ! -f "$FILE" ] && logger error "File $FILE not found" && return 1
        # check if envsubst is available
        local CONTENT=$(cat "$FILE")
        # if ! command -v envsubst >/dev/null 2>&1; then
        #     logger warn "envsubst not found, using cat"
        #     local CONTENT=$(cat "$FILE")
        # else
        #     local CONTENT=$(envsubst "$@" <"$FILE") && [ -z "$CONTENT" ] && CONTENT=$(cat "$FILE")
        # fi
        [ -z "$CONTENT" ] && logger info "File $FILE is empty" && return 0
        local NS=${YWT_PROJECT_NAMESPACE:-YWT} && [ -n "$2" ] && NS="${NS}_${2^^}"
        local INJECT=${3:-false}
        local QUIET=${4:-true}
        local JSON="{"
        # logger info "Reading env file $file"
        # trap 'handle_error' ERR
        while IFS= read -r LINE || [ -n "$LINE" ]; do
            IFS='=' read -r KEY VALUE <<<"$LINE"
            [[ -z "$LINE" || -z "$KEY" || "$KEY" =~ ^#.*$ || "$VAR" =~ ^#.*$ ]] && continue
            [[ $INJECT == true ]] && export "${NS^^}_${KEY}"="$VALUE" # || echo "${NS^^}_${KEY}=$VALUE" >>"$YWT_PATH_TMP/.env" # eval "export ${NS^^}_${VAR}"
            JSON="$JSON\"${NS^^}_${KEY}\":\"${VALUE}\","
            [[ $QUIET == false ]] && logger debug "Setting ${NS^^}_${KEY}=$VALUE"
        done <<<"$CONTENT"
        JSON="${JSON%,}"
        JSON="$JSON}"
        echo "$JSON"
    }
    _nnf "$@" || usage "$?" "$@" && return 1
}
(
    export -f dotenv
)

# end of dotenv.ywt.sh

# {"file":"/workspace/rapd-shell/sdk/lib/errors.ywt.sh","expires_at":"31/12/2999","size":"4.0K","md5":"dbf18bc7333880529228f8e72b41c8ce","sha1":"178698ceaa503fb39a444c60ba75460e9200a562","sha256":"865c7f35921ab66d83a96da36c9e10a38bf62417cf78fd828a40bbaf6bea6f5c","sha512":"7716dca8d324f60458f36baeed13c10390941bd970713f340471e70ad04abf100829136ca7e95937ba35b2e213b0b4c92572d01876f94671f8dec68143e89fd1","created_at":"2024-03-14T16:29:42+00:00","binary":false}

errors() {
    code() {
        local code=${1:?} && [ -z "$code" ] && echo "Invalid error code" | logger error && return 1
        local message=${2:?} && [ -z "$message" ] && echo "Invalid error message" | logger error && return 1
        echo "{
            \"code\": \"$code\",
            \"message\": \"$message\"
        }"
    }
    _throw() {
        local ERROR_CODE=${1:$?} && shift
        local MESSAGE=${1:-"An error occurred"} && shift
        _fail "$ERROR_CODE" "$MESSAGE"
    }
    _nnf "$@" || usage "$?" "styles" "$@" && return 1
    return 0
}
(
    export -f errors
)

# end of errors.ywt.sh

# {"file":"/workspace/rapd-shell/sdk/lib/host.ywt.sh","expires_at":"31/12/2999","size":"4.0K","md5":"daa6ae3619e2b9b53335df844c7dd52f","sha1":"85b46ee886c8c2e4cb2912d42c9f7ed2ff54c123","sha256":"e804e7ba33be422026f6ce32f35ac4a920586c8430dcd7ccecd04d3d88acb5c3","sha512":"66439d5b6e4e593a6e1ce6db0f83dd64cf7b53c9db45a62e9fcdc569bd2d806832ec9d6c1c0159fca5c60d6ef856e1490a65bb148f792d20927f38852caeb117","created_at":"2024-03-14T16:29:42+00:00","binary":false}

host() {
    info() {
        local HOSTNAME=$(hostname)
        local OS=$(uname -s)
        local KERNEL=$(uname -r)
        local ARCH=$(uname -m)
        local CPU=$(lscpu | grep "Model name" | cut -d: -f2 | xargs)
        local MEM=$(free -h | awk '/^Mem:/ {print $2}')
        local DISK=$(df -h / | awk '/\// {print $2}')
        echo "{
            \"hostname\": \"$HOSTNAME\",
            \"os\": \"$OS\",
            \"kernel\": \"$KERNEL\",
            \"arch\": \"$ARCH\",
            \"cpu\": \"$CPU\",
            \"mem\": \"$MEM\",
            \"disk\": \"$DISK\"
        }"
    }
    _nnf "$@" || usage "$?" "$@" && return 1
}

# end of host.ywt.sh

# {"file":"/workspace/rapd-shell/sdk/lib/ioc.ywt.sh","expires_at":"31/12/2999","size":"4.0K","md5":"46144eaf28c4f983766c3f5745560224","sha1":"d16fab679bee59cb2d581d4cc836369b853ef49a","sha256":"be6f1bd96c8968bc912b14eafed0b01fcf799f79ce8fabaf7693f23a80a9eb45","sha512":"40f38a2e50f5f51ed91a99be012f916f38d0346d6ee8a6a4ddf03d4662208f500fce0bc060070aac8df3f5fba2fd20b53c9a27141310bd2ca9144a978417c00d","created_at":"2024-03-14T16:29:42+00:00","binary":false}

ioc() {    
    YWT_LOG_CONTEXT="ioc"
    echo "ioc"
}
(
    export -f ioc
)

# end of ioc.ywt.sh

# {"file":"/workspace/rapd-shell/sdk/lib/logger.ywt.sh","expires_at":"31/12/2999","size":"4.0K","md5":"23b0edb62d4a065bfa36412eeae66d6d","sha1":"bb101c6e6c1c8438bffcf660722856f97aa3413d","sha256":"11634c48f794ac98ff13aa3a4caf6e9c63dfd0a3a01f599d02415cd43e9a0967","sha512":"cca6e675dc5c9dde897005e5481df865d635e62396cfb0c43aa99326651de40d87a900a907aec51e32ea9af6ef84c892998a2d427295978aac629aec357d3d31","created_at":"2024-03-14T16:29:42+00:00","binary":true}

logger() {
    # YWT_LOG_CONTEXT=${YWT_LOG_CONTEXT:-logger}
    _is_log_level() {
        local LEVEL=${1:-info} && [[ ! $LEVEL =~ ^(debug|info|warn|error|success)$ ]] && LEVEL=info
        local LOG_LEVEL=${YWT_LOG_LEVEL:-info}
        [[ $LOG_LEVEL == "debug" ]] && [[ $LEVEL == "debug" ]] && return 0
        [[ $LOG_LEVEL == "info" ]] && [[ $LEVEL == "info" ]] && return 0
        [[ $LOG_LEVEL == "warn" ]] && [[ $LEVEL == "warn" ]] && return 0
        [[ $LOG_LEVEL == "error" ]] && [[ $LEVEL == "error" ]] && return 0
        [[ $LOG_LEVEL == "success" ]] && [[ $LEVEL == "success" ]] && return 0
        return 1
    }
    _log_level() {
        local LEVEL=${1:-info} && [[ ! $LEVEL =~ ^(debug|info|warn|error|success)$ ]] && LEVEL=info
        local COLOR=white
        local ICON=""
        case $LEVEL in
        debug)
            COLOR=cyan
            ICON="🐞"
            ;;
        info)
            COLOR=green
            ICON="📗"
            ;;
        warn)
            COLOR=yellow
            ICON="🔔"
            ;;
        error)
            COLOR=red
            ICON="🚨"
            ;;
        success)
            COLOR=green
            ICON="✅"
            ;;
        esac
        LEVEL=$(printf "%-5s" "$LEVEL") #YWT_LOG_CONTEXT
        echo -n "$(colors apply "yellow" "[${YWT_CMD_NAME^^}]") "
        echo -n "$(colors apply "bright-black" "[$$]" "fg") "
        # echo -n "$(style "underline" "[$(etime)]" "fg") "
        echo -n "$(colors apply "blue" "[$(date +"%Y-%m-%d %H:%M:%S")]" "fg") "
        echo -n "$(colors apply "$COLOR" "$(styles bold "[${LEVEL^^}]")" "fg") "
        [[ "${YWT_LOG_CONTEXT^^}" != "${YWT_CMD_NAME^^}" ]] && echo -n "$(colors apply "blue" "[${YWT_LOG_CONTEXT^^}]") "
        [ -n "$ICON" ] && echo -n "$(colors apply "$COLOR" "$ICON" "fg")"
        echo -n " "
    }
    _log_message() {
        local MESSAGE=${1:-}
        local LINES=()
        [[ -n "$MESSAGE" ]] && LINES+=("$MESSAGE")
        [[ -p /dev/stdin ]] && while read -r LINE; do LINES+=("$LINE"); done <&0
        MESSAGE="${LINES[*]//$'\n'/$'\n' }"
        echo -n "$MESSAGE"
    }
    log() {
        _log_level "$1"
        _log_message "$2"
        # elapsed time
        echo " $(colors apply "bright-black" "[$(styles "underline" "$(etime)")]" "fg")"
    }
    json() {
        _log_level "$1"
        jq -cC . <<<"$(_log_message "$2")"
    }
    local LEVEL=${1}
    if [[ $LEVEL =~ ^(debug|info|warn|error|success)$ ]]; then
        # ARGS=("${@:2}")
        shift # && LEVEL="log ${LEVEL}"
        log "${LEVEL}" "$@" && return 0
    elif [[ $LEVEL == "json" ]]; then
        shift # && LEVEL="json ${LEVEL}"
        json "${LEVEL}" "$@" && return 0
    elif _nnf "$@"; then
        return 0
        usage "$?" "logger" "$@" && return 1
    else
        usage 1 "logger" "$@" && return 1
    fi
}
(
    export -f logger
)

# end of logger.ywt.sh

# {"file":"/workspace/rapd-shell/sdk/lib/network.ywt.sh","expires_at":"31/12/2999","size":"4.0K","md5":"d620ee350cb4d3bd8debc52c46dc51cf","sha1":"5d0acad5ed8090a7e1c29a27d79e6417294f5bc0","sha256":"c7c7e4df78d6dc400698c61b7e925a7ebb1c9428a7ee482d19c3123f4fd49790","sha512":"c061aff3756867cfaec36b82f971e42f8d8bac9be3003dccd9dabe1255fe41da2b0994a5b888ff53b03f4bf8416c91e43b7b184dbb73191fb8993a2636d23ba8","created_at":"2024-03-14T16:29:42+00:00","binary":false}

network() {
    info() {
        local IP=$(hostname -I | awk '{print $1}')
        local MAC=""
        local GATEWAY=""
        if command -v ip >/dev/null 2>&1; then
            GATEWAY=$(ip route | awk '/default/ {print $3}')
            MAC=$(ip link show | awk '/link\/ether/ {print $2}')
        fi
        local DNS=$(awk '/nameserver/ {print $2}' </etc/resolv.conf)
        local PUBLIC_IP=$(curl -s ifconfig.me)
        echo "{
            \"ip\": \"$IP\",
            \"mac\": \"$MAC\",
            \"gateway\": \"$GATEWAY\",
            \"dns\": \"$DNS\",
            \"public_ip\": \"$PUBLIC_IP\"
        }"
    }
    _nnf "$@" || usage "$?" "$@" && return 1
}
(
    export -f network
)

# end of network.ywt.sh

# {"file":"/workspace/rapd-shell/sdk/lib/process.ywt.sh","expires_at":"31/12/2999","size":"4.0K","md5":"d9f8ff61ecc4abf7a2c2443cedd88ae0","sha1":"c23e53eb4e00850be4e874773f616b68a6dfa3fa","sha256":"967c9f78fe84ce18e2bfe2f5f37a629e8dacad3e2978763f2575e42bb5cd6e8e","sha512":"6c3a0259831c83f78ab336c2fd644ebca324c74df96d8dabc903a0e991730f5ec3b564e64b2c14a8ca9dd06987425ee57bcb4af214edc84aaa5524f0d189d0c0","created_at":"2024-03-14T16:29:42+00:00","binary":false}

process() {
    local YWT_CMD_PROCESS=$$ && readonly YWT_CMD_PROCESS
    local YWT_CMD_FILE=$0 && readonly YWT_CMD_FILE
    local YWT_CMD_ARGS=$* && readonly YWT_CMD_ARGS
    local YWT_CMD_ARGS_LEN=$# && readonly YWT_CMD_ARGS_LEN
    local YWT_IS_BINARY=false
    LC_ALL=C grep -a '[^[:print:][:space:]]' "$YWT_CMD_FILE" >/dev/null && YWT_IS_BINARY=true
    info() {
        local FILE="$YWT_CMD_FILE"
        echo "{
            \"pid\": \"$YWT_CMD_PROCESS\",
            \"file\": \"$FILE\",        
            \"args\": \"$YWT_CMD_ARGS\",
            \"args_len\": \"$YWT_CMD_ARGS_LEN\",
            \"name\": \"$YWT_CMD_NAME\",
            \"initialized\": \"$YWT_INITIALIZED\",
            \"binary\": \"$YWT_IS_BINARY\"
        }"
    }
    _nnf "$@" || usage "$?" "process" "$@" && return 1
    return 0
}
(
    export -f process
)

# end of process.ywt.sh

# {"file":"/workspace/rapd-shell/sdk/lib/spinner.ywt.sh","expires_at":"31/12/2999","size":"4.0K","md5":"1813045fdf36b7bd00e17c73c1caf9fd","sha1":"417a8f6a36286d8a98d298378a1b88ca0cc3fda3","sha256":"a4822e6bb1294aa6c70f8a02fbb451f551835d348e0e89554e60a7d9e8775310","sha512":"2f522e98a60a16d7d8d17b140b4f1b0f7a5c5b6e8fe6877d9ad77cee9e03dd1e8bebc11762e990ec198aa5215e04b1678d5099daf5ca7a95e294010fc61ba558","created_at":"2024-03-14T16:29:42+00:00","binary":false}

spinner() {
    local pid=$1
    local delay=0.75
    local spinstr='|/-\'
    while ps a | awk '{print $1}' | grep -q "$pid"; do
        local temp=${spinstr#?}
        printf " [%c]  " "$spinstr"
        local spinstr=$temp${spinstr%"$temp"}
        sleep $delay
        printf "\b\b\b\b\b\b"
    done
    printf "    \b\b\b\b"
    # local CMD="$*"
    # local SPIN='-\|/'
    # local PID=$(spwan "$CMD")
    # logger info "Spinning PID: $PID"
    # local i=1
    # while true; do
    #     printf "\b%s" "${SPIN:i++%${#SPIN}:1}"
    #     sleep .1
    # done
    # # while kill -0 "$PID" 2>/dev/null; do
    # #     i=$(((i + 1) % 4))
    # #     printf "\r%s" "${SPIN:$i:1}"
    # #     sleep .1
    # # done
    # # printf "\r"
    # # spin() {
    # #     local PID=$(spwan "$CMD")
    # #     logger info "Spinning PID: $PID"
    # #     local i=1
    # #     while true; do
    # #         printf "\b%s" "${SPIN:i++%${#SPIN}:1}"
    # #         sleep .1
    # #     done
    # #     # while kill -0 "$PID" 2>/dev/null; do
    # #     #     i=$(((i + 1) % 4))
    # #     #     printf "\r%s" "${SPIN:$i:1}"
    # #     #     sleep .1
    # #     # done
    # #     # printf "\r"
    # # }
    # # spin & local SPIN_PID=$!
    # # wait "$SPIN_PID"
    # # kill "$SPIN_PID"
    # # local PID_INDEX=$(echo "${YWT_PIDS[@]}" | grep -n "$PID" | cut -d: -f1)
    # # [ -n "$PID_INDEX" ] && unset "YWT_PIDS[$PID_INDEX]"
}
(
    export -f spinner
)

# end of spinner.ywt.sh

# {"file":"/workspace/rapd-shell/sdk/lib/spwan.ywt.sh","expires_at":"31/12/2999","size":"4.0K","md5":"0c691c09a4a17a0eb50a21d3267482ca","sha1":"c6bed10f49fa590acfb906dc155442fe80eefb34","sha256":"ff5bafbce559ec75ec6b1ed7fab6d0d7b42409d6d35d19c490e57e355b1df8a7","sha512":"c76fc611a386cb31e839b405e1a2ec31c6ab57a141bb69ff14f3cab109c0d8d7322f519a0b90529674a0c214c30d60254a72c2eefa611ca5aef3d1421d14f014","created_at":"2024-03-14T16:29:42+00:00","binary":false}

spwan() {
    [ -z "$YWT_PIDS" ] && declare -a YWT_PIDS && readonly YWT_PIDS
    run() {
        local CMD="$*"
        $CMD &
        YWT_PIDS+=($!)
        echo $!
        return 0
    }
    _nnf "$@" || usage "$?" "$@" && return 1
}
(
    export -f spwan
)

# end of spwan.ywt.sh

# {"file":"/workspace/rapd-shell/sdk/lib/styles.ywt.sh","expires_at":"31/12/2999","size":"4.0K","md5":"9997de4ac157b3401ca5f5b41a1e6623","sha1":"2868935e10f608921e93445cb81572f320fd05b5","sha256":"869e24673f28a08ddfa9d9d5a0689e86a2a4d3ec71534846dbe941ed96da1271","sha512":"b38939228b4bd337265020d419b244c1f6e63a93d5da664a762fbcad6e4ab8029f6ec7d4f0da6c01fa9d0d606b8c1bc73c3ce7e2115da8b0443d5fcbdd07e008","created_at":"2024-03-14T16:29:42+00:00","binary":false}

styles() {
    YWT_LOG_CONTEXT="styles"
    apply() {
        local STYLE=${1:-bold} && STYLE=${STYLE,,}
        local TEXT=${2}
        local KIND=${3:-normal} && KIND=${KIND,,}
        [[ ! $KIND =~ ^(normal|italic|underline|blink|inverse|hidden)$ ]] && KIND=normal
        case $STYLE in
        bold) STYLE=1 ;;
        dim) STYLE=2 ;;
        italic) STYLE=3 ;;
        underline) STYLE=4 ;;
        blink) STYLE=5 ;;
        inverse) STYLE=7 ;;
        hidden) STYLE=8 ;;
        esac
        echo -e "\e[${STYLE}m${TEXT}\e[0m"
    }
    bold(){
        apply bold "$@"
    }
    dim(){
        apply dim "$@"
    }
    italic(){
        apply italic "$@"
    }
    underline(){
        apply underline "$@"
    }
    blink(){
        apply blink "$@"
    }
    inverse(){
        apply inverse "$@"
    }
    hidden(){
        apply hidden "$@"
    }
    _nnf "$@" || usage "$?" "styles" "$@" && return 1
    return 0
}
(
    export -f styles
)
export NSTL=$'\033[24m' && readonly NSTL
export BOLD=$'\033[1m' && readonly BOLD
export DIM=$'\033[2m' && readonly DIM
export ITALIC=$'\033[3m' && readonly ITALIC
export UNDERLINE=$'\033[4m' && readonly UNDERLINE
export BLINK=$'\033[5m' && readonly BLINK
export INVERSE=$'\033[7m' && readonly INVERSE
export HIDDEN=$'\033[8m' && readonly HIDDEN
export STRICKETHROUGH=$'\033[9m' && readonly STRICKETHROUGH
export YWT_STYLE=(
    bold dim italic underline blink inverse hidden
) && readonly YWT_STYLE

# end of styles.ywt.sh

# {"file":"/workspace/rapd-shell/sdk/lib/tests.ywt.sh","expires_at":"31/12/2999","size":"4.0K","md5":"37dbb5d5610ada70aec9ddadd1e9ba9f","sha1":"d816ac4719f0511c96c2463d15ecd2b31cc86190","sha256":"b3d4d33cb518a32136256d4a1d8d70eb6531fe23581f2f9ea972e04843c56f5f","sha512":"8d92c727b05035fc6b66be49b75b0aeeb9b8a82497d29b7478b31a5be2fd93d4d47d1b07bc839a42200feb23c8ca16c9d16f777e552d4111e422bf9aa8e00f96","created_at":"2024-03-14T16:29:42+00:00","binary":false}

tests() {
    YWT_LOG_CONTEXT="TESTS"
    local TESTS_DIR="$(jq -r '.tests' <<<"$YWT_PATHS")"
    local TMP_DIR="$(jq -r '.tmp' <<<"$YWT_PATHS")"
    local TEST_HELPER_DIR="${TESTS_DIR}/helpers" && mkdir -p "${TEST_HELPER_DIR}"
    cleanup() {
        logger info "Cleaning up tests"
        rm -f -r "${TEST_HELPER_DIR}/bats"
        rm -f -r "${TEST_HELPER_DIR}/bats-assert"
        rm -f -r "${TEST_HELPER_DIR}/bats-support"
        rm -f -r "${TEST_HELPER_DIR}/bats-file"
        rm -f "/usr/local/bin/bats"
    }
    setup() {
        [ "${1}" == true ] && cleanup
        [ ! -d "${TEST_HELPER_DIR}/bats" ] && logger info "getting bats" && git clone https://github.com/bats-core/bats-core.git "${TEST_HELPER_DIR}/bats" &>/dev/null
        [ ! -d "${TEST_HELPER_DIR}/bats-assert" ] && logger info "getting bats-assert" && git clone https://github.com/bats-core/bats-assert.git "${TEST_HELPER_DIR}/bats-assert" &>/dev/null
        [ ! -d "${TEST_HELPER_DIR}/bats-support" ] && logger info "getting bats-support" && git clone https://github.com/bats-core/bats-support.git "${TEST_HELPER_DIR}/bats-support" &>/dev/null
        [ ! -d "${TEST_HELPER_DIR}/bats-file" ] && logger info "getting bats-file" && git clone https://github.com/bats-core/bats-file.git "${TEST_HELPER_DIR}/bats-file" &>/dev/null
        if ! command -v bats >/dev/null 2>&1; then
            logger info "installing bats"
            chmod -R +x "${TEST_HELPER_DIR}"
            "${TEST_HELPER_DIR}"/bats/install.sh /usr/local | tee /dev/null | logger debug
            bats --version | logger debug
        fi
    }
    #  --filter-tags "!tcp"
    unit() {
        local ARGS=("${@}")
        local BATS_VERSION=$(bats --version)
        logger info "Bats version: ${BATS_VERSION} ${TESTS_DIR}"
        # --filter <regex>      Only run tests that match the regular expression
        # filter-tags           <comma-separated-tag-list> Only run tests that match all the tags in the list (&&). You can negate a tag via prepending '!'. Specifying this flag multiple times allows for logical or (||): `--filter-tags A,B --filter-tags A,!C` matches tags (A && B) || (A && !C)
        # --trace              Print test commands as they are executed (like `set -x`)
        # --verbose-run        Make `run` print `$output` by default
        # bats --no-tempdir-cleanup \
        #     --recursive \
        #     --verbose-run \
        #     "${TESTS_DIR}"/*.bats 2>&1
        local TEST_RESULT=$(
            bats --recursive \
                --no-tempdir-cleanup \
                --output "${TMP_DIR:-"/tmp"}" \
                --show-output-of-passing-tests \
                --print-output-on-failure \
                --jobs 1 \
                --tap \
                --formatter pretty \
                "${ARGS[@]}" \
                "${TESTS_DIR}"/*.bats 2>&1
        )
        local TEST_EXIT_CODE=$?
        logger info "Test exit code: ${TEST_EXIT_CODE}"
        logger info "Test result: ${TEST_RESULT}"
    }
    case "$1" in
    cleanup) cleanup ;;
    setup) setup ;;
    unit) shift && setup false && unit "$@" ;;
    *) setup && unit "$@" ;;
    esac
    # _nnf "$@" || usage "$?" "tests" "$@" && return 1
    # return 0
}

# end of tests.ywt.sh

# {"file":"/workspace/rapd-shell/sdk/lib/user.ywt.sh","expires_at":"31/12/2999","size":"4.0K","md5":"2a0ab36c7afdd5190cc49c6da0f47ef1","sha1":"d164b63ae1121ba8279848616975011b5397d209","sha256":"c31ee1276ead1c5ed6be98ec41971d2211a216dc106353203ac773a2141ace76","sha512":"9af1ed2d54f07fe081fba241b2585cfb1ebf16687efcc7adb6898c0a5eaaf55e5a3173b6c65804b68e66e06f6a7020661de6ad2e0d494f79f3efac886d02c9ba","created_at":"2024-03-14T16:29:42+00:00","binary":false}

user() {
    info() {
        local USER=$(whoami)
        local GROUP=$(id -gn)
        local USERID=$(id -u)
        local GROUPID=$(id -g)
        local HOME=~
        local SHELL="$SHELL"
        local SUDO=$(sudo -nv 2>&1 | grep "may run sudo" || true) && SUDO=${SUDO:-false}
        echo "{
            \"user\": \"$USER\",
            \"group\": \"$GROUP\",
            \"uid\": \"$USERID\",
            \"gid\": \"$GROUPID\",
            \"home\": \"$HOME\",
            \"shell\": \"$SHELL\",
            \"sudo\": \"$SUDO\"
        }"
    }
    runAsRoot() {
        local CMD="$*"
        if [ "$EUID" -ne 0 ] && [ "$YWT_CONFIG_USE_SUDO" = "true" ]; then
            CMD="sudo $CMD"
        fi
        $CMD
    }
    _nnf "$@" || usage "$?" "$@" && return 1
}
(
    export -f user
)

# end of user.ywt.sh

# {"file":"/workspace/rapd-shell/sdk/sdk.sh","expires_at":"31/12/2999","size":"12K","md5":"934e033aa30c9d356d76566c4b92b407","sha1":"19478740da060bfb6bf45195332dbed4c9fc4856","sha256":"5b50ab216f93e0c94efb8e4a8a5a3e05b36698ece531a0f6119ad27f7ca911a2","sha512":"9a9b2c9ed4c15145ef751aff47594fb3322ac3f35a296b057788852c1e55ba8bd208dbb05169a7855a6482f258ecee83028aceb9a1d7fb6c30f84c4394e2e5e0","created_at":"2024-03-14T16:29:42+00:00","binary":false}

export YWT_SDK_FILE="${BASH_SOURCE[0]:-$0}" && readonly YWT_SDK_FILE
sdk() {
    set -e -o pipefail
    local YWT_FIFO="/tmp/ywt.$$.fifo" && [ ! -p "$YWT_FIFO" ] && mkfifo "$YWT_FIFO"
    export YWT_LOG_CONTEXT="ywt"
    export YWT_LOG_DEFAULT_CONTEXT="ywt" && readonly YWT_LOG_DEFAULT_CONTEXT
    trap '_fail $? "An error occurred"' EXIT ERR INT TERM
    _fail() {
        local RESULT=${1:$?} && shift
        [[ "$RESULT" -eq 0 ]] && return 0
        local MESSAGE=${1:-"An error occurred"} && shift
        rm -f "$YWT_FIFO"
        local ERROR && ERROR=$(jq -n --arg result "$RESULT" --arg message "$MESSAGE" --arg caller "${FUNCNAME[*]}" --arg args "$* ($!)" '{result: $result, message: $message, caller: $caller, args: $args}')
        # logger error "$ERROR"
        kill -s EXIT $$ 2>/dev/null
        # echo "$MESSAGE" 1>&2
    }
    # local YWT_CMD_NAME && YWT_CMD_NAME=$(basename -- "$0") && YWT_CMD_NAME="${YWT_CMD_NAME%.*}" && readonly YWT_CMD_NAME
    local YWT_CMD_NAME=ywt
    local YWT_INITIALIZED=false
    local YWT_DEBUG=${YWT_CONFIG_DEBUG:-false}
    etime() {
        ps -o etime= "$$" | sed -e 's/^[[:space:]]*//' | sed -e 's/\://'
    }
    paths() {
        local CMD && CMD=$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd) && readonly CMD
        local SDK="${CMD}"
        local PROJECT && PROJECT=$(dirname -- "$SDK") && PROJECT=$(realpath -- "$PROJECT") && readonly PROJECT
        local WORKSPACE && WORKSPACE=$(dirname -- "$PROJECT") && WORKSPACE=$(realpath -- "$WORKSPACE") && readonly WORKSPACE
        local TMP="${YWT_CONFIG_PATH_TMP:-"$(dirname -- "$(mktemp -d -u)")"}/${YWT_CMD_NAME}"
        echo -n "{"
        echo -n "\"cmd\":\"$CMD\","
        echo -n "\"workspace\":\"$WORKSPACE\","
        echo -n "\"project\":\"$PROJECT\","
        echo -n "\"sdk\":\"$SDK\"",
        echo -n "\"lib\":\"$SDK/lib\"",
        echo -n "\"src\":\"$PROJECT/src\"",
        echo -n "\"extensions\":\"$PROJECT/extensions\"",
        echo -n "\"packages\":\"$PROJECT/packages\"",
        echo -n "\"scripts\":\"$PROJECT/scripts\"",
        echo -n "\"tools\":\"$PROJECT/tools\"",
        echo -n "\"cli\":\"$PROJECT/cli\"",
        echo -n "\"apps\":\"$PROJECT/apps\"",
        echo -n "\"tests\":\"$PROJECT/tests\"",
        echo -n "\"bin\":\"$PROJECT/bin\"",
        echo -n "\"dist\":\"$PROJECT/dist\"",
        echo -n "\"tmp\":\"$TMP\"",
        echo -n "\"logs\":\"${YWT_CONFIG_PATH_LOGS:-"/var/log/$YWT_CMD_NAME"}\"",
        echo -n "\"cache\":\"${YWT_CONFIG_PATH_CACHE:-"/var/cache/${YWT_CMD_NAME}"}\"",
        echo -n "\"data\":\"${YWT_CONFIG_PATH_DATA:-"/var/lib/$YWT_CMD_NAME"}\"",
        echo -n "\"etc\":\"${YWT_CONFIG_PATH_ETC:-"/etc/$YWT_CMD_NAME"}\"",
        echo -n "\"pwd\":\"${YWT_CONFIG_PATH_CWD:-"${PWD}"}\""
        echo -n "}"
        echo ""
    }
    resources() {
        local TYPE=${1:-} && [ -z "$TYPE" ] && echo "Resource type not defined" && return 1
        local RESOURCE_PATH && RESOURCE_PATH=$(jq -r ".$TYPE" <<<"$YWT_PATHS")
        [ ! -d "$RESOURCE_PATH" ] && echo "Resource $TYPE not found" && return 1
        find "$RESOURCE_PATH" -mindepth 1 -maxdepth 1 -type d -printf '%P\n' | jq -R -s -c 'split("\n") | map(select(length > 0))'
    }
    appinfo() {
        local YWT_PACKAGE && YWT_PACKAGE=$(jq -c <"./package.json" 2>/dev/null)
        echo "$YWT_PACKAGE"
    }
    copyright() {
        echo "# YELLOW TEAM BUNDLE"
        echo "# $(jq -c .yellowteam <<<"$YWT_CONFIG")"
        echo "# This file is generated by yellowteam sdk builder. Do not edit this file"
        echo "# Build date: $(date -Iseconds)"
        echo "# Build ID: $(git rev-parse HEAD 2>/dev/null || echo "Unknown")"
        echo "# Build branch: $(git rev-parse --abbrev-ref HEAD 2>/dev/null || echo "Unknown")"
        echo "# Build tag: $(git describe --tags 2>/dev/null || echo "Unknown")"
        echo "# Build commit: $(git rev-parse --short HEAD 2>/dev/null || echo "Unknown")"
        echo "# Build author: $(git log -1 --pretty=format:'%an <%ae>' 2>/dev/null || echo "Unknown")"
        echo "# Build message: $(git log -1 --pretty=format:'%s' 2>/dev/null || echo "Unknown")"
    }
    welcome() {
        # $(jq -r '.yellowteam' <<<"$YWT")
        local NAME && NAME=$(jq -r '.name' <<<"$YWT_APPINFO") && readonly NAME
        local VERSION && VERSION=$(jq -r '.version' <<<"$YWT_APPINFO") && readonly VERSION
        colors hyperlink "https://yellowteam.cloud" "$(colors apply "yellow" "${NAME}@${VERSION} | Cloud Yellow Team | https://yellowteam.cloud")" | logger info
        # "Yellow Team"
        # ?utm_source=yellowteam&utm_medium=cli&utm_campaign=yellowteam
    }
    _is_function() {
        local FUNC=${1:-} && [ -n "$(type -t "$FUNC")" ] && [ "$(type -t "$FUNC")" = function ]
    }
    [ -z "$YWT_PATHS" ] && local YWT_PATHS && YWT_PATHS=$(paths) && readonly YWT_PATHS
    [ -z "$YWT_APPINFO" ] && local YWT_APPINFO && YWT_APPINFO=$(appinfo) && readonly YWT_APPINFO
    # [ -z "$YWT_PROCESS" ] && local YWT_PROCESS && YWT_PROCESS=$(process) && readonly YWT_PROCESS
    _debug() {
        [ -z "$YWT_DEBUG" ] || [ "$YWT_DEBUG" == false ] && return 0
        [ -z "$*" ] && return 1
        (echo "DEBUG: $*" >"$YWT_FIFO") &
        true
    }
    _nnf() {
        local FUNC=${1} && [ -z "$FUNC" ] && return 1
        local ARGS=("${@:2}") # local ARGS=("${@}")
        if [ -n "$(type -t "$FUNC")" ] && [ "$(type -t "$FUNC")" = function ]; then
            # [[ "$FUNC" == "builder" ]] && echo "Running $FUNC with args: ${ARGS[*]}" 1>&2
            exec 3>&1
            trap 'exec 3>&-' EXIT
            local STATUS
            # $FUNC "${ARGS[@]}"
            local OUTPUT && OUTPUT=$($FUNC "${ARGS[@]}" 1>&3) # 2>&1
            STATUS=$?
            [ $STATUS -eq 0 ] && STATUS=success || STATUS=error
            #debug "Function $FUNC status: $STATUS" # 1>&2
            exec 3>&-
            echo "$OUTPUT" # && echo "$OUTPUT" 1>&2
            # (echo "$OUTPUT" >$YWT_FIFO) & true
        else
            # echo "Function $FUNC not found" | logger error
            return 1
        fi
    }
    _inject_lib() {
        local LIB="${1:-}" && [ ! -d "$LIB" ] && return 1
        [ ! -d "$LIB" ] && return 1
        # local LIB && LIB=$(jq -r '.lib' <<<"$YWT_PATHS") && readonly LIB && [ ! -d "$LIB" ] && return 0
        _debug "Injecting libraries from $LIB"
        while read -r FILE; do
            local FILE_NAME && FILE_NAME=$(basename -- "$FILE") && FILE_NAME="${FILE_NAME%.*}" && FILE_NAME=$(echo "$FILE_NAME" | tr '[:upper:]' '[:lower:]')
            _is_function "$FILE_NAME" && continue
            # shellcheck source=/dev/null # echo "source $FILE" 1>&2 &&
            [ -f "$FILE" ] && source "$FILE"
        done < <(find "$LIB" -type f -name "*.ywt.sh" | sort)
    }
    _bootstrap() {
        [ "$YWT_INITIALIZED" == true ] && return 0
        YWT_INITIALIZED=true
        # --argjson process "$YWT_PROCESS" \
        # return array of resources
        # resources packages
        # resources tools
        # resources scripts
        # resources extensions
        _inject_lib "$(jq -r '.lib' <<<"$YWT_PATHS")"
        export YWT_CONFIG && YWT_CONFIG=$(
            jq -n \
                --argjson package "$YWT_APPINFO" \
                --argjson path "$YWT_PATHS" \
                --argjson process "$(process info)" \
                '{yellowteam: $package, path: $path, process: $process}'
        ) && readonly YWT_CONFIG
        _debug "$(jq . <<<"$YWT_CONFIG")"
        # logger info "$(colors apply "yellow" "$(jq -r '.yellowteam' <<<"$YWT") https://yellowteam.cloud")"
        export YWT_PATHS && readonly YWT_PATHS
        welcome
    }
    inspect() {
        jq -r '.' <<<"$YWT_CONFIG"
    }
    usage() {
        local ERROR_CODE=${1:-0} && shift
        local CONTEXT=${1:-}
        local FUNC_LIST && FUNC_LIST=$(declare -F | awk '{print $3}') && FUNC_LIST=${FUNC_LIST[*]} && FUNC_LIST=$(echo "$FUNC_LIST" | sed -e 's/ /\n/g' | grep -v '^_' | sort | tr '\n' ' ' | sed -e 's/ $//')
        [ -z "$CONTEXT" ] && CONTEXT="sdk"
        [ -z "$*" ] && return 0
        echo "usage error ($ERROR_CODE): ywt [$CONTEXT]($#)[$*]" | logger info
        echo "Available functions: (${YELLOW}${FUNC_LIST}${NC})" | logger info
        # for FUNC in $FUNC_LIST; do
        #     [[ "$FUNC" == _* ]] && continue
        #     echo "  $FUNC" | logger info
        # done
        return "$ERROR_CODE"
    }
    _bootstrap && logger debug "${YELLOW}yw-sh${NC} ${GREEN}$*${NC}"
    _nnf "$@" && return 0
    local STATUS=$? && usage "$STATUS" "sdk" "$@" && return 1
    # if _nnf "$@"; then 
    #     return 0
    # else
    #     local STATUS=$? && usage "$STATUS" "sdk" "$@" && return 1
    # fi
    # _nnf "$@" || local STATUS=$? && usage "$STATUS" "sdk" "$@" && return 1
    # return 0
}
ywt() {
    [ "$#" -eq 0 ] && return 0
    local FUNC=${1} && [ -z "$FUNC" ] && return 1
    FUNC=${FUNC#_} && FUNC=${FUNC#__}
    local ARGS=("${@:2}")
    sdk "$FUNC" "${ARGS[@]}"
    return 0
}
(
    export -f ywt
)
if [ "$#" -gt 0 ]; then
    SDK_FILE="$(realpath -- "${YWT_SDK_FILE}")" && export SDK_FILE
    if ! LC_ALL=C grep -a '[^[:print:][:space:]]' "$SDK_FILE" >/dev/null; then
        ywt "$@"
        exit $?
    else
        # binary injection
        # echo "Binary file ($#) $*" 1>&2
        ywt "$@"
        exit $?
    fi
fi

# end of /workspace/rapd-shell/sdk/sdk.sh

