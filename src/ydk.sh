#!/bin/bash
# YELLOW TEAM BUNDLE
# {"name":"@yw-team/yw-sh","description":"Cloud Yellow Team | Shell SDK","version":"0.0.0-alpha.0","license":"MIT","homepage":"https://yellowteam.cloud","repository":{"type":"git","url":""},"bugs":{"url":"https://bugs.yellowteam.cloud"},"author":{"name":"Raphael Rego","email":"raphael@yellowteam.cloud","url":"https://raphaelcarlosr.dev"}}
# This file is generated by yellowteam sdk builder. Do not edit this file
# Build date: 2024-04-06T00:55:20+00:00
# Build ID: dfcd961aca149f49e97a8474da4e4c61922d0e1a
# Build branch: main
# Build tag: Unknown
# Build commit: dfcd961
# Build author: Raphael C. Rego <raphaelcarlosr@gmail.com>
# Build message: Add spinner examples and clear commands to readme.md
# <app-info.ywt.sh>
ywt:info() {
    package() {
        [[ -n "$YWT_PACKAGE" ]] && echo "$YWT_PACKAGE" && return 0
        local YWT_PACKAGE && YWT_PACKAGE=$(jq -c <"./package.json" 2>/dev/null) && export YWT_PACKAGE && readonly YWT_PACKAGE
        echo "$YWT_PACKAGE"
    }
    welcome() {
        local YWT_PACKAGE=$(package)
        local NAME && NAME=$(jq -r '.name' <<<"$YWT_PACKAGE") && readonly NAME
        local VERSION && VERSION=$(jq -r '.version' <<<"$YWT_PACKAGE") && readonly VERSION
        local DESCRITPTION=$(jq -r '.description' <<<"$YWT_PACKAGE")
        local URI && URI=$(jq -r '.homepage' <<<"$YWT_PACKAGE") && readonly URI
        colors hyperlink "$URI" "$(colors apply "yellow" "${NAME}@${VERSION} | ${DESCRITPTION} | $URI")" | logger info       
    }
    copyright() {
        echo "# YELLOW TEAM BUNDLE"
        echo "# $(jq -c .yellowteam <<<"$YWT_CONFIG")"
        echo "# This file is generated by yellowteam sdk builder. Do not edit this file"
        echo "# Build date: $(date -Iseconds)"
        echo "# Build ID: $(git rev-parse HEAD 2>/dev/null || echo "Unknown")"
        echo "# Build branch: $(git rev-parse --abbrev-ref HEAD 2>/dev/null || echo "Unknown")"
        echo "# Build tag: $(git describe --tags 2>/dev/null || echo "Unknown")"
        echo "# Build commit: $(git rev-parse --short HEAD 2>/dev/null || echo "Unknown")"
        echo "# Build author: $(git log -1 --pretty=format:'%an <%ae>' 2>/dev/null || echo "Unknown")"
        echo "# Build message: $(git log -1 --pretty=format:'%s' 2>/dev/null || echo "Unknown")"
    }
    __nnf "$@" || usage "$?" "ywt:info" "$@" && return 1
}
(
    export -f ywt:info
)
# </app-info.ywt.sh>
# <async.ywt.sh>
async() {
    YWT_LOG_CONTEXT="ASYNC"
    await() {
        spinner spin "$@"
    }
    __content:extract:json() {
        [[ -z "$1" ]] && echo -n "null" && return 0
        if [ -f "$1" ]; then
            sed -n '/{/,$p' "$1"
        else
            echo -n "$1" | sed -n '/{/,$p'                
        fi
        return 0
    }
    __content:sanitize() {
        local CONTENT="$1"
        [ -f "$CONTENT" ] && CONTENT=$(cat "$CONTENT")
        [[ -z "$CONTENT" ]] && echo -n "null" && return 0
        echo -n "$CONTENT" |
            sed -r 's/\x1B\[[0-9;]*[mK]//g' |
            sed -r 's/\\x1B]8;; //g' |
            sed -r 's/\\x1B]8;0=;//g'
        return 0
    }
    __content:normatize() {
        local FILE="$1"
        {
            echo -n "{"
            echo -n "\"file\": \"${FILE}\","
            echo -n "\"size\": $(stat -c%s "${FILE}"),"
            if [ ! -f "${FILE}" ]; then
                echo -n "\"error\": \"File not found\""
                echo -n "}"
                return 1
            fi
            if [ ! -s "${FILE}" ]; then
                echo -n "\"error\": \"Empty file\""
                echo -n "}"
                return 1
            fi            
            if jq -e . "${FILE}" >/dev/null 2>&1; then
                echo -n "\"format\": \"json1\","
                echo -n "\"content\": $(
                    jq -c '
                    map_values(
                        if type == "string" then
                            . | gsub("\n"; "\\n") | gsub("\""; "\\\"")
                        else
                            .
                        end
                    )
                    ' "${FILE}"
                )"
                echo -n "}"
                return 0
            fi
            local CONTENT=$(__content:extract:json "$FILE")
            if [[ -n "$CONTENT" ]] && jq -e . <<<"$CONTENT" >/dev/null 2>&1; then
                echo -n "\"format\": \"json2\","
                echo -n "\"content\": $(jq -c . <<<"$CONTENT" || echo -n "null")"
                echo -n "}"
                return 0
            fi
            local CONTENT=$(__content:sanitize "$FILE")
            if [[ -n "$CONTENT" ]] && jq -e . <<<"$CONTENT" >/dev/null 2>&1; then
                echo -n "\"format\": \"json3\","
                echo -n "\"content\": $(jq -c . <<<"$CONTENT" || echo -n "null")"
                echo -n "}"
                return 0
            fi
            CONTENT="${CONTENT//$'\n'/\\n}"
            CONTENT="${CONTENT//\"/\\\"}"
            echo -n "\"format\": \"text\","
            echo -n "\"content\": \"${CONTENT}\""
            echo -n "}"
        } | jq -c .        
        return 0        
    }
    declare -a PIDS=()
    declare -a RESULTS=()
    declare -a ERRORS=()
    declare -a COMMANDS=()
    declare -a START_TIMES=()
    local ASYNC_OUTPUT=$(mktemp -u -t "ywt-async-XXXXXX")
    for COMMAND in "$@"; do
        local CMD_OUTPUT=$(mktemp -u -t "ywt-async-XXXXXX" --suffix=".out")
        local CMD_ERROR=$(mktemp -u -t "ywt-async-XXXXXX" --suffix=".err")
        RESULTS+=("$CMD_OUTPUT")
        ERRORS+=("$CMD_ERROR")
        COMMANDS+=("$COMMAND")
        START_TIMES+=("$(date -u +%s.%N)")
        {
            bash -c "source $YWT_SDK_FILE $COMMAND" >"$CMD_OUTPUT" 2>"$CMD_ERROR"
        } &
        PIDS+=("$!")
    done
    echo "Waiting for ${#PIDS[@]} commands to finish" | logger info
    local TASKS_LENGTH=${#PIDS[@]}
    local TASKS_LEFT=${#PIDS[@]}
    local TASKS_DONE=0
    local TASKS_ERROR=0
    local TASKS_ID=1
    for IDX in "${!PIDS[@]}"; do
        local YPID="${PIDS[$IDX]}"
        local RESULT="${RESULTS[$IDX]}"
        local ERROR="${ERRORS[$IDX]}"
        local COMMAND="${COMMANDS[$IDX]}"
        local STARTED_AT="${START_TIMES[$IDX]}"
        local COMMAND_NAME=$(echo "$COMMAND" | awk '{print $1}')
        local MESSAGE="(${YELLOW}$YPID${NC}) ${BLUE}${COMMAND_NAME}${NC} ${TASKS_ID} of ${TASKS_LENGTH}, remaining ${TASKS_LEFT}, done ${TASKS_DONE}, errors ${TASKS_ERROR}"
        echo "Running $MESSAGE" | logger info
        await "$YPID" "Waiting $MESSAGE" # & wait "${YPID}"
        local STATUS=$?
        local EXIT_CODE="${STATUS}" #"${EXIT_CODES[$IDX]}"
        local FINISHED_AT=$(date -u +%s.%N)
        local ELAPSED_TIME=$(awk "BEGIN {printf \"%.2f\", $FINISHED_AT - $STARTED_AT}")
        {
            echo -n "{"
            echo -n "\"idx\": ${IDX},"
            echo -n "\"pid\": ${YPID},"
            echo -n "\"started_at\": ${STARTED_AT},"
            echo -n "\"finished_at\": ${FINISHED_AT},"
            echo -n "\"elapsed_time\": ${ELAPSED_TIME:-0},"
            echo -n "\"command\": \"${COMMAND//\"/\\\"}\","
            echo -n "\"exit_code\": ${EXIT_CODE},"
            echo -n "\"result\": $(__content:normatize "$RESULT" 2>&1),"
            echo -n "\"error\": $(__content:normatize "$ERROR" 2>&1)"            
            echo -n "}"
            echo
        } | jq -c . >>"$ASYNC_OUTPUT"
        TASKS_LEFT=$((TASKS_LEFT - 1))
        TASKS_ID=$((TASKS_ID + 1))
        TASKS_DONE=$((TASKS_DONE + 1))
        [ "$EXIT_CODE" -gt 0 ] && TASKS_ERROR=$((TASKS_ERROR + 1))
        echo "Done $MESSAGE" | logger success
        rm -f "$RESULT" "$ERROR"
    done
    echo "All commands executed successfully ${ASYNC_OUTPUT}" | logger success
    if jq -se . "$ASYNC_OUTPUT" >/dev/null 2>&1; then
        jq -sc . "$ASYNC_OUTPUT"
    else
        cat "$ASYNC_OUTPUT"
    fi
    rm -f "$ASYNC_OUTPUT"
    return 0
}
# </async.ywt.sh>
# <builder.ywt.sh>
builder() {
    YWT_LOG_CONTEXT="BUILDER"
    config() {
        local DEFAULT_EXPIRES_AT="${YWT_CONFIG_BUILDER_EXPIRES_AT:-"31/12/2999"}"
        local PATH_DIST=${2:-"${YWT_CONFIG_BUILDER_DIST:-"$(jq -r .path.dist <<<"$YWT_CONFIG")"}"} && readonly PATH_DIST
        local PATH_SRC=${3:-"${YWT_CONFIG_BUILDER_SRC:-"$(jq -r .path.src <<<"$YWT_CONFIG")"}"} && readonly PATH_SRC
        local PATH_SDK=$(jq -r .path.sdk <<<"$YWT_CONFIG") && SDK=$(realpath -- "$PATH_SDK") && readonly PATH_SDK
        local PATH_BIN=$(jq -r .path.bin <<<"$YWT_CONFIG") && readonly PATH_BIN
        {
            echo -n "{"
            echo -n "\"expires\": \"$DEFAULT_EXPIRES_AT\","
            echo -n "\"path/dist\": \"$PATH_DIST\","
            echo -n "\"path/src\": \"$PATH_SRC\","
            echo -n "\"path/sdk\": \"$PATH_SDK\","
            echo -n "\"path/bin\": \"$PATH_BIN\""
            echo -n "}"
        } | jq -c .
    }
    info() {
        {
            echo -n "{"
            echo -n "\"date\": \"$(date -Iseconds)\","
            echo -n "\"id\": \"$(git rev-parse HEAD 2>/dev/null || echo "Unknown")\","
            echo -n "\"branch\": \"$(git rev-parse --abbrev-ref HEAD 2>/dev/null || echo "Unknown")\","
            echo -n "\"tag\": \"$(git describe --tags 2>/dev/null || echo "Unknown")\","
            echo -n "\"commit\": \"$(git rev-parse --short HEAD 2>/dev/null || echo "Unknown")\","
            echo -n "\"author\": \"$(git log -1 --pretty=format:'%an <%ae>' 2>/dev/null || echo "Unknown")\","
            echo -n "\"message\": \"$(git log -1 --pretty=format:'%s' 2>/dev/null || echo "Unknown")\""
            echo -n "}"
        } | jq -c .
    }
    _prepare() {
        while read -r KEY VALUE; do
            [[ "$KEY" =~ ^path/ ]] && [[ ! -d "$VALUE" ]] && mkdir -p "${VALUE}" && echo "Created directory ${VALUE}" | logger verbose
        done < <(jq -r 'to_entries|map("\(.key) \(.value|tostring)")|.[]' <<<"$(config "$@")")
        echo "Directories created" | logger info
    }
    _cleanup() {
        local KEEP_SOURCE="${YWT_CONFIG_BUILDER_KEEP_SOURCE:-false}"
        [[ "$KEEP_SOURCE" == true ]] && echo "Keeping sources" | logger info && return 0
        local CONFIG=$(config "$@")
        local DIST=$(jq -r '.["path/dist"]' <<<"$CONFIG")
        rm -f "${DIST}/"*.sh >/dev/null
        rm -f "${DIST}/"*.c >/dev/null
        echo "Sources removed" | logger info
    }
    _bundle:validate() {
        local CONFIG=$(config "$@")
        local SRC_FILE=${1:?} && [ ! -f "$SRC_FILE" ] && echo "{ \"error\": \"Invalid source file\" }" && return 1
        local FILE_EXT="${SRC_FILE##*.}" && [[ "$FILE_EXT" != "sh" ]] && echo "{ \"error\": \"Invalid file extension\" }" && return 1
        if ! grep -q "^#!/usr/bin/env bash$" "$SRC_FILE"; then
            echo "{ \"error\": \"Invalid shebang\" }" && return 1
            return 1
        fi
        local FILENAME=$(basename -- "$SRC_FILE") && FILENAME="${FILENAME%.*}"
        local BUNDLE_NAME="${2:-"${FILENAME}.sh"}" && [ -z "$BUNDLE_NAME" ] && echo "{ \"error\": \"Invalid bundle name\" }" && return 1
        local FILE_BASEPATH=$(dirname -- "$SRC_FILE")
        local FILE_REALPATH=$(realpath -- "$FILE_BASEPATH")
        local FILE_RELATIVEPATH=$(realpath --relative-to="$SRC_FILE" "$FILE_BASEPATH")
        if [[ ! -d "${FILE_REALPATH}/lib" ]]; then
            echo "{ \"error\": \"${FILE_REALPATH}/lib is not a valid directory\" }" && return 1
        fi
        local SRC_PATH=$(jq -r '.["path/src"]' <<<"$CONFIG")
        local TARGET_FILE="${SRC_PATH}/${BUNDLE_NAME}" && [[ -f "$TARGET_FILE" ]] && rm -f "$TARGET_FILE"
        {
            echo -n "$CONFIG"
            echo -n "{"
            echo -n "\"success\": true,"
            echo -n "\"file\": \"$SRC_FILE\","
            echo -n "\"filename\": \"$FILENAME\","
            echo -n "\"extension\": \"$FILE_EXT\","
            echo -n "\"basepath\": \"$FILE_BASEPATH\","
            echo -n "\"realpath\": \"$FILE_REALPATH\","
            echo -n "\"relativepath\": \"$FILE_RELATIVEPATH\","
            echo -n "\"lib\": \"$FILE_REALPATH/lib\","
            echo -n "\"name\": \"$BUNDLE_NAME\","
            echo -n "\"output\": \"$TARGET_FILE\""
            echo -n "}"
        } | jq -sc '
            .[0] as $config | 
            .[1] as $validation |
            {
                config: $config,
                validation: $validation
            }
        '
        return 0
    }
    _bundle:inject() {
        local FILE="$1"
        [[ ! -f "$FILE" ]] && echo "{ \"error\": \"$FILE is not a valid file\" }" && return 0
        grep -v "^#" "$FILE" | grep -v "^[[:space:]]*#[^!]" | grep -v "^$" | grep -v "^#!/usr/bin/env bash$" | grep -v "^# shellcheck disable" | grep -v "^#"
    }
    _bundle:checksum:generate() {
        local TARGET=${1:?}
        local EXPIRES_AT="${2:-$CONFIG_EXPIRES_AT}"
        local FILENAME && FILENAME=$(basename -- "$TARGET") && FILENAME="${FILENAME%.*}"
        local IS_BINARY=false
        LC_ALL=C grep -a '[^[:print:][:space:]]' "$TARGET" >/dev/null && IS_BINARY=true
        echo "{"
        echo "  \"file\": \"$TARGET\","
        echo "  \"expires_at\": \"$EXPIRES_AT\","
        echo "  \"size\": \"$(du -h "$TARGET" | awk '{print $1}' 2>/dev/null)\","
        echo "  \"md5\": \"$(md5sum "$TARGET" | awk '{print $1}' 2>/dev/null)\","
        echo "  \"sha1\": \"$(sha1sum "$TARGET" | awk '{print $1}' 2>/dev/null)\","
        echo "  \"sha256\": \"$(sha256sum "$TARGET" | awk '{print $1}' 2>/dev/null)\","
        echo "  \"sha512\": \"$(sha512sum "$TARGET" | awk '{print $1}' 2>/dev/null)\"",
        echo "  \"created_at\": \"$(date -Iseconds)\"",
        echo "  \"binary\": $IS_BINARY"
        echo "}"
    }
    bundle() {
        local VALIDATION=$(_bundle:validate "$@")
        if ! jq -r '.validation.success' <<<"$VALIDATION" | grep -q true; then
            echo "$VALIDATION" | jq -c .
            return 1
        fi
        _prepare
        _cleanup
        local BUNDLE_FILE=$(jq -r '.validation.output' <<<"$VALIDATION")
        local BUNDLE_LIB_PATH=$(jq -r '.validation.lib' <<<"$VALIDATION")
        local BUNDLE_SRC_PATH=$(jq -r '.config["path/src"]' <<<"$VALIDATION")
        local BUNDLE_OUTPUT_TMP=$(mktemp -u -t "ywt-XXXX")
        echo "#!/bin/bash" >"$BUNDLE_FILE"
        {
            copyright
            while read -r FILE; do
                local FILENAME && FILENAME=$(basename -- "$FILE")
                local RELATIVE_PATH && RELATIVE_PATH=$(realpath --relative-to="$BUNDLE_SRC_PATH" "$FILE")
                local RELATIVE_PATH && RELATIVE_PATH=$(dirname -- "$RELATIVE_PATH")
                echo "# <$FILENAME>"
                _bundle:inject "$FILE"
                echo "# </$FILENAME>"
                {
                    echo -n "{"
                    echo -n "\"file\": \"$FILE\","
                    echo -n "\"path\": \"$RELATIVE_PATH\","
                    echo -n "\"content\": \"$(cat "$FILE" | base64 -w 0)\","
                    echo -n "\"checksum\": $(_bundle:checksum:generate "$FILE")"
                    echo -n "}"
                } >>"$BUNDLE_OUTPUT_TMP"
            done < <(find "$BUNDLE_LIB_PATH" -type f -name "*.ywt.sh" | sort)
            local SRC_FILE=$(jq -r '.validation.file' <<<"$VALIDATION")
            echo "# <$SRC_FILE>"
            _bundle:inject "$SRC_FILE"
            echo "# </$SRC_FILE>"
        } >>"$BUNDLE_FILE"
        echo "Bundle created" | logger info
        cat "$BUNDLE_FILE"
    }
    __nnf "$@" || usage "$?" "builder" "$@" && return 1
    return 0
}
builder:v1() {
    YWT_LOG_CONTEXT="BUILDER"
    local CONFIG_EXPIRES_AT="${YWT_CONFIG_BUILDER_EXPIRES_AT:-"31/12/2999"}"
    local DIST=${2:-"${YWT_CONFIG_BUILDER_DIST:-"$(jq -r .path.dist <<<"$YWT_CONFIG")"}"} && readonly DIST
    local SRC=${3:-"${YWT_CONFIG_BUILDER_SRC:-"$(jq -r .path.src <<<"$YWT_CONFIG")"}"} && readonly SRC
    local SDK=$(jq -r .path.sdk <<<"$YWT_CONFIG") && SDK=$(realpath -- "$SDK") && readonly SDK
    local BIN=$(jq -r .path.bin <<<"$YWT_CONFIG") && readonly BIN
    _prepare() {
        [[ ! -d "$DIST" ]] && mkdir -p "${DIST}"
        rm -fR "${DIST:?}"/*
        [[ ! -d "$BIN" ]] && mkdir -p "${BIN}"
        if ! command -v shc &>/dev/null; then
            colors apply "red" "$YWT_LOG_CONTEXT compiler is not installed, trying install" | logger warn
            apt-get install shc -y || return 1
        fi
        local SHC_INSTALLED && SHC_INSTALLED=$(command -v shc)
        [[ -z "$SHC_INSTALLED" ]] && colors apply "red" "$YWT_LOG_CONTEXT compiler is not installed" | logger error && return 1
        colors apply "green" "$YWT_LOG_CONTEXT Compiler is installed" | logger success
    }
    _cleanup() {
        local KEEP_SOURCE="${YWT_CONFIG_BUILDER_KEEP_SOURCE:-false}"
        [[ "$KEEP_SOURCE" == true ]] && echo "Keeping sources" | logger info && return 0
        rm -f "${DIST}/"*.sh | logger verbose
        rm -f "${DIST}/"*.c | logger verbose
        echo "Sources removed" | logger info
    }
    _stats() {
        local TARGET=${1:?}
        local EXPIRES_AT="${2:-$CONFIG_EXPIRES_AT}"
        local FILENAME && FILENAME=$(basename -- "$TARGET") && FILENAME="${FILENAME%.*}"
        local IS_BINARY=false
        LC_ALL=C grep -a '[^[:print:][:space:]]' "$TARGET" >/dev/null && IS_BINARY=true
        echo "{"
        echo "  \"file\": \"$TARGET\","
        echo "  \"expires_at\": \"$EXPIRES_AT\","
        echo "  \"size\": \"$(du -h "$TARGET" | awk '{print $1}' 2>/dev/null)\","
        echo "  \"md5\": \"$(md5sum "$TARGET" | awk '{print $1}' 2>/dev/null)\","
        echo "  \"sha1\": \"$(sha1sum "$TARGET" | awk '{print $1}' 2>/dev/null)\","
        echo "  \"sha256\": \"$(sha256sum "$TARGET" | awk '{print $1}' 2>/dev/null)\","
        echo "  \"sha512\": \"$(sha512sum "$TARGET" | awk '{print $1}' 2>/dev/null)\"",
        echo "  \"created_at\": \"$(date -Iseconds)\"",
        echo "  \"binary\": $IS_BINARY"
        echo "}"
    }
    __bundle() {
        local SRC_FILE=${1:?} && [ ! -f "$SRC_FILE" ] && echo "Invalid source file" | logger error && return 1
        local FILE_EXT="${SRC_FILE##*.}" && [[ "$FILE_EXT" != "sh" ]] && echo "Invalid file extension" | logger error && return 1
        local FILENAME=$(basename -- "$SRC_FILE") && FILENAME="${FILENAME%.*}"
        local FILE_BASEPATH=$(dirname -- "$SRC_FILE")
        local FILE_REALPATH=$(realpath -- "$FILE_BASEPATH")
        local FILE_RELATIVEPATH=$(realpath --relative-to="$SRC_FILE" "$FILE_BASEPATH")
        local BUNDLE_NAME="${2:-"${FILENAME}.sh"}" && [ -z "$BUNDLE_NAME" ] && echo "Invalid bundle name" | logger error && return 1
        local EXPIRES_AT="${3:-$CONFIG_EXPIRES_AT}" && [ -z "$EXPIRES_AT" ] && EXPIRES_AT="31/12/2999"
        local LIB=${FILE_REALPATH}/lib && [[ ! -d "$LIB" ]] && echo "${LIB} is not a valid directory" | logger error && return 0
        local TARGET_FILE="${SRC}/${BUNDLE_NAME}" && [[ -f "$TARGET_FILE" ]] && rm -f "$TARGET_FILE"
        _inject() {
            local FILE="$1"
            [[ ! -f "$FILE" ]] && echo "$FILE is not a valid file" | logger error && return 0
            grep -v "^#" "$FILE" | grep -v "^$" | grep -v "^#!/usr/bin/env bash"
        }
        {
            echo "#!/bin/bash"
            echo "# shellcheck disable=SC2044,SC2155,SC2317"
            copyright
            while read -r FILE; do
                local FILENAME && FILENAME=$(basename -- "$FILE")
                local RELATIVE_PATH && RELATIVE_PATH=$(realpath --relative-to="$SRC" "$FILE")
                local RELATIVE_PATH && RELATIVE_PATH=$(dirname -- "$RELATIVE_PATH")
                echo -e "# $(_stats "$FILE" "$EXPIRES_AT" | jq -c .)\n"
                _inject "$FILE"
                echo -e "\n# end of $FILENAME\n"
            done < <(find "$LIB" -type f -name "*.ywt.sh" | sort)
            echo -e "# $(_stats "$SRC_FILE" "$EXPIRES_AT" | jq -c .)\n"
            _inject "$SRC_FILE"
            echo -e "\n# end of $SRC_FILE\n"
        } >>"$TARGET_FILE"
        _stats "$TARGET_FILE" "$EXPIRES_AT" | jq -Cc . | logger info
    }
    __build_file() {
        local FILE=$1 && readonly FILE && [[ ! -f "$FILE" ]] && echo "$FILE is not a valid file" | logger error && return 0
        local FILE_DIR=$(dirname -- "$FILE") && readonly FILE_DIR
        local EXPIRES_AT="${2:-$CONFIG_EXPIRES_AT}" && [ -z "$EXPIRES_AT" ] && EXPIRES_AT="31/12/2999"
        local FILENAME && FILENAME=$(basename -- "$FILE") && FILENAME="${FILENAME%.*}"
        colors apply "blue" "Building file ${FILE} valid until ${EXPIRES_AT}" | logger info
        shc -r -f "${FILE}" -e "${EXPIRES_AT}" -m "File expired since ${EXPIRES_AT}, please contact us to renew. $(jq -Cc .yellowteam <<<"$YWT_CONFIG")"
        [ -f "$DIST/$FILENAME.sh" ] && rm -f "$DIST/$FILENAME.sh"
        [ -f "$DIST/$FILENAME.c" ] && rm -f "$DIST/$FILENAME.c"
        [ -f "${BIN}/$FILENAME" ] && rm -f "${BIN}/$FILENAME"
        cp -f "$FILE" "$DIST/$FILENAME.sh"      # /dist/file.sh
        mv -f "${FILE}.x.c" "$DIST/$FILENAME.c" # /dist/file.c
        mv -f "${FILE}.x" "${BIN}/$FILENAME"    # /bin/file
        colors apply "green" "Build done. run ${BIN}/${FILENAME}" | logger success
        jq -Cn \
            --argjson sh "$(_stats "$DIST/$FILENAME.sh" "$EXPIRES_AT")" \
            --argjson c "$(_stats "$DIST/$FILENAME.c" "$EXPIRES_AT")" \
            --argjson bin "$(_stats "${BIN}/$FILENAME" "$EXPIRES_AT")" \
            '{sh: $sh, c: $c, bin: $bin}' | logger info
    }
    _build_sdk() {
        _prepare
        __bundle "$SDK/sdk.sh" "ywt.sh" "31/12/2999"
        __build_file "$SRC/ywt.sh" "31/12/2999"
        return 0
    }
    inspect() {
        jq -r '.path' <<<"$YWT_CONFIG"
    }
    __nnf "$@" || usage "$?" "builder" "$@" && return 1
    return 0
}
# </builder.ywt.sh>
# <cache.ywt.sh>
cache() {
    [ -z "$YWT_PATH_CACHE" ] && YWT_PATH_CACHE="$(jq -r '.cache' <<<"$YWT_PATHS")"
    [ ! -d "$YWT_PATH_CACHE" ] && mkdir -p "$YWT_PATH_CACHE"
    [ ! -r "$YWT_PATH_CACHE" ] || [ ! -w "$YWT_PATH_CACHE" ] || [ ! -x "$YWT_PATH_CACHE" ] && {
        __log error "cache: cannot read, write, or execute $YWT_PATH"
    }
    __key() {
        local KEY="${1// /_}" && KEY="${KEY//[^a-zA-Z0-9_]/}"
        local TMP_FILE="$(mktemp -u -t "ywt.cache.XXXXXXXXXX" --tmpdir="$YWT_PATH_CACHE")"
        local KEY="${KEY}.$(basename "$TMP_FILE")"
        echo "$KEY"
    }
    __get() {
        local KEY="$(__key "$1")"
        local FILE="$YWT_PATH_CACHE/$KEY"
        [ -f "$FILE" ] && cat "$FILE"
    }
    __set() {
        local KEY="$(__key "$1")" && shift
        local FILE="$YWT_PATH_CACHE/$KEY"
        local CONTENT="$1" && [ -z "$CONTENT" ] && CONTENT="$(cat)"
        echo "$CONTENT" >"$FILE"
    }
    __delete() {
        local KEY="$(__key "$1")"
        local FILE="$YWT_PATH_CACHE/$KEY"
        [ -f "$FILE" ] && rm -f "$FILE"
    }
    __clear() {
        rm -rf "$YWT_PATH_CACHE" && mkdir -p "$YWT_PATH_CACHE"
    }    
    case "$1" in
    get) __get "$2" ;;
    set) __set "$2" "$3" ;;
    delete) __delete "$2" ;;
    clear) __clear ;;
    *) __nnf "$@" || usage "$?" "tests" "$@" && return 1 ;;
    esac
}
(
    export -f cache
)
# </cache.ywt.sh>
# <capabilities.ywt.sh>
capabilities() {
    __capability() {
        local CAPABILITY="$1" && shift
        case "$CAPABILITY" in
        inter)
            local VALUE="false"
            [ -t 0 ] && local VALUE="true"
            ;;
        net-admin)
            local VALUE="false"
            [ "$(id -u)" -eq 0 ] && local VALUE="true"
            ;;
        sudo)
            local VALUE="false"
            [ -x "$(command -v sudo)" ] && local VALUE="true"
            ;;
        mount)
            local VALUE="false"
            [ -d /mnt ] && local VALUE="true"
            ;;
        docker)
            local VALUE="false"
            [ -x "$(command -v docker)" ] && local VALUE="true"
            ;;
        sys-admin)
            local VALUE="false"
            [ "$(id -u)" -eq 0 ] && local VALUE="true"
            ;;
        *)
            local VALUE="\"unexpected\""
            ;;
        esac
        echo -n "\"$CAPABILITY\": $VALUE"
    }
    {
        [ "$#" -eq 0 ] && set -- "sys-admin" "docker" "mount" "sudo" "net-admin" "inter"
        echo -n "{"
        echo -n "\"capabilities\": {"
        while [ "$#" -gt 0 ]; do
            __capability "$1"
            shift
            [ "$#" -gt 0 ] && echo -n ","
        done
        echo -n "}"
        echo -n "}"
    } | jq .
    return 0
}
# </capabilities.ywt.sh>
# <colors.ywt.sh>
colors() {
    YWT_LOG_CONTEXT="colors"
    rainbow() {
        local TEXT=${1:-$YWT_CMD_FILE} && shift
        local COLORS=("${@}") && [ ${#COLORS[@]} -eq 0 ] && COLORS=("${YWT_COLORS[@]}")
        local COLOR_COUNT=${#COLORS[@]}
        local LENGTH=${#TEXT}
        local INDEX=0
        for ((i = 0; i < LENGTH; i++)); do
            local CHAR=${TEXT:$i:1}
            local COLOR=${COLORS[$INDEX]}
            local COLOR_CODE=$(colorize "$COLOR" "$CHAR")
            echo -n "$COLOR_CODE"
            INDEX=$((INDEX + 1))
            [[ $INDEX -ge $COLOR_COUNT ]] && INDEX=0
        done
        echo
    }
    apply() {
        local VAR=${1:-"NC"} && VAR=${VAR^^}
        local VARS=("${YWT_COLORS[@]}" "${YWT_STYLE[@]}")
        local IS_VALID=false
        for ITEM in "${VARS[@]}"; do
            [[ "${ITEM^^}" == "${VAR}" ]] && IS_VALID=true && break
        done
        [[ "$IS_VALID" == false ]] && VAR="NC"
        local KIND=fg
        [[ $VAR =~ bg$ ]] && KIND="bg"
        [[ $VAR =~ ^(bold|dim|italic|underline|blink|inverse|hidden)$ ]] && KIND=style
        VAR=${VAR//-/_}
        local COLOR=${VAR%%-*}
        [[ $KIND == "bg" || $KIND == "bg" ]] && COLOR=$((COLOR + 10))
        local TEXT=${2} # && while read -r LINE; do echo -e "$LINE"; done <<<"$TEXT"
        echo -e "\e[${!VAR}${TEXT}\e[0m${NC}"
        return 0        
    }
    hyperlink() {
        local OSC=$'\e]'
        local BEL=$'\a'
        local SEP=';'
        local PARAM_SEP=':'
        local EQ='='        
        local URI=$1
        local TEXT=$2
        local PARAMS=$3
        local PARAM_STR=""
        for PARAM in "${!PARAMS[@]}"; do
            PARAM_STR+="${PARAM}${EQ}${PARAMS[$param]}${PARAM_SEP}"
        done
        PARAM_STR=${PARAM_STR%"$PARAM_SEP"}
        printf "%s8%s%s%s%s%s%s%s8%s%s%s" "$OSC" "$SEP" "$PARAM_STR" "$SEP" "$URI" "$BEL" "$TEXT" "$OSC" "$SEP" "$SEP" "$BEL"
        echo -e "${NC}${NSTL}${NBG}"
    }
    __nnf "$@" || usage "colors" "$?" "$@" && return 1
}
(
    export -f colors
)
export NO_COLOR=${NO_COLOR:-false} && readonly NO_COLOR
export YWT_COLORS=(
    black black-bg bright-black dark-gray dark-gray-bg red red-bg bright-red green green-bg bright-green yellow yellow-bg bright-yellow blue blue-bg bright-blue purple purple-bg bright-purple cyan cyan-bg bright-cyan gray gray-bg bright-gray white white-bg bright-white
) && readonly YWT_COLORS
export BLACK=$'\033[0;30m' && [ "$NO_COLOR" == true ] && BLACK="" && readonly BLACK BLACK
export BLACK_BG=$'\033[40m' && [ "$NO_COLOR" == true ] && BLACK_BG="" && readonly BLACK_BG
export BRIGHT_BLACK=$'\033[1;30m' && [ "$NO_COLOR" == true ] && BRIGHT_BLACK="" && readonly BRIGHT_BLACK
export DARK_GRAY=$'\033[1;30m' && [ "$NO_COLOR" == true ] && DARK_GRAY="" && readonly DARK_GRAY
export DARK_GRAY_BG=$'\033[100m' && [ "$NO_COLOR" == true ] && DARK_GRAY_BG="" && readonly DARK_GRAY_BG
export RED=$'\033[0;31m' && [ "$NO_COLOR" == true ] && RED="" && readonly RED
export RED_BG=$'\033[41m' && [ "$NO_COLOR" == true ] && RED_BG="" && readonly RED_BG
export BRIGHT_RED=$'\033[1;31m' && [ "$NO_COLOR" == true ] && BRIGHT_RED="" && readonly BRIGHT_RED
export GREEN=$'\033[0;32m' && [ "$NO_COLOR" == true ] && GREEN="" && readonly GREEN
export GREEN_BG=$'\033[42m' && [ "$NO_COLOR" == true ] && GREEN_BG="" && readonly GREEN_BG
export BRIGHT_GREEN=$'\033[1;32m' && [ "$NO_COLOR" == true ] && BRIGHT_GREEN="" && readonly BRIGHT_GREEN
export YELLOW=$'\033[0;33m' && [ "$NO_COLOR" == true ] && YELLOW="" && readonly YELLOW
export YELLOW_BG=$'\033[43m' && [ "$NO_COLOR" == true ] && YELLOW_BG="" && readonly YELLOW_BG
export BRIGHT_YELLOW=$'\033[1;33m' && [ "$NO_COLOR" == true ] && BRIGHT_YELLOW="" && readonly BRIGHT_YELLOW
export BLUE=$'\033[0;34m' && [ "$NO_COLOR" == true ] && BLUE="" && readonly BLUE
export BLUE_BG=$'\033[44m' && [ "$NO_COLOR" == true ] && BLUE_BG="" && readonly BLUE_BG
export BRIGHT_BLUE=$'\033[1;34m' &&[ "$NO_COLOR" == true ] && BRIGHT_BLUE="" && readonly BRIGHT_BLUE
export PURPLE=$'\033[0;35m' && [ "$NO_COLOR" == true ] && PURPLE="" && readonly PURPLE
export PURPLE_BG=$'\033[45m' && [ "$NO_COLOR" == true ] && PURPLE_BG="" && readonly PURPLE_BG
export BRIGHT_PURPLE=$'\033[1;35m' && [ "$NO_COLOR" == true ] && BRIGHT_PURPLE="" && readonly BRIGHT_PURPLE
export CYAN=$'\033[0;36m' && [ "$NO_COLOR" == true ] && CYAN="" && readonly CYAN
export CYAN_BG=$'\033[46m' && [ "$NO_COLOR" == true ] && CYAN_BG="" && readonly CYAN_BG
export BRIGHT_CYAN=$'\033[1;36m' && [ "$NO_COLOR" == true ] && BRIGHT_CYAN="" && readonly BRIGHT_CYAN
export GRAY=$'\033[0;37m' && [ "$NO_COLOR" == true ] && GRAY="" && readonly GRAY
export GRAY_BG=$'\033[47m' && [ "$NO_COLOR" == true ] && GRAY_BG="" && readonly GRAY_BG
export BRIGHT_GRAY=$'\033[1;37m' && [ "$NO_COLOR" == true ] && BRIGHT_GRAY="" && readonly BRIGHT_GRAY
export WHITE=$'\033[0;37m' && [ "$NO_COLOR" == true ] && WHITE="" && readonly WHITE
export WHITE_BG=$'\033[107m' && [ "$NO_COLOR" == true ] && WHITE_BG="" && readonly WHITE_BG
export BRIGHT_WHITE=$'\033[1;37m' && [ "$NO_COLOR" == true ] && BRIGHT_WHITE="" && readonly BRIGHT_WHITE
export NC=$'\033[0m' && [ "$NO_COLOR" == true ] && NC="" && readonly NC
export NBG=$'\033[49m' && [ "$NO_COLOR" == true ] && NBG="" && readonly NBG
# </colors.ywt.sh>
# <config.ywt.sh>
config() {
    user(){
        local USER=$(whoami)
        local USER_ID=$(id -u)
        local GROUP_ID=$(id -g)
        local GROUP=$(id -g -n)
        echo "{
            \"user\": \"$USER\",
            \"user_id\": \"$USER_ID\",
            \"group\": \"$GROUP\",
            \"group_id\": \"$GROUP_ID\"
        }"
    }
    __nnf "$@" || usage "config" "$?" "$@" && return 1
    return 0
}
(
    export -f config
)
# </config.ywt.sh>
# <dates.ywt.sh>
dates() {
    add() {
        local ARGS=()
        while [[ $# -gt 0 ]]; do
            case "$1" in
            -d | --datetime) local DATETIME=$(date -Iseconds -d "$2") && shift 2 ;;
            -y | --years) local YEARS="$2" && shift 2 ;;
            -m | --months) local MONTHS="$2" && shift 2 ;;
            -D | --days) local DAYS="$2" && shift 2 ;;
            -h | --hours) local HOURS="$2" && shift 2 ;;
            -M | --minutes) local MINUTES="$2" && shift 2 ;;
            -s | --seconds) local SECONDS="$2" && shift 2 ;;
            *) ARGS+=("$1") && shift ;;
            esac
        done
        [ -z "$DATETIME" ] && DATETIME=${ARGS[0]:-"$(date -Iseconds -d "$(date +'%F %T')")"}
        [ -z "$YEARS" ] && YEARS=${ARGS[1]:-0}
        [ -z "$MONTHS" ] && MONTHS=${ARGS[2]:-0}
        [ -z "$DAYS" ] && DAYS=${ARGS[3]:-0}
        [ -z "$HOURS" ] && HOURS=${ARGS[4]:-0}
        [ -z "$MINUTES" ] && MINUTES=${ARGS[5]:-0}
        [ -z "$SECONDS" ] && SECONDS=${ARGS[6]:-0}
        local DATE=$(date -Iseconds -d "$DATETIME $YEARS years $MONTHS months $DAYS days $HOURS hours $MINUTES minutes $SECONDS seconds")
        echo "$DATE"
        unset ARGS DATETIME YEARS MONTHS DAYS HOURS MINUTES SECONDS DATE
        return "$?"
    }
    parse() {
        local DATE="${1:-$(date +'%F %T')}"
        {
            echo -n "{"
            echo -n "\"timezone\":\"$(date -d "$DATE" +%Z)\","
            echo -n "\"date\":\"$DATE\","
            echo -n "\"utc\":\"$(date -u -d "$DATE" +%F\ %T)\","
            echo -n "\"year\":\"$(date -d "$DATE" +%Y)\","
            echo -n "\"month\":\"$(date -d "$DATE" +%m)\","
            echo -n "\"day\":\"$(date -d "$DATE" +%d)\","
            echo -n "\"hour\":\"$(date -d "$DATE" +%H)\","
            echo -n "\"minute\":\"$(date -d "$DATE" +%M)\","
            echo -n "\"second\":\"$(date -d "$DATE" +%S)\""
            echo -n "}"
        } | jq .
        unset DATE
        return 0
    }
    formats() {
        local DATETIME=${1:-"$(date +'%F %T')"}
        {
            echo -n "{"
            echo -n "\"date\":\"$DATETIME\","
            echo -n "\"timestamp\":\"$(date -d "$DATETIME" +%s)\","
            echo -n "\"iso\":\"$(date -d "$DATETIME" --iso-8601=seconds)\","
            echo -n "\"rfc3339\":\"$(date -d "$DATETIME" --rfc-3339=seconds)\""
            echo -n "}"
        } | jq .
        unset DATETIME
        return 0
    }
    now() {
        timestamp() {
            local timezone="${1:-UTC}"
            if [ "$timezone" == "UTC" ]; then
                date -u +%s
            else
                TZ=$timezone date -d "$(date -u +'%Y-%m-%d %H:%M:%S')" '+%s' # date +%s
            fi
        }
        iso() {
            local timezone="${1:-UTC}"
            if [ "$timezone" == "UTC" ]; then
                local utc_seconds=$(date -u +%s)
                local utc_date=$(date -u -d @"$utc_seconds" +%Y-%m-%dT%H:%M:%S.%3NZ)
                echo "$utc_date"
            else
                TZ=$timezone date +'%Y-%m-%dT%H:%M:%S.%3NZ' # date -u +"%Y-%m-%dT%H:%M:%S.%3NZ"
            fi
        }
        __nnf "$@" || usage "dates" "$?" "$@" && return 1
    }
    diff() {
        days() {
            start=$(date -d "$1" +%s)
            end=$(date -d "$2" +%s)
            days_diff=$(((end - start) / 86400))
            echo "$days_diff"
        }
        __nnf "$@" || usage "dates" "$?" "$@" && return 1
    }
    __nnf "$@" || usage "dates" "$?" "$@" && return 1
}
(
    export -f dates
)
# </dates.ywt.sh>
# <debugger.ywt.sh>
debugger() {
    YWT_LOG_CONTEXT="debugger"
    watch() {
        __require tail wait kill        
        (tail -f "$FIFO") && wait && kill "$!"
    }
    _verbose() {
        echo "$1" 1>&2
    }
    if __nnf "$@"; then return 0; fi
    usage "debugger" "$?" "debugger" "$@" && return 1
}
# </debugger.ywt.sh>
# <domains.ywt.sh>
domains() {
    hsts(){
        local DOMAIN="${1}"
        local HSTS_HEADER=$(curl -s -I "https://${DOMAIN}" | grep -i "Strict-Transport-Security")
        if [ -z "${HSTS_HEADER}" ]; then
            echo "HSTS not enabled for ${DOMAIN}" | logger warn
            return 1
        else
            echo "HSTS enabled for ${DOMAIN}" | logger success
            return 0
        fi
    }
    __nnf "$@" || usage "tests" "$?" "$@" && return 1
}
(
    export -f domains
)
# </domains.ywt.sh>
# <dotenv.ywt.sh>
dotenv() {
    YWT_LOG_CONTEXT="DOTENV"
    load() {
        local FILE=${1}
        [ ! -f "$FILE" ] && logger error "File $FILE not found" && return 1
        local CONTENT=$(cat "$FILE") && CONTENT=$(envsubst "$FILE")
        [ -z "$CONTENT" ] && logger info "File $FILE is empty" && return 0
        CONTENT="$CONTENT"$'\n'
        local NS=${YWT_PROJECT_NAMESPACE:-YWT} && [ -n "$2" ] && NS="${NS}_${2^^}"
        local INJECT=${3:-false}
        local JSON="{"
        while IFS= read -r LINE || [ -n "$LINE" ]; do
            IFS='=' read -r KEY VALUE <<<"$LINE"
            [[ -z "$LINE" || -z "$KEY" || "$KEY" =~ ^#.*$ || "$VAR" =~ ^#.*$ ]] && continue
            [[ $INJECT == true ]] && export "${NS^^}_${KEY}"="$VALUE" # || echo "${NS^^}_${KEY}=$VALUE" >>"$YWT_PATH_TMP/.env" # eval "export ${NS^^}_${VAR}"
            JSON="$JSON\"${NS^^}_${KEY}\":\"${VALUE}\","
            local MASKED=$(echo "$VALUE" | sed -E 's/./*/g')
            __debug "Dotenv: ${NS^^}_${KEY}=$MASKED - ${FILE}"
        done <<<"$CONTENT"
        JSON="${JSON%,}"
        JSON="$JSON}"
        echo "$JSON"
        return 0
    }
    __nnf "$@" || usage "dotenv" "$?" "$@" && return 1
}
(
    export -f dotenv
)
# </dotenv.ywt.sh>
# <drawer.ywt.sh>
drawer() {
    box(){
        local TITLE="$1" && shift
        local CONTENT="$1" && shift
        echo -n "┌"
        for ((i=0; i<${#TITLE}+2; i++)); do
            echo -n "─"
        done
        echo "┐"
        echo "│ $TITLE │"
        echo -n "└"
        for ((i=0; i<${#TITLE}+2; i++)); do
            echo -n "─"
        done
        echo "┘"
        echo -n "$CONTENT"
        echo -n "└"
        for ((i=0; i<${#TITLE}+2; i++)); do
            echo -n "─"
        done
        echo "┘"
    }
    __nnf "$@" && return "$?"
}
# </drawer.ywt.sh>
# <envsubst.ywt.sh>
if ! command -v envsubst >/dev/null 2>&1; then
    envsubst() {
        export YWT_LOG_CONTEXT="ENVSUBST"
        local FILE_PATH="$1"
        [ -z "$FILE_PATH" ] && __log error "File path not defined" && return 1
        [ ! -f "$FILE_PATH" ] && __log error "File not found" && return 1
        while IFS= read -r LINE || [ -n "$LINE" ]; do
            while [[ "$LINE" =~ (\$\{([a-zA-Z_][a-zA-Z_0-9]*)\}) ]]; do
                local FULL_MATCH=${BASH_REMATCH[1]}
                local VAR_NAME=${BASH_REMATCH[2]}
                local VAR_VALUE=${!VAR_NAME:-}
                LINE=${LINE//$FULL_MATCH/$VAR_VALUE}
            done
            echo "$LINE"
        done <"$FILE_PATH"
        return 0
    }
    (
        export -f envsubst
    )
fi
# </envsubst.ywt.sh>
# <errors.ywt.sh>
errors() {
    code() {
        local code=${1:?} && [ -z "$code" ] && echo "Invalid error code" | logger error && return 1
        local message=${2:?} && [ -z "$message" ] && echo "Invalid error message" | logger error && return 1
        echo "{
            \"code\": \"$code\",
            \"message\": \"$message\"
        }"
    }
    _throw() {
        local ERROR_CODE=${1:$?} && shift
        local MESSAGE=${1:-"An error occurred"} && shift
        _fail "$ERROR_CODE" "$MESSAGE"
    }
    __nnf "$@" || usage "errors" "$?" "styles" "$@" && return 1
    return 0
}
(
    export -f errors
)
# </errors.ywt.sh>
# <extract.ywt.sh>
extract() {
    json() {
        local TEXT="$1"
        [ -z "$TEXT" ] && while read -r line; do TEXT+="$line"; done
        echo "$TEXT" | sed -n '/{/,$p' | jq -sR 'fromjson? | select(.)'
    }
    __nnf "$@" || usage "$?" "extract" "$@" && return 1
}
(
    export -f extract
)
# </extract.ywt.sh>
# <fetch.ywt.sh>
fetch() {
    YWT_LOG_CONTEXT="fetch"
    __metrics() {
        [ -z "$HTTP_METRIC" ] && local HTTP_METRIC=(
            "url_effective" "http_code" "response_code" "http_connect" "time_namelookup" "time_connect" "time_appconnect" "time_pretransfer" "time_starttransfer" "size_header" "size_request" "size_download" "size_upload" "speed_download" "speed_upload" "content_type" "num_connects" "time_redirect" "num_redirects" "ssl_verify_result" "proxy_ssl_verify_result" "filename_effective" "remote_ip" "remote_port" "local_ip" "local_port" "http_version" "scheme"
        ) && readonly HTTP_METRIC
        {
            echo -n "{"
            for METRIC in "${HTTP_METRIC[@]}"; do
                echo -n "\"${METRIC}\":\"%{${METRIC}}\","
            done
            echo -n "\"metrics\":\"%{time_total}\""
            echo -n "}"
        } | jq -c .
    }
    __check_header() {
        local HEADERS="${1:-"{}"}" && shift
        for VALUE in "${@}"; do
            local HEADER_VALUE=$(jq -r ".[\"${VALUE}\"]" <<<"${HEADERS}")
            if [ -n "${HEADER_VALUE}" ]; then
                echo -n "${HEADER_VALUE}"
                return 0
            fi
        done
        echo -n "0"
        return 1
    }
    __extract_rate_limit() {
        local HEADERS="${1:-"{}"}"
        local RATE_LIMIT="$(__check_header "$HEADERS" "x-ratelimit-limit" "x-rate-limit-limit")"
        local RATE_REMAIN="$(__check_header "$HEADERS" "x-ratelimit-remaining" "x-rate-limit-remaining")"
        local RATE_RESET="$(__check_header "$HEADERS" "x-ratelimit-reset" "x-rate-limit-reset")" && RATE_RESET=$((RATE_RESET < 0 ? 0 : RATE_RESET))
        local RATE_RESET_AT=$(date -u -d "@${RATE_RESET}" "+%Y-%m-%d %H:%M:%S")
        local RATE_WINDOW="$(($(date +%s) - RATE_RESET))" && RATE_WINDOW=$((RATE_WINDOW < 0 ? 0 : RATE_WINDOW))
        if [ -z "${RATE_WINDOW}" ] || [ "${RATE_WINDOW}" == "null" ]; then
            RATE_WINDOW=0
        fi
        RATE_WINDOW=$(date -u -d "@${RATE_WINDOW}" "+%H:%M:%S")
        local RATE_TIMESTAMP=$(date -u -d "@$(date +%s)" "+%Y-%m-%d %H:%M:%S")
        echo -n "{\"max\":${RATE_LIMIT},\"remain\":${RATE_REMAIN},\"reset\":${RATE_RESET}, \"reset_at\":\"${RATE_RESET_AT}\", \"window\":\"${RATE_WINDOW}\", \"timestamp\":\"${RATE_TIMESTAMP}\"}"
    }
    __cookies() {
        local HEADERS="${1:-"{}"}"
        jq -r '
            if .headers == null or .headers == {} then
                empty
            else
                .headers | to_entries[]
            end
            | select(.key | startswith("Set-Cookie"))
            | .value
            | split(";") | map(split("=")) | .[0] as $key | .[1] as $value | {($key): $value}
        ' <<<"${HEADERS}"
    }
    __scurl() {
        local URL="${1}"
        local METHOD="${2:-GET}"
        local DATA="${3:-}"
        local HEADERS="${4:-}"
        local TIMEOUT="${5:-3}"
        local RESPONSE=$(curl -s -X "${METHOD}" -H "${HEADERS}" -d "${DATA}" -m "${TIMEOUT}" "${URL}")
        [ -z "${RESPONSE}" ] && echo "No response" | logger error && return 1
        echo "${RESPONSE}" && return 0
    }
    __options() {
        local OPTIONS=$({
            [ -z "$1" ] && echo "{
                \"method\":\"GET\",
                \"headers\":{},
                \"data\":{},
                \"timeout\":3
            }" && return 0
            echo -n "$1" && return 0
        } | jq -c .)
        __is nil "$(jq -r '.method' <<<"${OPTIONS}")" && OPTIONS=$(jq -c ".method=\"GET\"" <<<"${OPTIONS}")
        __is nil "$(jq -r '.headers' <<<"${OPTIONS}")" && OPTIONS=$(jq -c ".headers={}" <<<"${OPTIONS}")
        __is nil "$(jq -r '.data' <<<"${OPTIONS}")" && OPTIONS=$(jq -c ".data={}" <<<"${OPTIONS}")
        __is nil "$(jq -r '.timeout' <<<"${OPTIONS}")" && OPTIONS=$(jq -c ".timeout=3" <<<"${OPTIONS}")
        echo "${OPTIONS}" && return 0
    }
    __send() {
        local URL="${1}" && shift && ! __is json "${URL}" && URL="$(parse url "${URL}")"
        __is nil "$(jq -r '.uri' <<<"${URL}")" && echo "No URL ${URL:-empty}" | logger error && return 1
        local OPTIONS=$(__options "$1") && shift && OPTIONS=$(jq . <<<"${OPTIONS}")
        local AUTZ="$(jq -r '.credentials' <<<"${URL}")"
        if [ -n "${AUTZ}" ]; then
            local AUTHORIZATION=$(jq -c ".headers.Authorization=\"Basic $(echo -n "${AUTZ}" | base64 -w 0)\"" <<<"${OPTIONS}")
            OPTIONS=$(jq -c ".=${AUTHORIZATION}" <<<"${OPTIONS}")
        fi
        local REQUEST_ID=$(echo -n "$(jq -r '.uri' <<<"${URL}")" | md5sum | cut -d' ' -f1)
        local RESPONSE_FILE="/tmp/ywt.request.${REQUEST_ID}.json" && export RESPONSE_FILE
        local CURL_ARGS=(
            "--include"
            "--silent"
            "--show-error"
            "--location"
            "--user-agent" "'ywt/0.0.0-alpha.0'"
            "--request" "$(jq -r '.method' <<<"${OPTIONS}")"
            "--connect-timeout" "$(jq -r '.timeout' <<<"${OPTIONS}")"
            "--retry" "3"
            "--retry-delay" "3"
            "--retry-max-time" "30"
            "--write-out" "'$(__metrics)'"
            "--url" "$(jq -r '.uri' <<<"${URL}")"
        )
        while IFS= read -r HEADER; do
            CURL_ARGS+=("--header" "'${HEADER}'")
        done < <(jq -r '.headers | to_entries[] | "\(.key): \(.value)"' <<<"${OPTIONS}")
        logger info "🔼 $(jq -r '.method' <<<"${OPTIONS}") $(jq -r '.uri' <<<"${URL}")"
        local RESPONSE=$(curl "${CURL_ARGS[@]}" | response)
        local LOG_MESSAGE=$({
            echo -n "🔽"
            echo -n " $(jq -r '.method' <<<"${OPTIONS}")"
            echo -n " $(jq -r '.stats.url_effective' <<<"${RESPONSE}")"
            echo -n " $(jq -r '.status.status_code' <<<"${RESPONSE}")"
            echo -n " $(jq -r '.stats.metrics' <<<"${RESPONSE}")"
            echo -n " ${YELLOW}$RESPONSE_FILE${NC}"
            echo -n " $REQUEST_ID"
        })
        if [ "$(jq -r '.ok' <<<"${RESPONSE}")" = "false" ]; then
            logger error "${LOG_MESSAGE}"
            local STATUS=1
        else
            logger success "${LOG_MESSAGE}"
            local STATUS=0
        fi
        jq -c <<<"${RESPONSE}" >"${RESPONSE_FILE}"
        jq . <"${RESPONSE_FILE}"
        return "${STATUS}"
    }
    response() {
        local RESPONSE="${1}"
        if [ -p /dev/stdin ]; then
            RESPONSE=$(cat -)
            while IFS= read -r LINE; do
                if [ -z "$LINE" ]; then continue; fi
                RESPONSE+="\n$LINE"
            done
        fi
        RESPONSE=$(echo -e "${RESPONSE}" | sed -e 's/^[[:space:]]*// ' -e 's/[[:space:]]*$//' | tr -d '\r' | sed '1{/^$/d}' | sed "s,\x1B\[[0-9;]*[a-zA-Z],,g")
        if [[ "${RESPONSE}" =~ ^curl: ]]; then
            echo -n "{\"protocol\":\"\",\"status_code\":0,\"status_message\":\"${RESPONSE}\"}"
            return 1
        fi
        local IS_HEADER=true
        local IS_FIRST=true
        RESPONSE="$({
            BODY=""
            STATS=""
            while IFS= read -r LINE || [ -n "$LINE" ]; do
                if [ "$IS_FIRST" = true ]; then
                    local PROTOCOL="$(echo -n "$LINE" | cut -d' ' -f1)"
                    local STATUS_CODE="$(echo -n "$LINE" | cut -d' ' -f2)"
                    local STATUS_MESSAGE="$(echo -n "$LINE" | cut -d' ' -f3-)"
                    echo -ne "{\"protocol\":\"${PROTOCOL}\",\"status_code\":\"${STATUS_CODE}\",\"status_message\":\"${STATUS_MESSAGE}\"}{"
                    IS_FIRST=false
                elif [ "$IS_HEADER" = true ]; then
                    if [[ -n "${LINE}" ]]; then
                        local KEY="$(echo -n "$LINE" | cut -d':' -f1)"
                        local VALUE="$(echo -n "$LINE" | cut -d':' -f2- | sed 's/"/\\"/g' | sed 's/^[[:space:]]*//' | sed 's/[[:space:]]*$//')"
                        if [ "${KEY}" = "Set-Cookie" ]; then
                            VALUE=$(echo -n "${VALUE}" | tr ';' '\n' | tr -d '\n\t')
                        fi
                        echo -ne "\"${KEY}\":\"${VALUE}\"", | tr -d '\n\t'
                    else
                        echo -n '"x-ywt-version": "0.0.0-alpha.0"}'
                        IS_HEADER=false
                    fi
                else
                    BODY+="${LINE}"
                fi
            done < <(echo -e "${RESPONSE}")
            local IS_JSON=false
            STATS=$(echo "$BODY" | grep -oP "'{.*}'" | tail -n 1)
            STATS=$(echo -n "${STATS}" | sed "s/^'//" | sed "s/'$//")
            echo -n "${STATS}"
            BODY=$(echo -n "${BODY}" | sed "s/'{.*}'//")
            echo -n "{\"data\":"
            if __is json "${BODY}"; then
                local IS_JSON=true
                echo -n "${BODY}" | jq -c
            else
                BODY=$(echo -n "${BODY}" | sed 's/"/\\"/g' | sed 's/^[[:space:]]*//' | sed 's/[[:space:]]*$//')
                echo -n "\"${BODY}\""
            fi
            echo -n ",\"json\":${IS_JSON}"
            echo -n ",\"ok\":$([ "$STATUS_CODE" -ge 200 ] && [ "$STATUS_CODE" -lt 300 ] && echo "true" || echo "false")"
            echo -n "}"
        })"
        RESPONSE=$(jq --slurp '{"status": .[0], "headers": .[1], "stats": .[2], "response": .[3]}' <<<"${RESPONSE}")
        RATE_LIMIT="$(__extract_rate_limit "$(jq -r '.headers' <<<"${RESPONSE}")")"
        COOKIES="$(__cookies "$(jq -r '.headers' <<<"${RESPONSE}")")"
        jq -c '. + {
            "cookies": '"${COOKIES:-"{}"}"', 
            "limit": '"${RATE_LIMIT}"',
            "ok": '.response.ok',
            "json": '.response.json'
        } | del(.response.ok, .response.json)' <<<"${RESPONSE}"
        return 0
    }
    [ "$0" == "curl" ] && shift
    local METHOD="${1:-GET}"
    local URI="${2}" && [[ "${URI:-1}" != "/" ]] && URI="${URI}/" 
    URI="$(parse url "${URI}")" 
    if __is nil "$(jq -r '.uri' <<<"${URI}")"; then 
        echo "No URL2 (${URI})" | logger error 
        return 1
    fi
    case "${METHOD,,}" in    
    g | get)
        __send "$URI" '{"method":"'"${METHOD^^}"'"}'
        ;;
    p | post)
        __send "$URI" '{"method":"'"${METHOD^^}"'"}'
        ;;
    d | delete)
        __send "$URI" '{"method":"'"${METHOD}"'"}'
        ;;
    h | head)
        __send "$URI" '{"method":"'"${METHOD^^}"'"}'
        ;;
    o | options)
        __send "$URI" '{"method":"'"${METHOD^^}"'"}'
        ;;
    *) __nnf "$@" || usage "tests" "$?" "$@" && return 1 ;;
    esac
}
(
    export -f fetch
)
# </fetch.ywt.sh>
# <host.ywt.sh>
host() {
    info() {
        local HOSTNAME=$(hostname)
        local OS=$(uname -s)
        local KERNEL=$(uname -r)
        local ARCH=$(uname -m)
        local CPU=$(lscpu | grep "Model name" | cut -d: -f2 | xargs)
        local MEM=$(free -h | awk '/^Mem:/ {print $2}')
        local DISK=$(df -h / | awk '/\// {print $2}')
        echo "{
            \"hostname\": \"$HOSTNAME\",
            \"os\": \"$OS\",
            \"kernel\": \"$KERNEL\",
            \"arch\": \"$ARCH\",
            \"cpu\": \"$CPU\",
            \"mem\": \"$MEM\",
            \"disk\": \"$DISK\"
        }"
    }
    __nnf "$@" || usage "host" "$?" "$@" && return 1
}
# </host.ywt.sh>
# <hrml.ywt.sh>
hrml() {
    echo "Parse HRML files into a request parameters in any language, and vice versa" | logger info
    local VERBS=("GET" "POST" "PUT" "PATCH" "DELETE" "HEAD" "OPTIONS" "CONNECT" "TRACE")
    __print() {
        echo -n "$1"
    }
    __inspect:dir() {
        local TARGET="${1}" && shift
        ((DIR_INDEX++))
        while read -r FILE; do
            __print "["
            __inspect:file "$FILE"
            __print "],"
        done < <(find "$TARGET" -type f -name "*.hrml") | sed -e 's/,$//' | jq -c .
    }
    __inspect:file() {
        local TARGET="${1}" && shift
        ((FILE_INDEX++))
        local NAME=$(basename "$TARGET") && NAME=${NAME%.*}
        {
            __print "{"
            __print "\"scope\": \"$(dirname "$TARGET")\","
            __print "\"file\": \"$TARGET\","
            __print "\"name\": \"$NAME\","
            __print "\"seq\": $FILE_INDEX,"
            __print "\"requests\": ["
            local LINE_NUM=0
            local REQUEST_INDEX=0
            while read -r LINE || [ -n "$LINE" ]; do
                LINE_NUM=$((LINE_NUM + 1))
                LINE=$(echo "$LINE" | sed -e 's/^\s*//' -e 's/\s*$//')
                if [[ " ${VERBS[*]} " =~ ${LINE%% *} ]]; then
                    local METHOD=${LINE%% *}
                    [ -z "$METHOD" ] && continue
                    local URL=${LINE#* } && URL=${URL% *}
                    [ -z "$URL" ] && continue
                    REQUEST_INDEX=$((REQUEST_INDEX + 1))
                    __print "{"
                    __print "\"from\": ${LINE_NUM},"
                    __print "\"method\": \"${METHOD}\","
                    __print "\"url\": \"${URL}\","
                    __print "\"seq\": ${REQUEST_INDEX},"
                else
                    if [[ "$LINE" == "/}"* ]]; then
                        __print "\"to\": ${LINE_NUM}"
                        __print "},"
                    else
                        continue
                    fi
                fi
            done <"$TARGET" | sed -e 's/,$//'
            __print "]"
            __print "}"
        } | jq -c .
    }
    __inspect:lines() {
        local FILE="${1}" && shift
        local FROM="${1}" && shift
        local TO="${1}" && shift
        sed -n "${FROM},${TO}p" "$FILE"
    }
    __inspect::request() {
        local FILE="${1}" && shift
        local REQUEST="${1}" && shift
        local METHOD=$(echo "$REQUEST" | jq -r '.method')
        local URL=$(echo "$REQUEST" | jq -r '.url')
        local FROM=$(echo "$REQUEST" | jq -r '.from')
        local TO=$(echo "$REQUEST" | jq -r '.to')
        local SEQ=$(echo "$REQUEST" | jq -r '.seq')
        __inspect:block() {
            local BLOCK="${1}" && shift
            local CONTENT="${1}" && shift
            {
                __print "{\"${BLOCK,,}\": ["
                case "$BLOCK" in
                cookies)
                    {
                        local COOKIE=""
                        while read -r LINE || [ -n "$LINE" ]; do
                            if [[ "$LINE" == "cookie"* ]]; then
                                COOKIE_NAME=$(echo "$LINE" | grep -oP 'cookie\s+\K\w+')
                                COOKIE="{\"name\": \"$COOKIE_NAME\","
                            elif [[ "$LINE" == "}"* ]]; then
                                [ -z "$COOKIE" ] && continue
                                COOKIE=$(echo "$COOKIE" | sed -e 's/,$//')
                                COOKIE+="}"
                                __print "$COOKIE" | jq -c . #| tee /dev/stderr | logger info
                                __print ","
                                COOKIE=""
                            else
                                [ -z "$COOKIE" ] && continue
                                local VALUE=$(echo "$LINE" | grep -oP 'value:\s*"\K[^"]+')
                                [ -n "$VALUE" ] && COOKIE+="\"value\": \"$VALUE\","
                                VALUE=$(echo "$LINE" | grep -oP 'domain:\s*"\K[^"]+')
                                [ -n "$VALUE" ] && COOKIE+="\"domain\": \"$VALUE\","
                                VALUE=$(echo "$LINE" | grep -oP 'expires:\s*"\K[^"]+')
                                [ -n "$VALUE" ] && COOKIE+="\"expires\": \"$VALUE\","
                                VALUE=$(echo "$LINE" | grep -oP 'maxAge:\s*\K[^,]+')
                                [ -n "$VALUE" ] && COOKIE+="\"maxAge\": $VALUE,"
                                VALUE=$(echo "$LINE" | grep -oP 'secure:\s*\K[^,]+')
                                [ -n "$VALUE" ] && COOKIE+="\"secure\": $VALUE,"
                                VALUE=$(echo "$LINE" | grep -oP 'sameSite:\s*"\K[^"]+')
                                [ -n "$VALUE" ] && COOKIE+="\"sameSite\": \"$VALUE\","
                                VALUE=$(echo "$LINE" | grep -oP 'httpOnly:\s*\K[^,]+')
                                [ -n "$VALUE" ] && COOKIE+="\"httpOnly\": $VALUE,"
                                VALUE=$(echo "$LINE" | grep -oP 'path:\s*"\K[^"]+')
                                [ -n "$VALUE" ] && COOKIE+="\"path\": \"$VALUE\","
                            fi
                        done < <(echo "$CONTENT") | sed -e 's/,$//'
                    } | sed -e 's/,$//'
                    ;;
                *)
                    __print "$CONTENT" |
                        awk '/'"${BLOCK}"' {/,/}/{print}' |
                        sed -e 's/'"${BLOCK}"' {//' \
                            -e 's/}//' \
                            -e 's/^\s*//' \
                            -e 's/\s*$//' \
                            -e 's/,\s*$//' |
                        grep -v '^\s*$' |
                        awk '{gsub(/["'\'']/, "", $2); print "{\"" substr($1, 1, length($1)-1) "\": \"" $2 "\"},"}' |
                        sed -e '$s/,$//' \
                            -e 's/""$/"/'
                    ;;
                esac
                __print "]}"
            } | jq -c .
        }
        echo "Request ($SEQ): $METHOD $URL ($FROM-$TO) ${FILE}" | logger info
        local CONTENT=$(__inspect:lines "$FILE" "$FROM" "$TO")
        __inspect:block "body" "$CONTENT"
    }
    __inspect() {
        local TARGET="${1}" && shift
        local DIR_INDEX=0
        local FILE_INDEX=0
        if [ -d "$TARGET" ]; then
            local JSON=$(__inspect:dir "$TARGET")
        elif [ -f "$TARGET" ]; then
            local JSON=$(__inspect:file "$TARGET")
        else
            echo "Invalid HRML file or directory: $TARGET" | logger error
            return 1
        fi
        echo "$JSON" | jq . | tee /dev/stderr | logger info
        while read -r FILE; do
            while read -r REQUEST; do
                __inspect::request "$FILE" "$REQUEST"
            done < <(cat <<<"$JSON" | jq -c '.[].requests[] | select(.method != null)')
        done < <(cat <<<"$JSON" | jq -r '.[].file')
    }
    __method() {
        echo "$1" | grep -oP "^\s*\w+" | head -1
    }
    __inspect "$@" #| jq . | tee /dev/stderr | logger info
    return 0
    hrml:v1() {
        __json() {
            local JSON=("{") && local HRML_CONTENT=$(cat "$HRML_FILE")
            local LINE_NUM=0
            while read -r LINE || [ -n "$LINE" ]; do
                LINE_NUM=$((LINE_NUM + 1))
                LINE=$(echo "$LINE" | sed -e 's/^\s*//' -e 's/\s*$//')
                [ -z "$LINE" ] && continue
                if [[ " ${VERBS[*]} " =~ ${LINE%% *} ]]; then
                    local METHOD=${LINE%% *}
                    local URL=${LINE#* } && URL=${URL% *}
                    JSON+=("\"index\": ${LINE_NUM}")
                    JSON+=("\"method\": \"${METHOD}\"")
                    JSON+=("\"url\": \"${URL}\"")
                    continue
                fi
            done <"$HRML_FILE" # > /tmp/hrml.json
            JSON+=("}")
            echo "$(
                IFS=,
                echo "${JSON[*]}"
            )"
        }
        ___json() {
            __print "{"
            local HRML_VALUE=$(__method)
            __print "\"method\": \"${HRML_VALUE:-"GET"}\","
            HRML_VALUE=$(__url)
            __print "\"url\": \"${HRML_VALUE:-""}\","
            HRML_VALUE=$(__headers)
            __print "\"headers\": {${HRML_VALUE:-""}},"
            HRML_VALUE=$(__body)
            __print "\"body\": {${HRML_VALUE:-""}},"
            HRML_VALUE=$(__cookie)
            __print "\"cookie\": {${HRML_VALUE:-""}},"
            HRML_VALUE=$(__authz)
            __print "\"authorization\": {${HRML_VALUE:-""}},"
            HRML_VALUE=$(__data)
            __print "\"data\": {${HRML_VALUE:-""}},"
            HRML_VALUE=$(__files)
            __print "\"files\": {${HRML_VALUE:-""}},"
            HRML_VALUE=$(__params)
            __print "\"params\": {${HRML_VALUE:-""}},"
            HRML_VALUE=$(__options)
            __print "\"options\": {${HRML_VALUE:-""}}"
            __print "}"
        }
        __params() {
            echo "$HRML_CONTENT" | grep -oP "params\s*{[^}]+}" | sed -e 's/params\s*{//' -e 's/}//' -e 's/^\s*//' -e 's/\s*:\s*/: /g' -e 's/,\s*$//'
        }
        __files() {
            echo "$HRML_CONTENT" | grep -oP "files\s*{[^}]+}" | sed -e 's/files\s*{//' -e 's/}//' -e 's/^\s*//' -e 's/\s*:\s*/: /g' -e 's/,\s*$//'
        }
        __options() {
            echo "$HRML_CONTENT" | grep -oP "options\s*{[^}]+}" | sed -e 's/options\s*{//' -e 's/}//' -e 's/^\s*//' -e 's/\s*:\s*/: /g' -e 's/,\s*$//'
        }
        __data() {
            echo "$HRML_CONTENT" | grep -oP "data\s*{[^}]+}" | sed -e 's/data\s*{//' -e 's/}//' -e 's/^\s*//' -e 's/\s*:\s*/: /g' -e 's/,\s*$//'
        }
        __authz() {
            echo "$HRML_CONTENT" | grep -oP "authorization\s*{[^}]+}" | sed -e 's/authorization\s*{//' -e 's/}//' -e 's/^\s*//' -e 's/\s*:\s*/: /g' -e 's/,\s*$//'
        }
        __cookie() {
            echo "$HRML_CONTENT" | grep -oP "cookie\s*{[^}]+}" | sed -e 's/cookie\s*{//' -e 's/}//' -e 's/^\s*//' -e 's/\s*:\s*/: /g' -e 's/,\s*$//'
        }
        __body() {
            echo "$HRML_CONTENT" | grep -oP "body\s*{[^}]+}" | sed -e 's/body\s*{//' -e 's/}//' -e 's/^\s*//' -e 's/\s*:\s*/: /g' -e 's/,\s*$//'
        }
        __headers() {
            echo "$HRML_CONTENT" | grep -oP "headers\s*{[^}]+}" | sed -e 's/headers\s*{//' -e 's/}//' -e 's/^\s*//' -e 's/\s*:\s*/: /g' -e 's/,\s*$//'
        }
        __url() {
            echo "$HRML_CONTENT" | grep -oP "https?://\S+"
        }
        __method() {
            echo "$HRML_CONTENT" | grep -oP "^\s*\w+" | head -1
        }
    }
}
(
    export -f hrml
)
# </hrml.ywt.sh>
# <hron.ywt.sh>
hron() {
    YWT_LOGGER_CONTEXT="hron"
    echo "Parsing HRON..." | logger info
    local VERBS=("GET" "POST" "PUT" "PATCH" "DELETE" "HEAD" "OPTIONS" "CONNECT" "TRACE")
    local DIR_INDEX=0
    local FILE_INDEX=0
    local LINE_INDEX=0
    __print() {
        echo -n "$1"
    }
    __inspect:file() {
        local TARGET="${1}" && shift
        ((FILE_INDEX++))
        jq '.[]' "$TARGET"
    }
    __inspect:dir() {
        local TARGET="${1}" && shift
        ((DIR_INDEX++))
        while read -r FILE; do
            __inspect:file "$FILE"
        done < <(find "$TARGET" -type f -name "*.hron") # | sed -e 's/,$//' | jq -c .
    }
    __inspect:service:v1() {
        local TARGET="${1}" && shift
        local SERVICE_NAME=$(basename "$(dirname "$TARGET")")
        ((FILE_INDEX++))
        jq '
            .[]
            | .endpoint as $endpoint
            | .service = (
                if .service then .service else "'"$SERVICE_NAME"'" end
            )
            | .headers = (
                if .headers then .headers else {} end
            )
            | .cookies = (
                if .cookies then .cookies else {} end
            )
            | .query = (
                if .query then .query else {} end
            )
            | .routes = (
                if .routes then .routes else [] end
            )
            | .service as $service
            | .query as $query
            | .headers as $headers
            | .cookies as $cookies
            | .routes as $routes            
            | {
                routes: (
                    $routes
                    | map(
                        to_entries
                        | map(
                            .key as $key
                            | .value as $value
                            | .method = ($key | split(" ")[0])
                            | .path = ($key | split(" ")[1])
                            | .id = (
                                $value.id
                                | if . then . else "" end
                                | sub("^-"; "")
                                | sub("-$"; "") 
                                | gsub("[^a-zA-Z0-9]"; "-")
                                | gsub("-+" ; "-")
                            )
                            | .query = (
                                $query
                                | to_entries
                                | map("\(.key)=\(.value)")
                                | join("&")
                            )
                            | .query = (
                                $value.query
                                | if . then to_entries
                                | map("\(.key)=\(.value)")
                                | join("&") else "" end
                            )    
                            | .query = (
                                if .query then "?" + .query else "" end
                            )  
                            | .headers = (
                                $value.headers
                                | if . then $headers + . else $headers end
                            )
                            | .cookies = (
                                $value.cookies
                                | if . then $cookies + . else $cookies end
                            )
                            | .cookies = (
                                .cookies
                                | to_entries                                
                                | map(
                                    .value = (
                                        .value
                                        | if . then . else {} end
                                    )
                                    | .raw = (
                                        .value.value
                                        | if . then . + ";" else ";" end
                                    )
                                    | ."max-age" = (
                                        .value."max-age"
                                        | if . then "Max-Age=" + (. | tostring) + "; " else "" end
                                    )
                                    | .domain = (
                                        .value.domain
                                        | if . then "Domain=" + . + "; " else "" end
                                    )
                                    | .path = (
                                        .value.path
                                        | if . then "Path=" + . + "; " else "" end
                                    )
                                    | .secure = (
                                        .value.secure
                                        | if . then "Secure; " else "" end
                                    )
                                    | .httpOnly = (
                                        .value.httpOnly
                                        | if . then "HttpOnly; " else "" end
                                    )
                                    | .sameSite = (
                                        .value.sameSite
                                        | if . then "SameSite=" + . + "; " else "" end
                                    )
                                    | .expires = (
                                        .value.expires
                                        | if . then "Expires=" + . + "; " else "" end
                                    )
                                    | "Set-Cookie: " + (
                                        .key + "=" + .raw + ."max-age" + .domain + .path + .secure + .httpOnly + .sameSite + .expires
                                    )
                                )
                            )
                            | .url = $endpoint + "\(.path)\(.query)"                       
                            | {
                                id: "\($service).\(.id)",
                                defaults: {
                                    query: $query,
                                    headers: $headers,
                                    cookies: $cookies
                                },
                                service: $service,
                                endpoint: $endpoint,                                
                                query: .query,
                                headers: .headers,
                                cookies: .cookies,
                                key: $key,
                                method: .method,
                                path: .path,
                                url: .url,
                                query: .query,
                                headers: .headers,
                                cookies: .cookies
                            }                  
                        )
                    )
                )
            }
            
        ' "$TARGET"
    }
    __inspect:service() {
        local TARGET="${1}" && shift
        local SERVICE_NAME=$(basename "$(dirname "$TARGET")")
        ((FILE_INDEX++))
        jq '
            .[]
            | .endpoint as $endpoint
            | .index = (
                '"$FILE_INDEX"'
            )
            | .index as $index
            | .service = (
                if .service then .service else "'"$SERVICE_NAME"'" end
            )
            | .service as $service
            | .id = (
                if .id then .id else .service end
                | sub("^-"; "")
                | sub("-$"; "") 
                | gsub("[^a-zA-Z0-9]"; "-")
                | gsub("-+" ; "-")
            )
            | .id as $id
            | .headers = (
                if .headers then .headers else {} end
            )
            | .headers as $headers
            | .cookies = (
                if .cookies then .cookies else {} end
            )
            | .cookies as $cookies
            | .query = (
                if .query then .query else {} end
            )
            | .query as $query
            | {
                index: $index,
                id: $id,
                service: $service,
                endpoint: $endpoint,                
                query: $query,
                headers: $headers,
                cookies: $cookies                
            }
        ' "$TARGET"
    }
    __inspect:routes(){
        local SVC_SCHEMA="${1}" && shift
        local ROUTES="${1}" && shift
        if [ -f "$ROUTES" ]; then
            local SVC_ROUTES=$(jq -r '.[]' "$ROUTES")
        elif [ -d "$ROUTES" ]; then
            local SVC_ROUTES=$(
                find "$ROUTES" -type f \
                    -name "*.hron" \
                    -not -name "index.hron" \
                    -exec jq -r '
                        . 
                        | .schema = (
                            '"$SVC_SCHEMA"'
                        )
                        | .file = (
                            input_filename
                            | sub(".*/"; "")
                            | sub("\\.hron$"; "")
                        )
                        | .file as $file
                        | .dir = (
                            input_filename
                            | sub("/[^/]+$"; "")
                            | sub(".*/"; "")
                        )
                        | .dir as $dir                        
                        | .
                        
                    ' {} \;
            )
        elif jq -e . >/dev/null 2>&1 <<<"$ROUTES"; then
            local SVC_ROUTES=$(jq -r '.[]' <<<"$ROUTES")
        else
            __debug "Invalid routes: $ROUTES"
            echo "[]" && return 1
        fi
        echo "$SVC_ROUTES"
    }
    __inspect() {
        local TARGET="${1}" && shift
        [[ ! -d "$TARGET" ]] && echo "Invalid directory: $TARGET" && return 1
        while read -r SVC_DIR; do
            local SVC_INDEX="$SVC_DIR/index.hron"
            [[ ! -f "$SVC_INDEX" ]] && continue
            local SVC_SCHEMA="$(__inspect:service "$SVC_INDEX")"
            echo "$SVC_SCHEMA" | jq .
        done < <(find "$TARGET" -type d)
    }
    __inspect "$1" #| jq .
}
(
    export -f hron
)
# </hron.ywt.sh>
# <linter.ywt.sh>
linter() {
    lint(){
        echo "lint"
    }
    __nnf "$@" || usage "linter" "$?" "$@" && return 1    
}
(
    export -f linter
)
# </linter.ywt.sh>
# <logger.ywt.sh>
logger() {
    _is_log_level() {
        local LEVEL=${1:-info} && [[ ! $LEVEL =~ ^(debug|info|warn|error|success)$ ]] && LEVEL=info
        local LOG_LEVEL=${YWT_LOG_LEVEL:-info}
        [[ $LOG_LEVEL == "debug" ]] && [[ $LEVEL == "debug" ]] && return 0
        [[ $LOG_LEVEL == "info" ]] && [[ $LEVEL == "info" ]] && return 0
        [[ $LOG_LEVEL == "warn" ]] && [[ $LEVEL == "warn" ]] && return 0
        [[ $LOG_LEVEL == "error" ]] && [[ $LEVEL == "error" ]] && return 0
        [[ $LOG_LEVEL == "success" ]] && [[ $LEVEL == "success" ]] && return 0
        return 1
    }
    _log_level() {
        local LEVEL=${1:-info} && [[ ! $LEVEL =~ ^(debug|info|warn|error|success)$ ]] && LEVEL=info
        local COLOR=white
        local ICON=""
        case $LEVEL in
        debug)
            COLOR=cyan
            ICON="🐞"
            ;;
        info)
            COLOR=green
            ICON="📗"
            ;;
        warn)
            COLOR=yellow
            ICON="🔔"
            ;;
        error)
            COLOR=red
            ICON="🚨"
            ;;
        success)
            COLOR=green
            ICON="✅"
            ;;
        esac
        LEVEL=$(printf "%-5s" "$LEVEL") #YWT_LOG_CONTEXT
        echo -n "$(colors apply "yellow" "[${YWT_CMD_NAME^^}]") "
        echo -n "$(colors apply "bright-black" "[$$]" "fg") "
        echo -n "$(colors apply "blue" "[$(date +"%Y-%m-%d %H:%M:%S")]" "fg") "
        echo -n "$(colors apply "$COLOR" "$(styles bold "[${LEVEL^^}]")" "fg") "
        [[ "${YWT_LOG_CONTEXT^^}" != "${YWT_CMD_NAME^^}" ]] && echo -n "$(colors apply "blue" "[${YWT_LOG_CONTEXT^^}]") "
        [ -n "$ICON" ] && echo -n "$(colors apply "$COLOR" "$ICON" "fg")"
        echo -n " "
    }
    _log_message() {
        local MESSAGE=${1:-}
        local LINES=()
        [[ -n "$MESSAGE" ]] && LINES+=("$MESSAGE")
        [[ -p /dev/stdin ]] && while read -r LINE; do LINES+=("$LINE"); done <&0
        MESSAGE="${LINES[*]//$'\n'/$'\n' }"
        echo -n "$MESSAGE"
    }
    _log:level() {
        local LEVEL=${1:-info} && [[ ! $LEVEL =~ ^(debug|info|warn|error|success)$ ]] && LEVEL=info
        local COLOR=white
        local ICON=""
        case $LEVEL in
        debug)
            COLOR=cyan
            ICON="🐞"
            ;;
        info)
            COLOR=green
            ICON="📗"
            ;;
        warn)
            COLOR=yellow
            ICON="🔔"
            ;;
        error)
            COLOR=red
            ICON="🚨"
            ;;
        success)
            COLOR=green
            ICON="✅"
            ;;
        esac
        {
            echo -n "{"
            echo -n "\"level\": \"${LEVEL}\","
            echo -n "\"icon\": \"${ICON}\","
            echo -n "\"color\": \"${COLOR}\""
            echo -n "}"
        } | jq -c .
    }
    _log:message() {
        local MESSAGE=${1:-}
        local LINES=()
        [[ -n "$MESSAGE" ]] && LINES+=("$MESSAGE")
        [[ -p /dev/stdin ]] && while read -r LINE; do LINES+=("$LINE"); done <&0
        MESSAGE="${LINES[*]//$'\n'/\\n}"
        MESSAGE=$(echo "$MESSAGE" | sed -r "s/\x1B\[[0-9;]*[mK]//g")
        echo -n "$MESSAGE"
    }
    _log:json() {
        local LOG_LEVEL="$(_log:level "$1")"
        local LOG_MESSAGE="$(_log:message "$2")"
        jq -cn \
            --argjson level "$LOG_LEVEL" \
            --argjson config "$YWT_CONFIG" \
            --arg message "${LOG_MESSAGE:-}" \
            '{
                "signal": $level.icon,
                "context": "'"${YWT_LOG_CONTEXT,,}"'",   
                "level": $level.level,
                "message": $message,
                "timestamp": (now | todate),
                "version": $config.yellowteam.version,                
                "tags": ["'"ywt:${YWT_LOG_CONTEXT,,}:context"'"],
                "path": "",
                "host": "'"$(hostname)"'",
                "type": "'"${YWT_LOG_CONTEXT,,}-log"'",
                "package": "\($config.yellowteam.name):\($config.yellowteam.version):\($config.yellowteam.license)",
                "color": $level.color,
                "icon": $level.icon,
                "pid": "'$$'",
                "ppid": "'"$PPID"'",
                "cmd": "'"$YWT_CMD_NAME"'",
                "name": "'"$YWT_CMD_NAME"'",                
                "etime": "'"$(__etime)"'"
            }' | jq -c '
                . |
                map_values(
                    if type == "string" then
                        . | gsub("\n"; " ")
                    else
                        .
                    end
                ) |
                .
            '
    }
    _log:loki() {
        local LOG_JSON=$1
        echo "$LOG_JSON" | jq -r .
    }
    _log:upstash() {
        local LOG_JSON=$1
        echo "$LOG_JSON" | jq -r .
    }
    _log:template() {
        local LOG_JSON=$1
        local LOG_FORMAT="${YELLOW}[${YWT_CMD_NAME^^}]${NC}" &&
            LOG_FORMAT+=" ${BRIGHT_BLACK}[\(.pid)]${NC}" &&
            LOG_TEMPLATE+=" ${BLUE}[\(.timestamp)]${NC}" &&
            LOG_FORMAT+=" \(.signal)" &&
            LOG_FORMAT+=" \(.level | ascii_upcase)" &&
            LOG_FORMAT+=" ${YELLOW}\(.context | ascii_upcase)${NC}" &&
            LOG_FORMAT+=" \(.message)" &&
            LOG_FORMAT+=" [${BRIGHT_BLACK}\(.etime)${NC}]"
        echo "$LOG_JSON" | jq --arg format "$LOG_FORMAT" -rc '
            . |
            "'"$LOG_FORMAT"'"
        '
    }
    log() {
        [ "$1" == "debug" ] && __debug "logger:" "$@" && return 0
        _log:template "$(_log:json "$@")"
        return 0
    }
    json() {
        _log_level "$1"
        jq -cC . <<<"$(_log_message "$2")"
    }
    local LEVEL=${1}
    if [[ $LEVEL =~ ^(debug|info|warn|error|success)$ ]]; then
        log "${1}" "${@:2}" && return 0
    elif [[ $LEVEL == "json" ]]; then
        shift # && LEVEL="json ${LEVEL}"
        json "${LEVEL}" "$@" && return 0
    elif __nnf "$@"; then
        return 0
        usage "$?" "logger" "$@" && return 1
    else
        usage 1 "logger" "$@" && return 1
    fi
}
(
    export -f logger
)
# </logger.ywt.sh>
# <network.ywt.sh>
network() {
    info() {
        local IP=$(hostname -I | awk '{print $1}')
        local MAC=""
        local GATEWAY=""
        if command -v ip >/dev/null 2>&1; then
            GATEWAY=$(ip route | awk '/default/ {print $3}')
            MAC=$(ip link show | awk '/link\/ether/ {print $2}')
        fi
        local DNS=$(awk '/nameserver/ {print $2}' </etc/resolv.conf)
        local PUBLIC_IP=$(curl -s ifconfig.me)
        echo "{
            \"ip\": \"$IP\",
            \"mac\": \"$MAC\",
            \"gateway\": \"$GATEWAY\",
            \"dns\": \"$DNS\",
            \"public_ip\": \"$PUBLIC_IP\"
        }"
    }
    ioc nnf "$@" || usage "network" "$?" "$@" && return 1
}
(
    export -f network
)
# </network.ywt.sh>
# <osint.ywt.sh>
osint() {
    employers() {
        echo "employers"
    }
    employees() {
        echo "employees"
    }
    companies() {
        echo "companies"
    }
    domains() {
        echo "domains"
    }
    emails() {
        echo "emails"
    }
}
(
    export -f osint
)
# </osint.ywt.sh>
# <param.ywt.sh>
param() {
    get() {
        local PARAM_NAME DEFAULT_VALUE REQUIRED TYPE STORE_FILE CONFIG_FILE
        local CONFIG_PREFIX="YWT_CONFIG_"
        local ARGS=()
        while [ "$#" -gt 0 ]; do
            case "$1" in
            -n | --name)
                PARAM_NAME="$2"
                shift 2
                ;;
            -d | --default)
                DEFAULT_VALUE="$2"
                shift 2
                ;;
            -r | --required)
                REQUIRED=true
                shift
                ;;
            -t | --type)
                TYPE="$2"
                shift 2
                ;;
            -s | --store)
                STORE_FILE="$2"
                [ ! -f "$STORE_FILE" ] && echo "Store file not found: $STORE_FILE" | Logger error && return 1
                ! __is rw "$STORE_FILE" && echo "Store file is not writable: $STORE_FILE" | Logger error && return 1
                shift 2
                ;;
            -c | --config)
                CONFIG_FILE="$2"
                shift 2
                ;;
            -f | --from)
                CONFIG_PREFIX="$2"
                shift 2
                ;;
            -m | --message)
                MESSAGE="$2"
                shift 2
                ;;
            *)
                ARGS+=("$1")
                shift
                ;;
            esac
        done
        local CONFIG_VALUE="$(eval echo "\$${CONFIG_PREFIX}${PARAM_NAME^^}")"
        local PARAM_VALUE="$(jq -r '.params["'"${PARAM_NAME}"'"] // empty' <<<"$YWT_CONFIG")"
        local FLAG_VALUE="$(jq -r '.flags["'"${PARAM_NAME}"'"] // empty' <<<"$YWT_CONFIG" 2>/dev/null)"
        local ENV_VALUE="$(jq -r '.env["'"${PARAM_NAME}"'"] // empty' <<<"$YWT_CONFIG" 2>/dev/null)"
        local STORE_VALUE="" #$(store get "$PARAM_NAME")
        local VAR_NAME="${PARAM_NAME^^}" && VAR_NAME="${VAR_NAME//-/_}" && VAR_NAME="${VAR_NAME//./_}" && VAR_NAME="${VAR_NAME// /_}" && VAR_NAME="${VAR_NAME//\//_}"
        local PROCESS_ENV_VALUE="$(eval echo "\$${VAR_NAME^^}")"
        local VALUE="${!VAR_NAME}"
        local VALUE_KEY="raw"
        if [ -z "$VALUE" ]; then
            if [ -n "$CONFIG_VALUE" ]; then
                VALUE="$CONFIG_VALUE"
                VALUE_KEY="config"
            elif [ -n "$FLAG_VALUE" ]; then
                VALUE="$FLAG_VALUE"
                VALUE_KEY="flag"
            elif [ -n "$STORE_VALUE" ]; then
                VALUE="$STORE_VALUE"
                VALUE_KEY="store"
            elif [ -n "$PARAM_VALUE" ]; then
                VALUE="$PARAM_VALUE"
                VALUE_KEY="param"
            elif [ -n "$DEFAULT_VALUE" ]; then
                VALUE="$DEFAULT_VALUE"
                VALUE_KEY="default"
            elif [ -n "$ENV_VALUE" ]; then
                VALUE="$ENV_VALUE"
                VALUE_KEY="env"
            elif [ -n "$PROCESS_ENV_VALUE" ]; then
                VALUE="$PROCESS_ENV_VALUE"
                VALUE_KEY="process"
            fi
        fi
        local LOG_MESSAGE="(--kv=$PARAM_NAME: ${VALUE:-"empty"})"
        local ERROR=
        [ -z "$VALUE" ] && [ "$REQUIRED" == true ] && ERROR="${LOG_MESSAGE} is required"
        if [ -n "$TYPE" ]; then
            case "$TYPE" in
            date)
                if ! date -d "$VALUE" >/dev/null 2>&1; then
                    ERROR="${LOG_MESSAGE} must be a valid date"
                fi
                ;;
            url)
                if ! [[ "$VALUE" =~ ^https?:// ]]; then
                    ERROR="${LOG_MESSAGE} must be a valid URL"
                fi
                ;;
            json)
                if ! jq -e . >/dev/null 2>&1 <<<"$VALUE"; then
                    ERROR="${LOG_MESSAGE} must be a valid JSON"
                fi
                ;;
            number)
                if ! [[ "$VALUE" =~ ^[0-9]+$ ]]; then
                    ERROR="${LOG_MESSAGE} must be a number"
                fi
                ;;
            int)
                if ! [[ "$VALUE" =~ ^[0-9]+$ ]]; then
                    ERROR="${LOG_MESSAGE} must be an integer"
                fi
                ;;
            float)
                if ! [[ "$VALUE" =~ ^[0-9]+(\.[0-9]+)?$ ]]; then
                    ERROR="${LOG_MESSAGE} must be a float"
                fi
                ;;
            bool)
                if ! [[ "$VALUE" =~ ^(true|false)$ ]]; then
                    ERROR="${LOG_MESSAGE} must be a boolean"
                fi
                ;;
            *) ;;
            esac
        fi
        local VALID=$(if [ -z "$ERROR" ]; then echo "true"; else echo "false"; fi)
        local METADATA="$({
            echo -n "{"
            echo -n "\"error\":\"$ERROR\","
            echo -n "\"message\":\"${MESSAGE:-""}\","
            echo -n "\"valid\":$VALID,"
            echo -n "\"name\":\"$PARAM_NAME\","
            echo -n "\"default\":\"${DEFAULT_VALUE//\"/\\\"}\","
            echo -n "\"required\":${REQUIRED:-false},"
            echo -n "\"type\":\"$TYPE\","
            echo -n "\"store\":\"$STORE_FILE\","
            echo -n "\"config\":\"$CONFIG_FILE\"",
            echo -n "\"from\":\"${VALUE_KEY}\","
            if [[ "$VALUE" =~ ^[0-9]+$ ]] || [[ "$VALUE" =~ ^(true|false)$ ]]; then
                echo -n "\"value\":$VALUE,"
            else
                echo -n "\"value\":\"$VALUE\","
            fi
            echo -n "\"values\":{"
            echo -n "\"config\":\"$CONFIG_VALUE\","
            echo -n "\"param\":\"$PARAM_VALUE\","
            echo -n "\"flag\":\"$FLAG_VALUE\","
            echo -n "\"env\":\"$ENV_VALUE\","
            echo -n "\"process\":\"$PROCESS_ENV_VALUE\","
            echo -n "\"store\":\"$STORE_VALUE\","
            echo -n "\"raw\":\"$VALUE\""
            echo -n "}"
            echo -n "}"
        } | jq -cr '.')"
        echo -n "${METADATA}" | jq -cr '.'
        [ -z "$ERROR" ] && return 0
        return 1
    }
    kv() {
        case "$1" in
        -v | --validate)
            VALIDATE=true
            shift
            ;;
        esac
        local PARAMS=$(
            {
                echo -n "["
                local ARGS=()
                while [ "$#" -gt 0 ]; do
                    case "$1" in                    
                    --)
                        get "${ARGS[@]}" #echo "get ${ARGS[*]}"
                        ARGS=()
                        shift
                        [ "$#" -gt 1 ] && echo -n ","
                        ;;
                    *)
                        ARGS+=("$1")
                        shift
                        ;;
                    esac
                done
                [ "${#ARGS[@]}" -gt 0 ] && get "${ARGS[@]}" # echo "get ${ARGS[*]}"
                echo -n "]"
            } | jq -r '.' | jq -cr 'reduce .[] as $item ({}; .[$item.name] = $item)'
        )
        if [ "$VALIDATE" == true ]; then
            if ! validate "$PARAMS"; then
                return 1
            fi
        fi
        echo "$PARAMS" | jq -cr '.'
    }
    validate() {
        if ! jq -e . >/dev/null 2>&1 <<<"$1"; then
            echo "Invalid JSON ${1}" | logger error
            return 1
        fi
        local ERRORS=$(jq -r '. | to_entries[] | select(.value.valid == false) | .value.error | select(. != null)' <<<"$1")
        if ! __is nil "$ERRORS"; then
            IFS=$'\n' read -r -d '' -a ERRORS <<<"$ERRORS"
            local COUNT=${#ERRORS[@]}
            echo "${COUNT} Invalid parameters" | logger error
            for ERROR in "${ERRORS[@]}"; do
                echo "$ERROR" | logger error
            done
            return 1
        fi
        return 0
    }
    case "$1" in
    get)
        shift
        get "$@"
        ;;
    merge)
        shift
        merge "$@"
        ;;
    validate)
        shift
        validate "$@"
        ;;
    *) __nnf "$@" || usage "param" "$?" "$@" && return 1 ;;
    esac
    return $?
}
(
    export -f param
)
# </param.ywt.sh>
# <parse.ywt.sh>
parse() {
    querystring() {
        __require awk sed
        local URI=${1}
        if [[ $URI =~ .*\?([^#]*).* ]]; then
            QS="${BASH_REMATCH[1]}"
            JSON=$(echo "$QS" | tr '&' '\n' | awk -F '=' '{printf "\"%s\":\"%s\",\n", $1, $2}' | sed 's/,$//') && JSON="{ ${JSON} }" && JSON=$(echo "$JSON" | tr -d '\n') && JSON="${JSON//\"\"/\",\"}" 
            
            echo "$JSON"
        fi
    }
    url() {
        __require cut rev
        local URI=${1}
        local URI_SCHEME=$(echo "$URI" | grep "://" | sed -e's,^\(.*://\).*,\1,g')
        local URI_NO_SCHEME="${URI/$URI_SCHEME/}" # $(echo "${URI/$URI_SCHEME/}" | cut -d/ -f3-)
        local URI_PROTOCOL=$(echo "$URI_SCHEME" | sed -e's,^\(.*://\).*,\1,g' | sed -e's,://,,g')
        local URI_CREDENTIAL=$(echo "$URI_NO_SCHEME" | grep "@" | cut -d"/" -f1 | rev | cut -d"@" -f2- | rev)
        local URI_PASSWORD=$(echo "$URI_CREDENTIAL" | grep ":" | cut -d":" -f2)
        if [[ -n $URI_PASSWORD ]]; then
            URI_USER=$(echo "$URI_CREDENTIAL" | grep ":" | cut -d":" -f1)
        else
            URI_USER="$URI_CREDENTIAL"
        fi
        local URI_HOST_PORT=$(echo "${URI_NO_SCHEME/$URI_CREDENTIAL@/}" | cut -d"/" -f1 | cut -d"?" -f1)
        local URI_HOST=$(echo "$URI_HOST_PORT" | cut -d":" -f1)
        local URI_PORT=$(echo "$URI_HOST_PORT" | grep ":" | cut -d":" -f2)
        local URI_PATH=$(echo "${URI_NO_SCHEME}" | grep "/" | cut -d"/" -f2-) && 
        URI_PATH=$(echo "$URI_PATH" | grep "?" | cut -d"?" -f1)
        local URI_QUERY=$(echo "$URI_NO_SCHEME" | grep "?" | cut -d"?" -f2)
        if [[ -n $URI_QUERY ]]; then
            local URI_QUERY_STRING=$(querystring "$URI")
        else
            local URI_QUERY_STRING="{}"
        fi
        local URI_ANCHOR=$(echo "$URI_QUERY" | grep "#" | cut -d"#" -f2)
        echo "{
            \"scheme\": \"$URI_SCHEME\",
            \"protocol\": \"$URI_PROTOCOL\",
            \"credentials\": \"$URI_CREDENTIAL\",
            \"user\": \"$URI_USER\",
            \"password\": \"$URI_PASSWORD\",
            \"hostport\": \"$URI_HOST_PORT\",
            \"host\": \"$URI_HOST\",
            \"port\": \"$URI_PORT\",
            \"path\": \"$URI_PATH\",
            \"query\": \"$URI_QUERY\",
            \"querystring\": $URI_QUERY_STRING,
            \"anchor\": \"$URI_ANCHOR\",
            \"uri\": \"$URI\",
            \"surl\": \"${URI/$URI_CREDENTIAL@/}\"
        }" | jq '.' -c
        return 0
    }
    __nnf "$@" || usage "parse" "$?" "$@" && return 1
}
(
    export -f parse
)
# </parse.ywt.sh>
# <process.ywt.sh>
process() {
    local YWT_CMD_PROCESS=$$ && readonly YWT_CMD_PROCESS
    local YWT_CMD_FILE=$0 && readonly YWT_CMD_FILE
    local YWT_CMD_ARGS=$* && readonly YWT_CMD_ARGS
    local YWT_CMD_ARGS_LEN=$# && readonly YWT_CMD_ARGS_LEN
    local YWT_IS_BINARY=false
    LC_ALL=C grep -a '[^[:print:][:space:]]' "$YWT_CMD_FILE" >/dev/null && YWT_IS_BINARY=true
    info() {
        local FILE="$YWT_CMD_FILE"
        echo "{
            \"pid\": \"$YWT_CMD_PROCESS\",
            \"file\": \"$FILE\",        
            \"args\": \"$YWT_CMD_ARGS\",
            \"args_len\": \"$YWT_CMD_ARGS_LEN\",
            \"name\": \"$YWT_CMD_NAME\",
            \"initialized\": \"$YWT_INITIALIZED\",
            \"binary\": \"$YWT_IS_BINARY\"
        }"
    }
    __nnf "$@" || usage "process" "$?" "$@" && return 1
    return 0
}
(
    export -f process
)
# </process.ywt.sh>
# <require.ywt.sh>
require() {
    deps() {
        local DEPENDENCIES=("$@")
        for DEPENDENCY in "${DEPENDENCIES[@]}"; do
            if ! __is command "${DEPENDENCY}"; then
                __debug "required ${DEPENDENCY} (command not found)"
                YWT_MISSING_DEPENDENCIES+=("${DEPENDENCY}")                
            fi
        done
        [ "${#YWT_MISSING_DEPENDENCIES[@]}" -eq 0 ] && return 0
        local MSG="Missing dependencies: ${YWT_MISSING_DEPENDENCIES[*]}"
        __log error "$MSG" && return 1
        return 1
    }
    __nnf "$@" || usage "require" "$?" "$@" && return 1
}
(
    export -f require
)
# </require.ywt.sh>
# <resources.ywt.sh>
resources() {
    __find() {
        local TYPE=${1:-} && [ -z "$TYPE" ] && echo "Resource type not defined" && return 1
        local RESOURCE_PATH && RESOURCE_PATH=$(jq -r ".$TYPE" <<<"$YWT_PATHS")
        [ ! -d "$RESOURCE_PATH" ] && echo "Resource $TYPE not found" && return 1
        find "$RESOURCE_PATH" -mindepth 1 -maxdepth 1 -type d -printf '%P\n' | jq -R -s -c 'split("\n") | map(select(length > 0))'
    }
    __nnf "$@" || usage "resources" "$?" "$@" && return 1
}
(
    export -f resources
)
# </resources.ywt.sh>
# <scan.ywt.sh>
scan() {
    __scan:validate() {
        local ASSETS="$1" && shift
        [ ! -f "${ASSETS}" ] && echo "File not found: ${ASSETS}" | logger error && return 1
        if ! jq -e . "${ASSETS}" >/dev/null 2>&1; then
            echo "{\"error\":\"Invalid JSON: ${ASSETS}\"}"
            return 1
        fi
        local ASSETS_COUNT=$(jq -c '.' "${ASSETS}" | wc -l)
        if [ "${ASSETS_COUNT}" -gt 10 ]; then
            echo "{\"error\":\"Max of 10 assets\"}"
            return 1
        fi
    }
    __scan:assets() {
        local ASSETS="$1" && shift
        if ! __scan:validate "${ASSETS}" >/dev/null 2>&1; then
            echo "{\"error\":\"Invalid assets\"}"
        fi
        jq -c '.' "$ASSETS"
        return 0
    }
    __scan:plan() {
        jq -cn \
            --argjson assets "$(__scan:assets "$1")" \
            --argjson scanners "$(scanner list)" '
            {
                assets: $assets,
                scanners: $scanners,
                plan: (
                    $assets | map(
                        . as $asset |
                        $scanners | map(
                            . as $scanner |
                            select($asset.type | IN($scanner.metadata.capabilities[])) |
                            {
                                asset: $asset,
                                scanner: $scanner
                            }
                        )
                    ) | flatten |
                    map(
                        {
                            asset: .asset,
                            scanner: .scanner
                        }
                    )
                )
            }
        ' | jq '.plan'
    }
    plan() {
        __scan:plan "$@" | jq -c 'del(.[] | .command)'
    }
    summary() {
        __scan:plan "$@" | jq -c '
            {
                assets: (map(.asset) | unique) | length,
                scanners: (map(.scanner.header.name) | unique) | length,
                executions: length
            }
        '
    }
    apply() {
        {
            local SCAN_TASKS=$(
                __scan:plan "$@" | jq -rc '
                    .[]
                '
            )
            local SCAN_COMMANDS=()
            while read -r TASK; do                
                TASK=$(jq -rc '.' <<<"${TASK}")
                local TASK_ARG=$(echo -n "${TASK}" | base64 -w 0 | tr -d '=' | tr '/+' '_-')
                SCAN_COMMANDS+=("scan analyze ${TASK_ARG}")
            done <<<"${SCAN_TASKS}"      
            async "${SCAN_COMMANDS[@]}" # & wait $!
            
            
        } #| jq -s '.'
    }
    analyze() {
        local SCAN_JSON=$(echo -n "$1" | base64 -d 2>/dev/null)
        if [[ -n "$SCAN_JSON" ]] && jq -e . >/dev/null 2>&1 <<<"${SCAN_JSON}"; then
            SCAN_JSON=$(jq -c '.' <<<"${SCAN_JSON}")
            local SCAN_ASSET=$(jq -r '.asset' <<<"${SCAN_JSON}")
            local SCAN_ASSET_TYPE=$(jq -r '.type' <<<"${SCAN_ASSET}")
            local SCAN_SCANNER=$(jq -r '.scanner' <<<"${SCAN_JSON}")
            local SCAN_SCANNER_NAME=$(jq -cr '.header.name' <<<"${SCAN_SCANNER}")
            local SCAN_ASSET_ARG="$(jq -c '.' <<<"${SCAN_ASSET}")" && SCAN_ASSET_ARG="${SCAN_ASSET_ARG//\"/\\\"}"
            echo "Scanning ${SCAN_ASSET_TYPE} with ${SCAN_SCANNER_NAME}" | logger info
            scanner "${SCAN_SCANNER_NAME}" asset "${SCAN_ASSET_ARG}"                        
        else
            echo "Invalid base64 input" >&2
        fi
    }
    asset(){
        local ASSET="$1" && shift
        local SCANNER="$1" && shift
        local COMMAND="scanner ${SCANNER} asset ${ASSET}"
        echo "${COMMAND}"
    }
    __nnf "$@" && return "$?"
}
# </scan.ywt.sh>
# <scanner.cloc.ywt.sh>
__scanner:cloc() {
    local DEFAULT_ARGS=(
        "--json"
        "--quiet"
        "--exclude-dir=sys,.git,vendor,node_modules,tests,tests-*,test,tests-*,.git,.github,.vscode,.idea,build,dist,docs,examples,examples-*,samples,spec,specs,spec-*,specs-*,tmp,log,logs,cache,bin,lib,libs,src,assets,resources,static,public,web,webroot,webapp,webapps,webroot,webroots,app,apps,app-*,apps-*,dist,build,builds,deploy,deploys,deployment,deployments,release,releases,backup,backups,backup-*,backups-*,temp,temporary,template,templates,config,configs,configuration,configurations,settings,setting,settings-*,setting-*,conf,confs,conf-*,confs-*,env,envs,env-*,envs-*,log,logs,log-*,logs-*,tmp,temp,tmp-*,temp-*,cache,caches,cache-*,caches-*,data,datas,data-*,datas-*,db,dbs,db-*,dbs-*,database,databases,database-*,databases-*,doc,docs,doc-*,docs-*,document,documents,document-*,documents-*,image,images,image-*,images-*,img,imgs,img-*,imgs-*,media,medias,media-*,medias-*,video,videos,video-*,videos-*,audio,audios,audio-*,audios-*,bin,binaries,binary,binaries-*,binary-*,lib,libs,lib-*,libs-*,libra"
    )
    cloc:install() {
        curl -sSfL https://raw.githubusercontent.com/AlDanial/cloc/master/cloc -o /usr/local/bin/cloc
        chmod +x /usr/local/bin/cloc
    }
    cloc:uninstall() {
        rm -f /usr/local/bin/cloc
    }
    cloc:cli() {
        __scanner:cli "cloc" "${DEFAULT_ARGS[@]}" "$@"
    }
    cloc:version() {
        cloc:cli --version
        return 0
    }
    cloc:metadata() {
        {
            echo -n "{"
            echo -n "\"uuid\":\"cbb46398-a79e-4afe-9672-badabf6075e7\","
            echo -n "\"capabilities\":[\"filesystem\"],"
            echo -n "\"features\":[\"lines-of-code\", \"files\", \"languages\"],"
            echo -n "\"engines\":[\"host\",\"docker\",\"npx\"],"
            echo -n "\"formats\":[\"json\",\"text\"],"
            echo -n "\"priority\":1,"
            echo -n "\"tool\":{"
            echo -n "\"driver\":{"
            echo -n "\"name\":\"cloc\","
            echo -n "\"informationUri\":\"https://github.com/AlDanial/cloc\","
            echo -n "\"version\":\"1.90\""
            echo -n "} }"
            echo -n "}"
        } | jq -c .
        return 0
    }
    cloc:activate() {
        echo "{}"
        return 0
    }
    cloc:result() {
        jq -c . "$1"
    }
    cloc:summary() {
        [ ! -f "$1" ] && echo -n "{}" && return 0
        jq -c '
            . as $root |
            keys[] |
            select(. != "header" and . != "SUM") |
            {
                Language: .,
                Files: $root[.].nFiles,
                Blank: $root[.].blank,
                Comment: $root[.].comment,
                Code: $root[.].code
            }
        ' "$1"
    }
    cloc:asset() {        
        local ASSET="${1//\\\"/\"}" && shift
        if ! __is json "$ASSET"; then
            echo "{\"error\":\"Invalid asset\"}"
            return 1
        fi
        case "$(jq -r '.type' <<<"$ASSET")" in
        filesystem)
            local ASSET_PATH="$(jq -r '.target' <<<"$ASSET")"
            if [ ! -d "$ASSET_PATH" ]; then
                echo "{\"error\":\"Invalid asset path\"}"
                return 1
            fi
            cloc:cli "/ywt-workdir$ASSET_PATH"
            return 0
            ;;
        *)
            echo "{\"error\":\"Invalid asset type\"}"
            return 1
            ;;
        esac
    }
    local ACTION="$1" && shift
    __nnf "cloc:$ACTION" "$@"
    return $?
}
# </scanner.cloc.ywt.sh>
# <scanner.network.ywt.sh>
__scanner:network:hsts() {
    local TARGET="$1" && shift
    local SCANNER="$({
        echo -n "{"
        echo -n "\"scanner\":\"ywt-network-hsts\","
        echo -n "\"type\":\"url\","
        echo -n "\"format\":\"json\","
        echo -n "\"output\":\"$RESULT_FILE\","
        echo -n "\"start\":\"$(date +%s)\","
        echo -n "\"engines\":["
        echo -n "\"host\","
        echo -n "\"docker\""
        echo -n "]"
    })"
    if [ -z "$TARGET" ]; then
        SCANNER+=",\"error\":\"target not found\""
    else
        local URI=$(parse url "$TARGET")
        if __is nil jq -r .uri <<<"$URI"; then
            SCANNER+=",\"error\":\"invalid target\""
        else
            SCANNER+="$({
                echo -n ",\"target\":\"$TARGET\""
                echo -n ",\"uri\": $URI"
            })"
        fi
        local HSTS_HEADER=$(curl -s -I "${TARGET}" | tr '[:upper:]' '[:lower:]' | grep -i "strict-transport-security")
        if [ -z "${HSTS_HEADER}" ]; then
            SCANNER+=",\"hsts\":false"
        else
            SCANNER+=",\"hsts\":true"
            local HSTS_MAX_AGE=$(echo "${HSTS_HEADER}" | grep -oP "max-age=\d+" | cut -d'=' -f2)
            local HSTS_INCLUDE_SUBDOMAINS=$(echo "${HSTS_HEADER}" | grep -oP "includeSubDomains")
            local HSTS_PRELOAD=$(echo "${HSTS_HEADER}" | grep -oP "preload")
            SCANNER+="$({
                echo -n ",\"maxAge\":${HSTS_MAX_AGE:-0}"
                echo -n ",\"includeSubDomains\":${HSTS_INCLUDE_SUBDOMAINS:-false}"
                echo -n ",\"preload\":${HSTS_PRELOAD:-false}"
            })"
            echo -n ",\"result\":["
            {
                if [ "${HSTS_MAX_AGE}" -lt 10886400 ]; then
                    echo -n "\"HSTS max-age is less than 10886400.\","
                fi
                if [ -z "${HSTS_INCLUDE_SUBDOMAINS}" ]; then
                    echo -n "\"HSTS includeSubDomains is not enabled.\","
                fi
                if [ -z "${HSTS_PRELOAD}" ]; then
                    echo -n "\"HSTS preload is not enabled.\","
                fi
            } | sed 's/,$//'
            echo -n "]"
        fi
    fi
    echo "${SCANNER}, \"end\":\"$(date +%s)\"}" | jq -c .
}
# </scanner.network.ywt.sh>
# <scanner.trivy.ywt.sh>
__scanner:trivy() {
    local DEFAULT_ARGS=(
        "--quiet"
        "--format" "sarif"
    )
    trivy:install(){
        curl -sfL https://raw.githubusercontent.com/aquasecurity/trivy/main/contrib/install.sh | sh -s -- -b /usr/local/bin
    }
    trivy:uninstall(){
        rm -f /usr/local/bin/trivy
    }
    trivy:cli() {
        __scanner:cli "trivy" "${DEFAULT_ARGS[@]}" "$@"
    }
    trivy:version() {
        trivy:cli --version
        return 0
    }
    trivy:metadata() {
        {
            echo -n "{"
            echo -n "\"uuid\":\"cbb46398-a79e-4afe-9672-badabf6075e7\","
            echo -n "\"capabilities\":[\"filesystem\"],"
            echo -n "\"features\":[\"code\", \"vulnerabilities\"],"
            echo -n "\"engines\":[\"host\",\"docker\"],"
            echo -n "\"formats\":[\"json\",\"sarif\"],"
            echo -n "\"priority\":1,"
            echo -n "\"tool\":{"
            echo -n "\"driver\":{"
            echo -n "\"name\":\"trivy\","
            echo -n "\"informationUri\":\"https://github.com/aquasecurity/trivy\","
            echo -n "\"version\":\"0.50.0\""
            echo -n "} }"
            echo -n "}"
        } | jq -c .
        return 0
    }
    trivy:activate() {
        echo "{}"
        return 0
    }
    trivy:result() {
        jq -c '.' "$1"
    }
    trivy:summary() {
        jq -c '
          .runs[].tool.driver.rules[] as $rules |
          .runs[].results[] |
          {
            RuleID: .ruleId,
            Severity: ($rules | select(.id == .ruleId) | .defaultConfiguration.level),
            Package: (.message.text | split("\n")[0]),
            InstalledVersion: (.message.text | split("\n")[1]),
            FixedVersion: (.message.text | split("\n")[4]),
            Link: (.message.text | split("\n")[5])
          }
        ' "$1"
    }
    trivy:asset(){
        local ASSET="${1//\\\"/\"}" && shift
        if ! __is json "$ASSET"; then
            echo "{\"error\":\"Invalid asset\"}"
            return 1
        fi
        case "$(jq -r '.type' <<<"$ASSET")" in
            docker:image)
                local DOCKER_IMAGE="$(jq -r '.target' <<<"$ASSET")"
                if [ -z "$DOCKER_IMAGE" ]; then
                    echo "{\"error\":\"Invalid image\"}"
                    return 1
                fi
                trivy:cli image "$DOCKER_IMAGE"
                return 0
                ;;
            repository)
                local REPOSITORY="$(jq -r '.target' <<<"$ASSET")"
                if [ ! -d "$REPOSITORY" ]; then
                    echo "{\"error\":\"Invalid repository path\"}"
                    return 1
                fi
                trivy:cli repository "/ywt-workdir$REPOSITORY"
                return 0
                ;;
            filesystem)
                local ASSET_PATH="$(jq -r '.target' <<<"$ASSET")"
                if [ ! -d "$ASSET_PATH" ]; then
                    echo "{\"error\":\"Invalid asset path\"}"
                    return 1
                fi
                trivy:cli fs "/ywt-workdir$ASSET_PATH"
                return 0
                ;;
            *)
                echo "{\"error\":\"Invalid asset type\"}"
                return 1
                ;;
        esac
    }
    local ACTION="$1" && shift
    __nnf "trivy:$ACTION" "$@"
    return $?
}
# </scanner.trivy.ywt.sh>
# <scanner.trufflehog.ywt.sh>
__scanner:trufflehog() {
    local DEFAULT_ARGS=(
        "--json"
    )
    trufflehog:install() {
        curl -sSfL https://raw.githubusercontent.com/trufflesecurity/trufflehog/main/scripts/install.sh | sh -s -- -b /usr/local/bin
    }
    trufflehog:uninstall() {
        rm -f /usr/local/bin/trufflehog
    }
    trufflehog:cli() {
        __scanner:cli "trufflehog" "${DEFAULT_ARGS[@]}" "$@"
    }
    trufflehog:version() {
        trufflehog:cli --version
        return 0
    }
    trufflehog:metadata() {
        {
            echo -n "{"
            echo -n "\"uuid\":\"cbb46398-a79e-4afe-9672-badabf6075e7\","
            echo -n "\"capabilities\":[\"filesystem\",\"repository\",\"docker:image\", \"bucket\"],"
            echo -n "\"features\":[\"secrets\"],"
            echo -n "\"engines\":[\"host\",\"docker\"],"
            echo -n "\"formats\":[\"json\",\"text\"],"
            echo -n "\"priority\":1,"
            echo -n "\"tool\":{"
            echo -n "\"driver\":{"
            echo -n "\"name\":\"trufflehog\","
            echo -n "\"informationUri\":\"https://github.com/trufflesecurity/trufflehog\","
            echo -n "\"version\":\"3.71.2\""
            echo -n "} }"
            echo -n "}"
        } | jq -c .
        return 0
    }
    trufflehog:activate() {
        echo "{}"
        return 0
    }
    trufflehog:result() {
        echo -n "["
        {
            while read -r LINE; do
                echo -n "$LINE"
                echo -n ","
            done <"$1"
        } | sed 's/,$//'
        echo -n "]"
    }
    trufflehog:summary() {
        echo -n "{}"
    }
    trufflehog:sarif() {
        local trufflehog_report="$1"
        local sarif_output="$2"
        jq -n --argfile findings "$trufflehog_report" '{
            "$schema": "https://json.schemastore.org/sarif-2.1.0.json",
            "version": "2.1.0",
            "runs": [
                {
                    "tool": {
                        "driver": {
                            "name": "TruffleHog",
                            "informationUri": "https://github.com/trufflesecurity/truffleHog"
                        }
                    },
                    "results": ($findings | map({
                        "ruleId": "secret-detected",
                        "level": "warning",
                        "message": {
                            "text": "Potential secret or sensitive information detected."
                        },
                        "locations": [
                            {
                                "physicalLocation": {
                                    "artifactLocation": {
                                        "uri": .path,
                                        "uriBaseId": "%SRCROOT%"
                                    },
                                    "region": {
                                        "startLine": .line_number
                                    }
                                }
                            }
                        ]
                    }))
                }
            ]
        }' >"$sarif_output"
    }
    trufflehog:asset(){
        local ASSET="${1//\\\"/\"}" && shift
        if ! __is json "$ASSET"; then
            echo "{\"error\":\"Invalid asset\"}"
            return 1
        fi
        case "$(jq -r '.type' <<<"$ASSET")" in
            docker:image)
                local DOCKER_IMAGE="$(jq -r '.target' <<<"$ASSET")"
                if [ -z "$DOCKER_IMAGE" ]; then
                    echo "{\"error\":\"Invalid image\"}"
                    return 1
                fi
                trufflehog:cli docker --image="$DOCKER_IMAGE"
                return 0
                ;;
            repository)
                local REPOSITORY_URL="$(jq -r '.target' <<<"$ASSET")"
                if [ -z "$REPOSITORY_URL" ]; then
                    echo "{\"error\":\"Invalid repository URL\"}"
                    return 1
                fi
                trufflehog:cli git "$REPOSITORY_URL"
                return 0
                ;;
            filesystem)
                local ASSET_PATH="$(jq -r '.target' <<<"$ASSET")"
                if [ ! -d "$ASSET_PATH" ]; then
                    echo "{\"error\":\"Invalid asset path\"}"
                    return 1
                fi
                trufflehog:cli filesystem "/ywt-workdir$ASSET_PATH"
                return 0
                ;;
            *)
                echo "{\"error\":\"Invalid asset type\"}"
                return 1
                ;;
        esac
    }
    local ACTION="$1" && shift
    __nnf "trufflehog:$ACTION" "$@"
    return $?
}
# </scanner.trufflehog.ywt.sh>
# <scanner.ywt.sh>
scanner() {
    __scanner:info() {
        if [ -n "$SCANNER_INFO" ]; then
            echo -n "$SCANNER_INFO" | jq -c .
            return 0
        fi
        local SCANNER_NAME="$1" && shift && SCANNER_NAME="${SCANNER_NAME,,}" && SCANNER_NAME="${SCANNER_NAME// /-}" && SCANNER_NAME="${SCANNER_NAME//./-}" && SCANNER_NAME="${SCANNER_NAME//:/-}" && SCANNER_NAME="${SCANNER_NAME//\//-}"
        local SCANNER_UID="$(mktemp -u -t XXXXXXXXXXXXXX -p /tmp)" && SCANNER_UID="$(basename "$SCANNER_UID")" && SCANNER_UID="${SCANNER_UID//./-}"
        local SCANNER_ID="$(echo -n "$SCANNER_NAME.$SCANNER_UID" | base64)"        
        local SCANNER_OUTPUT="/tmp/scanner-$SCANNER_UID.ywt"
        local SCANNER_INFO=$(jq -n \
            --arg name "$SCANNER_NAME" \
            --arg uid "$SCANNER_UID" \
            --arg id "$SCANNER_ID" \
            --arg output "$SCANNER_OUTPUT" \
            '{
                name: $name,
                uid: $uid,
                id: $id,
                output: $output
            }'
        )
        echo -n "$SCANNER_INFO" | jq -c .
        return 0
    }
    __scanner:list() {
        declare -F |
            grep -oP "__scanner:\K\w+" |
            jq -R . |
            jq -s . |
            jq -rc '
                map(
                    select(
                        . as $name |
                        "info list exists validate api activate validate registry inspect result  cli run definition network" |
                        split(" ") | 
                        map(select(. == $name)) | length == 0
                    )
                ) |
                sort |
                .[]                
            '
        return 0
    }
    __scanner:exists() {
        local SCANNER_NAME="$1" && shift
        __scanner:list | grep -q "$SCANNER_NAME" && return 0
        return 1
    }
    __scanner:validate:api() {
        local SCANNER_API=(cli version activate metadata result summary)
        {
            local SCANNER_API_IMPLEMENTED=true
            echo -n "{"
            for SCANNER_API in "${SCANNER_API[@]}"; do
                if ! __is function "${SCANNER_NAME}:${SCANNER_API}"; then
                    echo -n "\"${SCANNER_API}\":false,"
                    SCANNER_API_IMPLEMENTED=false
                else
                    echo -n "\"${SCANNER_API}\":true,"
                fi
            done
            echo -n "\"implemented\":$SCANNER_API_IMPLEMENTED"
            echo -n "}"
        }
    }
    __scanner:activate() {
        local SCANNER_NAME="$1" && shift
        if ! __scanner:exists "$SCANNER_NAME"; then
            echo -n "{"
            echo -n "\"error\":\"${SCANNER_NAME} not implemented\","
            echo -n "\"code\":100"
            echo -n "}"
            return 1
        elif ! __scanner:"${SCANNER_NAME}" activate >/dev/null 2>&1; then
            echo -n "{"
            echo -n "\"error\":\"${SCANNER_NAME} can't be activated\","
            echo -n "\"code\":101"
            echo -n "}"
            return 1
        else
            echo -n "{"
            echo -n "\"active\":true,"
            echo -n "\"enabled\":true,"
            echo -n "\"api\":" && __scanner:validate:api "$SCANNER_NAME" | jq -c .
            echo -n "}"
            return 0
        fi
    }
    __scanner:validate() {
        local SCANNER_NAME="$1" && shift
        local SCANNER_ACTIVATION=$(__scanner:activate "$SCANNER_NAME")
        jq -r .api.implemented <<<"$SCANNER_ACTIVATION" | grep -q false && {
            echo "$SCANNER_ACTIVATION" | jq -c '.error="API fully not implemented"'
            return 1
        }
        ! jq -r .error <<<"$SCANNER_ACTIVATION" | grep -q "null" && {
            echo "$SCANNER_ACTIVATION" | jq -c #'.state.error="Scanner not activated"'
            return 1
        }
        echo -n "$SCANNER_ACTIVATION" | jq -c ".valid=true"
        return 0
    }
    __scanner:registry() {
        {
            while read -r SCANNER_NAME; do
                echo -n "{"
                echo -n "\"header\":" && __scanner:info "$SCANNER_NAME" | jq -c .
                echo -n ","
                local SCANNER_VALIDATION=$(__scanner:validate "$SCANNER_NAME")
                echo -n "\"state\":" && echo -n "$SCANNER_VALIDATION" | jq -c .
                echo -n ","
                if jq -r .valid <<<"$SCANNER_VALIDATION" | grep -q true; then
                    echo -n "\"metadata\":" && __scanner:"${SCANNER_NAME}" metadata | jq -c .
                else
                    echo -n "\"metadata\":{}"
                fi
                echo -n "}"
            done < <(__scanner:list)
        } | jq -cs .
        return 0
    }
    __scanner:inspect() {
        local SCANNER_NAME="$1" && shift
        local SCANNER_DEFINITION=$({
            __scanner:registry | jq -c '
                map(
                    select(.state.valid == true) |
                    select(.header.name == "'"$SCANNER_NAME"'")
                )
                | .[0]
            '
        })
        if [ -z "$SCANNER_DEFINITION" ] || [ "$SCANNER_DEFINITION" == "null" ]; then
            {
                echo -n "{"
                echo -n "\"error\":\"${SCANNER_NAME} not found\","
                echo -n "\"code\":404"
                echo -n "}"
            } | jq -c .
            return 1
        fi
        echo -n "$SCANNER_DEFINITION" | jq -c .
        return 0
    }
    __scanner:result() {
        local SCANNER_NAME="$1" && shift
        local SCANNER_OUTPUT="$1" && shift
        {
            echo -n "{"
            if [ ! -f "$SCANNER_OUTPUT" ]; then
                echo -n "\"format\":\"text\","
                echo -n "\"content\":\"No output\","
            elif jq -e . "$SCANNER_OUTPUT" >/dev/null 2>&1; then
                echo -n "\"format\":\"json\","
                echo -n "\"content\":"
                __scanner:"${SCANNER_NAME}" result "$SCANNER_OUTPUT"
                echo -n ","
            else
                echo -n "\"format\":\"text\","
                local SCANNER_CONTENT="$(
                    {
                        cat "$SCANNER_OUTPUT"
                    } | sed 's/"/\\"/g' |
                        awk '{ printf "%s\\n", $0 }' |
                        awk '{ gsub("\t", "\\t", $0); print $0 }' |
                        sed 's/^/  /'
                )"
                echo -n "\"content\":\"$SCANNER_CONTENT\","
            fi
            echo -n "\"end\":$(date +%s)"
            echo -n "}"
        } | jq -c .
    }
    __scanner:cli() {
        local SCANNER_ARGS=()
        while [ $# -gt 0 ]; do
            case "$1" in
            -o | --output)
                local SCANNER_OUTPUT="$2"
                shift 2
                ;;
            *)
                SCANNER_ARGS+=("$1")
                shift
                ;;
            esac
        done
        set -- "${SCANNER_ARGS[@]}" && unset SCANNER_ARGS
        local SCANNER_METADATA="$1" && shift
        ! __is json "$SCANNER_METADATA" && SCANNER_METADATA="$(__scanner:inspect "$SCANNER_METADATA")"
        if [ -z "$SCANNER_METADATA" ] || [ "$SCANNER_METADATA" == "null" ] || [ "$(jq -r .error <<<"$SCANNER_METADATA")" != "null" ]; then
            echo "$SCANNER_METADATA" | jq -c . | logger error
            return 1
        fi
        local SCANNER_NAME="$(jq -r .header.name <<<"$SCANNER_METADATA")"
        local SCANNER_UID="$(jq -r .header.uid <<<"$SCANNER_METADATA")"
        [ -z "$SCANNER_OUTPUT" ] &&  local SCANNER_OUTPUT="$(jq -r .header.output <<<"$SCANNER_METADATA")"
        local DOCKER_ARGS=(
            "--rm"
            "--name" "ywt-scanners-${SCANNER_UID}"
            "-v" "$(pwd):/ywt-workdir"
            "-v" "/var/run/docker.sock:/var/run/docker.sock"
            "-v" "/tmp:/tmp"
            "ywt-sca:latest"
        )
        local SCANNER_ATTEMPTS=()
        local SCANNER_ENGINES=(host docker npx)
        for SCANNER_ENGINE in "${SCANNER_ENGINES[@]}"; do
            ! jq -r '.metadata.engines[]' <<<"$SCANNER_METADATA" | grep -c "$SCANNER_ENGINE" >/dev/null 2>&1 && continue
            if [ "$SCANNER_ENGINE" == "host" ] && __is command "$SCANNER_NAME"; then
                SCANNER_ENGINE="host"
                "$SCANNER_NAME" "$@" &>"$SCANNER_OUTPUT"
                break
            elif [ "$SCANNER_ENGINE" == "docker" ] && __is command docker; then
                SCANNER_ENGINE="docker"
                docker run "${DOCKER_ARGS[@]}" "$SCANNER_NAME" "$@" &>"$SCANNER_OUTPUT"
                break
            elif [ "$SCANNER_ENGINE" == "npx" ] && __is command npx; then
                SCANNER_ENGINE="npx"
                npx "$SCANNER_NAME" "$@" &>"$SCANNER_OUTPUT"
                break
            else
                SCANNER_ATTEMPTS+=("$SCANNER_ENGINE")
                continue
            fi
        done
        local SCANNER_EXIT_CODE=$?
        {
            echo -n "{"
            echo -n "\"engine\":\"$SCANNER_ENGINE\","
            echo -n "\"exit_code\":$SCANNER_EXIT_CODE,"
            echo -n "\"args\":\"$*\","
            echo -n "\"data\":$(__scanner:result "$SCANNER_NAME" "$SCANNER_OUTPUT"),"
            if [ "$SCANNER_EXIT_CODE" -ne 0 ]; then
                echo -n "\"error\":\"$SCANNER_ENGINE not found\""
            else
                echo -n "\"success\":true"
            fi
            echo -n "}"
        } | jq -c .
        return 0
    }
    __scanner:run() {
        local SCANNER_START_AT="$(date +%s)"
        local SCANNER_NAME="$1" && shift
        local SCANNER_METADATA=$(__scanner:inspect "$SCANNER_NAME")
        if [ -z "$SCANNER_METADATA" ] || [ "$SCANNER_METADATA" == "null" ] || [ "$(jq -r .error <<<"$SCANNER_METADATA")" != "null" ]; then
            echo "$SCANNER_METADATA" | jq -c . | logger error
            return 1
        fi
        local SCANNER_NAME="$(jq -r .header.name <<<"$SCANNER_METADATA")"
        local SCANNER_OUTPUT="$(jq -r .header.output <<<"$SCANNER_METADATA")"
        local SCANNER_RUN_OUTPUT="${SCANNER_OUTPUT//.ywt/.result}.ywt"
        {
            echo "$SCANNER_METADATA" #| jq -c .
            __scanner:"${SCANNER_NAME}" cli --output "$SCANNER_OUTPUT" "$@" #&>"$SCANNER_OUTPUT"
            __scanner:"${SCANNER_NAME}" summary "$SCANNER_OUTPUT"
        } >"$SCANNER_RUN_OUTPUT"
        jq -cs \ '
            .[0] as $metadata |
            .[1] as $result |
            .[2] as $summary |
            {
                scanner: $metadata,
                report: {
                    output: $metadata.header.output,
                    start: '"$SCANNER_START_AT"',
                    end: $result.data.end,
                    elapsed: ($result.data.end - '"$SCANNER_START_AT"'),
                    error: $result.error,
                    $result
                },
                summary: $summary
            }
        ' "$SCANNER_RUN_OUTPUT"
        return 0
    }
    __scanner:definition() {
        local SCANNER_NAME="$1" && shift
        local SCANNER_DEFINITION=$(__scanner:inspect "$SCANNER_NAME")
        if [ -z "$SCANNER_DEFINITION" ] || [ "$SCANNER_DEFINITION" == "null" ] || [ "$(jq -r .error <<<"$SCANNER_DEFINITION")" != "null" ]; then
            echo "$SCANNER_DEFINITION" | jq -c . | logger error
            return 1
        fi
        {
            echo -n "$SCANNER_DEFINITION"
            __scanner:"${SCANNER_NAME}" version "$@"
        } | jq -sc '
            {
                definition: .[0],
                version: .[1]
            }
        '
        return 0
    }
    inspect() {
        __scanner:definition "$@" | jq '.'
        return 0
    }
    list() {
        __scanner:registry | jq -c '
            del(.[].header.output)  |
            map(select(.state.valid == true))          
        '
        return 0
    }
    if ! __scanner:exists "$1"; then
        __nnf "$@" && return "$?"
    else 
        if [ "$2" == "asset" ]; then
            local SCANNER_NAME="$1" && shift
            __scanner:"${SCANNER_NAME}" "$@"
            return $?
        else 
            __scanner:run "$@" | jq .
            return 0
        fi
    fi
}
# </scanner.ywt.sh>
# <scap.ywt.sh>
scrap() {
    js() {
        __require curl
        if [ "$#" -ne 1 ]; then
            echo "Usage: $0 <URL>"
            return 1
        fi
        URL="$1"
        DOWNLOAD_DIR="./js_files"
        mkdir -p "$DOWNLOAD_DIR"
        HTML_CONTENT=$(curl -s "$URL")
        echo "$HTML_CONTENT" | grep -oE '<script src="([^"]+)"' | cut -d'"' -f2 | sort -u | while read -r JS_PATH; do
            if [[ "$JS_PATH" == http* ]]; then
                JS_URL="$JS_PATH"
            else
                JS_URL="${URL//\/[^\/]*\//$JS_PATH}"
            fi
            FILENAME=$(basename "$JS_PATH")
            FILEPATH="$DOWNLOAD_DIR/$FILENAME"
            echo "Downloading $JS_URL to $FILEPATH"
            curl -s "$JS_URL" -o "$FILEPATH"
        done
    }
    __nnf "$@" || usage "scrap" "$?" "$@"
}
(
    export -f scrap
)
# </scap.ywt.sh>
# <spinner.ywt.sh>
spinner() {
    local SPINNERS_TMP_FILE=/tmp/ywt-spinners.json
    __spinner:list() {
        if [[ -f "$SPINNERS_TMP_FILE" ]]; then
            jq -c . "$SPINNERS_TMP_FILE"
            return 0
        fi
        echo "Downloading spinners list..." | logger info
        curl -sL https://raw.githubusercontent.com/sindresorhus/cli-spinners/main/spinners.json >"$SPINNERS_TMP_FILE"
        jq -c . "$SPINNERS_TMP_FILE"
        return 0
    }
    __spinner:shutdown() {
        tput cnorm
    }
    __spinner:startup() {
        tput civis
    }
    __spinner:trap() {
        trap __spin:shutdown EXIT
        trap __spin:shutdown INT
        trap __spin:shutdown TERM
    }
    __spinner:cursor:back() {
        local N=${1:-1}
        echo -en "\033[${N}D"
    }
    names() {
        __spinner:list >/dev/null
        jq -r 'keys | .[]' "$SPINNERS_TMP_FILE" | tr '\n' ' '
    }
    random() {
        if [ "${#SPINNERS_LIST}" -eq 0 ]; then
            local SPINNERS_NAMES=($(names))
        else
            local SPINNERS_NAMES=("$@")
        fi
        local SPINNER_INDEX=$((RANDOM % ${#SPINNERS_NAMES[@]}))
        local SPINNER_NAME="${SPINNERS_NAMES[$SPINNER_INDEX]}"
        jq -r ".${SPINNER_NAME} | .name = \"${SPINNER_NAME}\"" "$SPINNERS_TMP_FILE"
    }
    spin() {
        local SPINNER=$(random)
        local SPINNER_NAME=$(jq -r '.name' <<<"$SPINNER")
        local SPINNER_FRAMES=($(jq -r '.frames | .[]' <<<"$SPINNER" | tr '\n' ' '))
        local SPINNER_INTERVAL=$(jq -r '.interval' <<<"$SPINNER")
        local SPINNER_LENGTH=${#SPINNER_FRAMES[@]}
        local SPINNER_INDEX=0
        local SPINNER_TARGET_PID=$1
        local SPINNER_MESSAGE="${2:-}"
        while ps a | awk '{print $1}' | grep -q "$SPINNER_TARGET_PID"; do
            local FRAME=${SPINNER_FRAMES[$SPINNER_INDEX]}
            printf " %s  %s\r" "$FRAME" "$SPINNER_MESSAGE"
            SPINNER_INDEX=$(((SPINNER_INDEX + 1) % SPINNER_LENGTH))
            sleep "$((SPINNER_INTERVAL / 500))"
            __spinner:cursor:back 1
            printf "\b\b\b\b\b\b"
        done
        printf "\b\b\b\b"
    }
    examples(){
        local COMMANDS=()
        local SPINNERS_NAMES=($(names))
        local SPINNER_INDEX=0
        for SPINNER_NAME in "${SPINNERS_NAMES[@]}"; do
            local MESSAGE="Spinner $SPINNER_NAME ${SPINNER_INDEX} of ${#SPINNERS_NAMES[@]}"
            echo "$MESSAGE" | logger info
            COMMANDS+=("sleep ${SPINNER_INDEX}; echo $MESSAGE")
            SPINNER_INDEX=$((SPINNER_INDEX + 1))
        done
        async "${COMMANDS[@]}"
    }
    __nnf "$@" || usage "$?" "spinner" "$@" && return 1
    return 0
}
# </spinner.ywt.sh>
# <spwan.ywt.sh>
spwan() {
    [ -z "$YWT_PIDS" ] && declare -a YWT_PIDS && readonly YWT_PIDS
    run() {
        local CMD="$*"
        $CMD &
        YWT_PIDS+=($!)
        echo $!
        return 0
    }
    __nnf "$@" || usage "spwan" "$?" "$@" && return 1
}
(
    export -f spwan
)
# </spwan.ywt.sh>
# <store.ywt.sh>
store() {
    __key() {
        [ -z "$1" ] && echo "" && return 1
        local KEY="${1// /_}" && KEY="${KEY//[^a-zA-Z0-9_]/_}"
        while [[ "$KEY" == _* ]]; do KEY="${KEY#_}"; done
        echo "${KEY^^}"
    }
    local ACTION="$1" && shift && [ -z "$ACTION" ] && ACTION="get"
    local KEY="$(__key "$1")" && shift && [ -z "$KEY" ] && logger error "store: key is required" && return 1    
    local VALUE="$1" && shift && [ -z "$VALUE" ] && VALUE="$(cat)" && [ -z "$VALUE" ] && logger error "store: value is required" && return 1
    local FILE="$1" && [ -z "$FILE" ] && FILE="$YWT_PATH_CACHE/.store"
    [ ! -f "$FILE" ] && touch "$FILE"
    case "$ACTION" in
    s | set)
        if ! grep -q "^$KEY=" "$FILE"; then
            echo "$KEY=$VALUE" >>"$FILE" && return 0
        else
            sed -i "s/^$KEY=.*/$KEY=$VALUE/" "$FILE" && return 0          
        fi
        ;;
    g | get)
        if grep -q "^$KEY=" "$FILE"; then
            VALUE=$(grep "^$KEY=" "$FILE" | cut -d'=' -f2)
            echo "$VALUE" && return 0
        fi
        ;;
    d | del | delete)
        if grep -q "^$KEY=" "$FILE"; then
            sed -i "/^$KEY=.*/d" "$FILE" && return 0
        fi
        ;;
    c | clear)
        rm -f "$FILE" && return 0
        ;;
    i | inspect)
        while IFS= read -r LINE; do
            IFS="=" read -r KEY VALUE <<<"$LINE" &&
            echo -n "$KEY=" && strings mask "$VALUE" && echo
        done <"$FILE" && return 0
        ;;
    *) usage "store" "Invalid action: $ACTION" "$@" && return 1 ;;
    esac
    return 1
}
(
    export -f store
)
# </store.ywt.sh>
# <strings.ywt.sh>
strings() {
    mask() {
        local STR="$1" && [ -z "$STR" ] && STR="$(cat)" && [ -z "$STR" ] && return 1
        local MASK="${2:-*}"
        local LENGTH="${#STR}"
        local MASK_LEN="${#MASK}"
        local MASKED=""
        for ((i = 0; i < LENGTH; i++)); do
            [ "$i" -lt 1 ] && MASKED+="${STR:i:1}" && continue
            [ "$i" -eq $((LENGTH - 1)) ] && MASKED+="${STR:i:1}" && continue
            MASKED+="${MASK:i%MASK_LEN:1}"
        done
        echo "$MASKED"
    }
    __nnf "$@" || usage "strings" "$?" "tests" "$@" && return 1
}
(
    export -f strings
)
# </strings.ywt.sh>
# <styles.ywt.sh>
styles() {
    YWT_LOG_CONTEXT="styles"
    apply() {
        local STYLE=${1:-bold} && STYLE=${STYLE,,}
        local TEXT=${2}
        local KIND=${3:-normal} && KIND=${KIND,,}
        [[ ! $KIND =~ ^(normal|italic|underline|blink|inverse|hidden)$ ]] && KIND=normal
        case $STYLE in
        bold) STYLE=1 ;;
        dim) STYLE=2 ;;
        italic) STYLE=3 ;;
        underline) STYLE=4 ;;
        blink) STYLE=5 ;;
        inverse) STYLE=7 ;;
        hidden) STYLE=8 ;;
        esac
        echo -e "\e[${STYLE}m${TEXT}\e[0m"
    }
    bold(){
        apply bold "$@"
    }
    dim(){
        apply dim "$@"
    }
    italic(){
        apply italic "$@"
    }
    underline(){
        apply underline "$@"
    }
    blink(){
        apply blink "$@"
    }
    inverse(){
        apply inverse "$@"
    }
    hidden(){
        apply hidden "$@"
    }
    __nnf "$@" || usage "styles" "$?"  "$@" && return 1
    return 0
}
(
    export -f styles
)
export NSTL=$'\033[24m' && readonly NSTL
export BOLD=$'\033[1m' && readonly BOLD
export DIM=$'\033[2m' && readonly DIM
export ITALIC=$'\033[3m' && readonly ITALIC
export UNDERLINE=$'\033[4m' && readonly UNDERLINE
export BLINK=$'\033[5m' && readonly BLINK
export INVERSE=$'\033[7m' && readonly INVERSE
export HIDDEN=$'\033[8m' && readonly HIDDEN
export STRICKETHROUGH=$'\033[9m' && readonly STRICKETHROUGH
export YWT_STYLE=(
    bold dim italic underline blink inverse hidden
) && readonly YWT_STYLE
# </styles.ywt.sh>
# <tcp.ywt.sh>
tcp() {
    request() {
        local HOST="${1}"
        local PORT="${2}"
        local DATA="${3}" # '{"key": "value"}'
        local REQUEST="$({
            echo "GET / HTTP/1.1"
            echo "Host: ${HOST}"
            echo "Connection: close"
            echo "User-Agent: curl/7.64.1"
            echo "Accept: */*"
            echo "Content-Type: application/json"
            echo "Content-Length: ${#DATA}"
            echo ""
            echo "${DATA}"        
        })"
        if __is command nc; then
            local RESPONSE=$(echo -e "${REQUEST}" | nc -w 3 "${HOST}" "${PORT}")
        elif __is command telnet; then
            local RESPONSE=$(echo -e "${REQUEST}" | telnet "${HOST}" "${PORT}")
        elif __is command bash; then
            exec 4<>/dev/tcp/"${HOST}"/"${PORT}"
            echo -e "${REQUEST}" >&4
            local RESPONSE=$(cat <&4)
            exec 4>&-
        else
            echo "No network tools found" | logger error
            return 1
        fi
        [ -z "${RESPONSE}" ] && echo "No response" | logger error && return 1
        echo "${RESPONSE}" && return 0        
    }
    __nnf "$@" || usage "tests" "$?" "$@" && return 1
}
(
    export -f tcp
)
# </tcp.ywt.sh>
# <tests.ywt.sh>
tests() {
    YWT_LOG_CONTEXT="TESTS"
    local TESTS=()
    local TESTS_DIR="$(jq -r '.tests' <<<"$YWT_PATHS")"
    local TMP_DIR="$(jq -r '.tmp' <<<"$YWT_PATHS")"
    local TEST_HELPER_DIR="${TESTS_DIR}/helpers" && [ ! -d "TEST_HELPER_DIR" ] && mkdir -p "${TEST_HELPER_DIR}"
    local SDK_DIR="$(jq -r '.sdk' <<<"$YWT_PATHS")"
    cleanup() {
        logger info "Cleaning up tests"
        rm -f -r "${TEST_HELPER_DIR}/bats"
        rm -f -r "${TEST_HELPER_DIR}/bats-assert"
        rm -f -r "${TEST_HELPER_DIR}/bats-support"
        rm -f -r "${TEST_HELPER_DIR}/bats-file"
        rm -f "/usr/local/bin/bats"
    }
    setup() {
        __require git tee
        [ "${1}" == true ] && cleanup
        [ ! -d "${TEST_HELPER_DIR}/bats" ] && logger info "getting bats" && git clone https://github.com/bats-core/bats-core.git "${TEST_HELPER_DIR}/bats" &>/dev/null && rm -fr "${TEST_HELPER_DIR}/bats/.git"
        [ ! -d "${TEST_HELPER_DIR}/bats-assert" ] && logger info "getting bats-assert" && git clone https://github.com/bats-core/bats-assert.git "${TEST_HELPER_DIR}/bats-assert" &>/dev/null && rm -fr "${TEST_HELPER_DIR}/bats-assert/.git"
        [ ! -d "${TEST_HELPER_DIR}/bats-support" ] && logger info "getting bats-support" && git clone https://github.com/bats-core/bats-support.git "${TEST_HELPER_DIR}/bats-support" &>/dev/null && rm -fr "${TEST_HELPER_DIR}/bats-support/.git"
        [ ! -d "${TEST_HELPER_DIR}/bats-file" ] && logger info "getting bats-file" && git clone https://github.com/bats-core/bats-file.git "${TEST_HELPER_DIR}/bats-file" &>/dev/null &
        rm -fr "${TEST_HELPER_DIR}/bats-file/.git"
        if ! command -v bats >/dev/null 2>&1; then
            logger info "installing bats"
            chmod -R +x "${TEST_HELPER_DIR}"
            "${TEST_HELPER_DIR}"/bats/install.sh /usr/local | tee /dev/null | logger debug
            bats --version | logger debug
        fi
        __require bats
    }
    _bats() {
        __require bats
        local BATS_VERSION=$(bats --version)
        logger info "Bats version: ${BATS_VERSION} ${TESTS_DIR}"
        local TEST_RESULT=$(
            bats --recursive \
                --no-tempdir-cleanup \
                --output "${TMP_DIR:-"/tmp"}" \
                --show-output-of-passing-tests \
                --print-output-on-failure \
                --jobs 100 \
                --timing \
                --tap \
                --formatter pretty \
                "${@}" \
                "${TESTS_DIR}"/*.bats 2>&1
        )
        local TEST_EXIT_CODE=$?
        logger info "Test exit code: ${TEST_EXIT_CODE}"
        logger info "Test result: ${TEST_RESULT}"
    }
    __copy_tests() {  
        __require find mktemp basename cp sed
        while IFS= read -r -d '' TEST; do
            local TEST_NAME=$(basename "${TEST}")
            local TEST_DEST=$(mktemp -u -t XXXXXXXX --suffix=".${TEST_NAME}" --tmpdir="${TESTS_DIR}")
            local TEST_FILE_NAME=$(basename "${TEST_DEST}") && TEST_FILE_NAME="unit.${TEST_FILE_NAME}"
            TEST_DEST="${TESTS_DIR}/${TEST_FILE_NAME}"
            cp -f "${TEST}" "${TEST_DEST}"
            {
                echo "
                   setup() {
                        load \"helpers/setup.sh\" && test_setup
                        FEATURE_DIR=\"\$(cd \"\$(dirname \"\$BATS_TEST_FILENAME\")\" >/dev/null 2>&1 && pwd)\"
                        PATH=\"\${FEATURE_DIR}:\${PATH}\" # add feature to PATH
                    }
                " | sed -e 's/^[[:space:]]*// ' -e 's/[[:space:]]*$//'
            } >>"${TEST_DEST}"
            TESTS+=("${TEST_DEST}")
        done < <(find "${SDK_DIR}" -type f -name "*.bats" -not -path "${TESTS_DIR}/*" -print0)
        return 0
    }
    unit() {
        __copy_tests
        local VERBOSE=false
        local TRACE=false
        while [[ $# -gt 0 ]]; do
            case $1 in
            -v | --verbose)
                VERBOSE=true
                shift
                ;;
            -t | --trace)
                TRACE=true
                shift
                ;;
            *) break ;;
            esac
        done
        [ "${VERBOSE}" == true ] && logger info "Running tests in verbose mode"
        [ "${TRACE}" == true ] && logger info "Running tests in trace mode"
        local ARGS=()
        [ "${VERBOSE}" == true ] && ARGS+=("--verbose-run")
        [ "${TRACE}" == true ] && ARGS+=("--trace")
        local LOG_MESSAGE="Running all tests"
        if [ $# -gt 0 ]; then
            local IFS=,
            local TAGS="${*}"
            ARGS+=("--filter-tags")
            ARGS+=("${TAGS}")
            LOG_MESSAGE="Running tests tags: ${TAGS}"
        fi
        logger info "${LOG_MESSAGE}"
        local START_TIME=$(date +%s)
        local RESULT && RESULT="$(_bats "${ARGS[@]}")"
        local EXIT_CODE=$?
        local END_TIME=$(date +%s)
        local ELAPSED_TIME=$((END_TIME - START_TIME))
        logger info "Test exit code: ${EXIT_CODE}"
        logger info "Test result:"
        __verbose "${RESULT}"
        local FAILURES=$(grep -Eo "0 failures" <<<"${RESULT}")
        rm -f "${TESTS[@]}"        
        if [ "${EXIT_CODE}" -eq 0 ] && [ -n "${FAILURES}" ]; then
            logger success "All tests passed, great job! (${ELAPSED_TIME} seconds)"
            return 0
        else
            logger error "Some tests failed, check the logs for more details (${ELAPSED_TIME} seconds)"
            return 1
        fi
    }
    case "$1" in
    cleanup) cleanup && return 0;;
    setup) setup && return 0;;
    unit) shift && setup false && unit "$@" && return 0;;
    *) __nnf "$@" || usage "tests" "$?" "$@" && return 1 ;;
    esac
}
# </tests.ywt.sh>
# <timezones.ywt.sh>
timezones() {
    current() {
        date +"%Z"
    }
    list() {
        [ -d /usr/share/zoneinfo/ ] && find /usr/share/zoneinfo/ -type f -printf '%P\n' | sed 's/\.\///' | sort && return 0
        __is command timedatectl && timedatectl | grep "Time zone" | awk '{print $3}' && return 0
        return 1
    }
    __nnf "$@" || usage "dates" "$?" "$@" && return 1
}
(
    export -f timezones
)
# </timezones.ywt.sh>
# <upm.ywt.sh>
upm(){
    install(){
        echo "install"
    }
    __nnf "$@" || usage "upm" "$?"  "$@" && return 1
}
(
    export -f upm
)
# </upm.ywt.sh>
# <user.ywt.sh>
user() {
    info() {
        local USER=$(whoami)
        local GROUP=$(id -gn)
        local USERID=$(id -u)
        local GROUPID=$(id -g)
        local HOME=~
        local SHELL="$SHELL"
        local SUDO=$(sudo -nv 2>&1 | grep "may run sudo" || true) && SUDO=${SUDO:-false}
        echo "{
            \"user\": \"$USER\",
            \"group\": \"$GROUP\",
            \"uid\": \"$USERID\",
            \"gid\": \"$GROUPID\",
            \"home\": \"$HOME\",
            \"shell\": \"$SHELL\",
            \"sudo\": \"$SUDO\"
        }"
    }
    runAsRoot() {
        local CMD="$*"
        if [ "$EUID" -ne 0 ] && [ "$YWT_CONFIG_USE_SUDO" = "true" ]; then
            CMD="sudo $CMD"
        fi
        $CMD
    }
    __nnf "$@" || usage "user" "$?" "$@" && return 1
}
(
    export -f user
)
# </user.ywt.sh>
# <vault.ywt.sh>
vault() {
    check() {
        if [ "$#" -ne 1 ]; then
            echo "Usage: $0 <URL>"
            exit 1
        fi
        URL="$1"
        DOWNLOAD_DIR="./js_files"
        mkdir -p "$DOWNLOAD_DIR"
        HTML_CONTENT=$(curl -s "$URL")
        echo "$HTML_CONTENT" | grep -oE '<script src="([^"]+)"' | cut -d'"' -f2 | sort -u | while read -r JS_PATH; do
            if [[ "$JS_PATH" == http* ]]; then
                JS_URL="$JS_PATH"
            else
                JS_URL=$(echo "$URL" | sed 's|/[^/]*$|/|')"$JS_PATH"
            fi
            FILENAME=$(basename "$JS_PATH")
            FILEPATH="$DOWNLOAD_DIR/$FILENAME"
            echo "Downloading $JS_URL to $FILEPATH"
            curl -s "$JS_URL" -o "$FILEPATH"
        done
    }
    __nnf "$@" || usage "vault" "$?"  "$@" && return 1
}
(
    export -f vault
)
# </vault.ywt.sh>
# <versions.ywt.sh>
versions() {
    semver(){
        echo "semver"
    }
    bump(){
        echo "bump"
    }
    compare(){
        echo "compare"
    }
    __nnf "$@" || usage "version" "$?"  "$@" && return 1
}
(
    export -f versions
)
# </versions.ywt.sh>
# <watcher.ywt.sh>
watcher() {
    dir() {
        __require find md5sum sort cmp mv
        WATCHED_DIR="/path/to/watched/dir"
        SNAPSHOT="/var/tmp/dir_snapshot.txt"
        TEMP_SNAPSHOT="/var/tmp/dir_snapshot_temp.txt"
        find "$WATCHED_DIR" -type f -exec md5sum {} + | sort >"$TEMP_SNAPSHOT"
        if [ -f "$SNAPSHOT" ]; then
            if ! cmp -s "$SNAPSHOT" "$TEMP_SNAPSHOT"; then
                echo "Change detected in $WATCHED_DIR at $(date)"
                mv "$TEMP_SNAPSHOT" "$SNAPSHOT"
            fi
        else
            echo "Initial snapshot of $WATCHED_DIR taken at $(date)"
            mv "$TEMP_SNAPSHOT" "$SNAPSHOT"
        fi
    }
    __nnf "$@" || usage "watcher" "$?"  "$@" && return 1
}
(
    export -f watcher
)
# </watcher.ywt.sh>
# <worker.ywt.sh>
worker() {
    local ENGINES=("system" "container" "pod" )    
    __node(){
        if ! __is command node; then
            echo "Node is not installed" | logger from_buf error
            return 1
        fi
        node --quiet --experimental-repl-await "$@"
    }
    __npx(){
        if ! __is command npx; then
            echo "Npx is not installed" | logger from_buf error
            return 1
        fi
        npx --quiet --yes "$@"
    }
    __zx(){        
        __npx zx "$@"
    }
    __python(){
        if ! __is command python3; then
            echo "Python3 is not installed" | logger from_buf error
            return 1
        fi
        python3 "$@"
    }
    __go(){
        if ! __is command go; then
            echo "Go is not installed" | logger from_buf error
            return 1
        fi
        go run "$@"    
    }
    __docker(){
        if ! __is command docker; then
            echo "Docker is not installed" | logger from_buf error
            return 1
        fi
        docker "$@"    
    }
    __compose(){
        if ! __is command docker-compose; then
            echo "Docker-compose is not installed" | logger from_buf error
            return 1
        fi
        docker-compose "$@"    
    
    }
    __k8s(){
        if ! __is command kubectl; then
            echo "Kubectl is not installed" | logger from_buf error
            return 1
        fi
        kubectl "$@"    
    }
    __helm(){
        if ! __is command helm; then
            echo "Helm is not installed" | logger from_buf error
            return 1
        fi
        helm "$@"    
    }
    __terraform(){
        if ! __is command terraform; then
            echo "Terraform is not installed" | logger from_buf error
            return 1
        fi
        terraform "$@"    
    }    
} 
(
    export -f worker
)
# </worker.ywt.sh>
# <./sdk/sdk.sh>
export YWT_SDK_FILE="${BASH_SOURCE[0]:-$0}" && readonly YWT_SDK_FILE
sdk() {
    set -e -o pipefail
    ___create_unit_tests() {
        while read -r FILE; do
            local FILE_REALPATH=$(realpath -- "$FILE") && [ ! -f "$FILE_REALPATH" ] && continue
            local FILE_DIR=$(dirname -- "$FILE_REALPATH")
            local FILE_NAME && FILE_NAME=$(basename -- "$FILE_REALPATH") && FILE_NAME="${FILE_NAME%.*}" && FILE_NAME=$(echo "$FILE_NAME" | tr '[:upper:]' '[:lower:]')
            local LIB_NAME="${FILE_NAME%.*}" && LIB_NAME="${LIB_NAME//-/:}" && LIB_NAME="${LIB_NAME//_/:}" && LIB_NAME="${LIB_NAME//./:}" && LIB_NAME="${LIB_NAME// /:}" && LIB_NAME="${LIB_NAME//-/:}"
            local TEST_NAME="${LIB_NAME//:/-}" && TEST_NAME="${TEST_NAME//_/-}" && TEST_NAME="${TEST_NAME// /-}"
            local TEST_FILE="$FILE_DIR/${LIB_NAME}.bats" && TEST_FILE="${TEST_FILE//:/-}" && TEST_FILE="${TEST_FILE//_/-}" && TEST_FILE="${TEST_FILE// /-}"
            local CMD_NAME="${TEST_NAME//:/-}" && CMD_NAME="${CMD_NAME//_/-}" && CMD_NAME="${CMD_NAME// /-}"
            [ -f "$TEST_FILE" ] && continue
            {
                echo "#!/usr/bin/env bats"
                echo "# bats file_tags=${TEST_NAME}"
                echo
                echo "# LIB_NAME=${LIB_NAME}"
                echo "# FILE_REALPATH=${FILE_REALPATH}"
                echo "# FILE_DIR=${FILE_DIR}"
                echo "# FILE_NAME=${FILE_NAME}"
                echo "# TEST_FILE=${TEST_FILE}"
                echo "# TEST_NAME=${TEST_NAME}"
                echo "# CMD_NAME=${CMD_NAME}"
                echo "# bats test_tags=${TEST_NAME}, usage"
                echo "@test \"ydk ${TEST_NAME} should be called\" {"
                echo "  run ydk ${CMD_NAME}"
                echo "  test_report"
                echo "  assert_success \"${LIB_NAME} should be called\""
                echo "  assert_output --partial \"Available functions\""
                echo "  assert_output --partial \"YWT Usage\""
                echo "}"
            } >"$TEST_FILE"
            echo "Created $TEST_FILE" | logger info
        done < <(find "$(jq -r '.lib' <<<"$YWT_PATHS")" -type f -name "*.ywt.sh" | sort)
        return 0
    }
    __rename_bats_tests() {
        while read -r FILE; do
            local DEST="${FILE%.*}.bat"
            mv -f "$FILE" "$DEST"
            echo "Moved $FILE, to ${DEST}" | logger info
        done < <(find "$(jq -r '.lib' <<<"$YWT_PATHS")" -type f -name "*.bats" | sort)
    }
    __teardown() {
        __debug "__teardown"
        [ -p "$YWT_DEBUG_FIFO" ] && rm -f "$YWT_DEBUG_FIFO" 2>/dev/null
        [ -p "$YWT_LOGGER_FIFO" ] && rm -f "$YWT_LOGGER_FIFO" 2>/dev/null
        [ -p "$YWT_TRACE_FIFO" ] && rm -f "$YWT_TRACE_FIFO" 2>/dev/null
        [ -p "$YWT_OUTPUT_FIFO" ] && rm -f "$YWT_OUTPUT_FIFO" 2>/dev/null
    }
    __fail() {
        __log "__fail"
        local RESULT=${1:$?} && shift
        [[ "$RESULT" -eq 0 ]] && return 0
        local MESSAGE=${1:-"An error occurred"} && shift
        local ERROR && ERROR=$(jq -n --arg result "$RESULT" --arg message "$MESSAGE" --arg caller "${FUNCNAME[*]}" --arg args "$* ($!)" '{result: $result, message: $message, caller: $caller, args: $args}')
        __log error "$ERROR"
        __teardown
        kill -s EXIT $$ 2>/dev/null
    }
    export YWT_LOG_DEFAULT_CONTEXT="ywt" && readonly YWT_LOG_DEFAULT_CONTEXT
    export YWT_LOG_CONTEXT="$YWT_LOG_DEFAULT_CONTEXT"
    local YWT_CMD_NAME="$YWT_LOG_DEFAULT_CONTEXT" && readonly YWT_CMD_NAME
    local YWT_INITIALIZED=false
    local YWT_DEBUG=${YWT_CONFIG_DEBUG:-false}
    local YWT_MISSING_DEPENDENCIES=()
    local YWT_LOGS=()
    local YWT_POSITIONAL=()
    __etime() {
        if grep -q 'Alpine' /etc/os-release; then
            ps -o etime= "$$" | awk -F "[:]" '{ print ($1 * 60) + $2 }' | head -n 1
        else
            ps -o etime= -p "$$" | sed -e 's/^[[:space:]]*//' | sed -e 's/\://' | head -n 1
        fi
    }
    __debug() {
        [ -z "$YWT_DEBUG" ] || [ "$YWT_DEBUG" == false ] && return 0
        [ -z "$*" ] && return 0
        [ ! -p "$YWT_DEBUG_FIFO" ] && return 0
        __is "function" "debug" && debug "${*}" && return 0
        local MESSAGE=(
            "${YELLOW}[${YWT_CMD_NAME^^}]"
            "${DARK_GRAY}[$$]"
            "${BLUE}[$(date +"%Y-%m-%d %H:%M:%S")]"
            "${CYAN}[DEBUG]"
            "${PURPLE}[${YWT_LOG_CONTEXT^^}]🐞"
            "${WHITE}${*}"
            "${DARK_GRAY}[$(__etime)]"
            "${NC}"
        )
        (echo "${MESSAGE[*]}" >"$YWT_DEBUG_FIFO") &
        true
    }
    __require() {
        local DEPENDENCIES=("$@")
        for DEPENDENCY in "${DEPENDENCIES[@]}"; do
            if ! __is command "${DEPENDENCY}"; then
                __debug "required ${DEPENDENCY} (command not found)" &&
                    YWT_MISSING_DEPENDENCIES+=("${DEPENDENCY}")
            fi
        done
        [ "${#YWT_MISSING_DEPENDENCIES[@]}" -eq 0 ] && return 0
        local MSG="Missing dependencies: ${YWT_MISSING_DEPENDENCIES[*]}"
        __is "function" "logger" && logger error "$MSG" && exit 255
        __debug "$MSG" && __verbose "$MSG"
        exit 255
    }
    __verbose() {
        echo "$1" 1>&2
    }
    __stdin() {
        [ ! -p /dev/stdin ] && [ ! -t 0 ] && return "$1"
        while IFS= read -r INPUT; do
            echo "$INPUT"
        done
        unset INPUT
    }
    __log() {
        __is "function" "logger" && logger "$@" && return $?
        __debug "$@" && return $?
    }
    __is() {
        case "$1" in
        not-defined)
            [ -z "$2" ] && return 0
            [ "$2" == "null" ] && return 0
            ;;
        defined)
            [ -n "$2" ] && return 0
            [ "$2" != "null" ] && return 0
            ;;
        rw)
            [ -r "$2" ] && [ -w "$2" ] && return 0
            ;;
        owner)
            [ -O "$2" ] && return 0
            ;;
        writable)
            [ -w "$2" ] && return 0
            ;;
        readable)
            [ -r "$2" ] && return 0
            ;;
        executable)
            [ -x "$2" ] && return 0
            ;;
        nil)
            [ -z "$2" ] && return 0
            [ "$2" == "null" ] && return 0
            ;;
        number)
            [ -n "$2" ] && [[ "$2" =~ ^[0-9]+$ ]] && return 0
            ;;
        string)
            [ -n "$2" ] && [[ "$2" =~ ^[a-zA-Z0-9_]+$ ]] && return 0
            ;;
        boolean)
            [ -n "$2" ] && [[ "$2" =~ ^(true|false)$ ]] && return 0
            ;;
        date)
            [ -n "$2" ] && [[ "$2" =~ ^[0-9]{4}-[0-9]{2}-[0-9]{2}$ ]] && return 0
            ;;
        url)
            [ -n "$2" ] && [[ "$2" =~ ^https?:// ]] && return 0
            ;;
        json)
            jq -e . <<<"$2" >/dev/null 2>&1 && return 0
            ;;
        fnc | function)
            local TYPE="$(type -t "$2")"
            [ -n "$TYPE" ] && [ "$TYPE" = function ] && return 0
            ;;
        cmd | command)
            command -v "$2" >/dev/null 2>&1 && return 0
            ;;
        f | file)
            [ -f "$2" ] && return 0
            ;;
        d | dir)
            [ -d "$2" ] && return 0
            ;;
        esac
        return 1
    }
    __functions() {
        if [ -f "${1}" ]; then
            local FUNC_LIST=$(
                grep -E '^\s*(function\s+)?[a-zA-Z_][a-zA-Z0-9_]*\s*\(\)' "${1}" | awk '{print $1}' | sort | tr '\n' ' ' | sed -e 's/()//g' -e 's/ $//'
            )
            [ "$2" == true ] && FUNC_LIST+=" $(declare -F | awk '{print $3}')"
            FUNC_LIST=$(echo "${FUNC_LIST}" | tr ' ' '\n' | sort | uniq | tr '\n' ' ' | sed -e 's/ $//')
        else
            local FUNC_LIST=$(declare -F | awk '{print $3}')
        fi
        local RESULT=()
        for FUNC in $FUNC_LIST; do
            [[ "$FUNC" == _* ]] && continue
            [[ "$FUNC" == bats_* ]] && continue
            [[ "$FUNC" == batslib_* ]] && continue
            [[ "$FUNC" == assert_* ]] && continue
            RESULT+=("$FUNC")
        done
        echo "${RESULT[*]}" | sed -e 's/ /\n/g' | grep -v '^_' | sort | tr '\n' ' ' | sed -e 's/ $//' | sed -e 's/ /, /g'
    }
    __libraries() {
        [ ! -d "${1}" ] && echo "{}" && return 0
        local JSON="{" && local FIRST=true
        while read -r FILE; do
            local FILE_NAME && FILE_NAME=$(basename -- "$FILE") && FILE_NAME="${FILE_NAME%.*}" && FILE_NAME=$(echo "$FILE_NAME" | tr '[:upper:]' '[:lower:]')
            local LIB_NAME="${FILE_NAME%.*}" && LIB_NAME="${LIB_NAME//-/:}" && LIB_NAME="${LIB_NAME//_/:}" && LIB_NAME="${LIB_NAME//./:}" && LIB_NAME="${LIB_NAME// /:}" && LIB_NAME="${LIB_NAME//-/:}"
            [ "$FIRST" == true ] && FIRST=false || JSON+=","
            JSON+="\"$LIB_NAME\": {\"entrypoint\": \"${LIB_NAME}\", \"name\":\"${FILE_NAME}\",\"src\":\"${FILE}\",\"methods\":["
            local METHODS=$(__functions "$FILE" false) && [ -z "$METHODS" ] && METHODS=""
            IFS=',' read -r -d '' -a METHODS <<<"$METHODS"
            for FUNC in "${METHODS[@]}"; do
                FUNC=$(echo "$FUNC" | tr -d '\n' | tr -d '\r' | tr -d '\t' | tr -d ' ') && FUNC="${FUNC//\{/}"
                [[ "$FUNC" == _* ]] && continue
                [[ "$FUNC" == bats_* ]] && continue
                [[ "$FUNC" == batslib_* ]] && continue
                [[ "$FUNC" == assert_* ]] && continue
                JSON+="\"$FUNC\","
            done
            JSON+="\"usage\"]}"
        done < <(find "${1}" -type f -name "*.ywt.sh" | sort)
        JSON+="}"
        echo "$JSON" | jq -C .
    }
    __ioc() {
        __resolve() {
            local FILE="${1:-}" && [ ! -f "$FILE" ] && return 1
            local FILE_NAME && FILE_NAME=$(basename -- "$FILE") && FILE_NAME="${FILE_NAME%.*}" && FILE_NAME=$(echo "$FILE_NAME" | tr '[:upper:]' '[:lower:]')
            __is function "$FILE_NAME" && return 0
            __debug "Sourcing ${FILE_NAME} $FILE"
            source "$FILE" && return 0
        }
        __inject() {
            local LIB="${1:-}" && [ ! -d "$LIB" ] && return 1
            __debug "Injecting $LIB"
            while read -r FILE; do
                [[ "$FILE" = *"ioc.ywt.sh" ]] && continue
                __resolve "$FILE"
            done < <(find "$LIB" -type f -name "*.ywt.sh" | sort)
            return 0
        }
        __lib() {
            local TARGET="${1:-"$(jq -r '.lib' <<<"$YWT_PATHS")"}" && [ ! -d "$TARGET" ] && return 0
            __inject "$TARGET"
        }
        __extension() {
            local TARGET="${1:-"$(jq -r '.extensions' <<<"$YWT_PATHS")"}" && [ ! -d "$TARGET" ] && return 0
            __inject "$TARGET"
        }
        __nnf() {
            local FUNC=${1} && [ -z "$FUNC" ] && return 1
            FUNC=${FUNC#_} && FUNC=${FUNC#__} && FUNC="${FUNC//_/-5f}" && FUNC="${FUNC//-/-2d}" && FUNC="${FUNC// /_}"
            local ARGS=("${@:2}") # local ARGS=("${@}")
            if __is function "$FUNC"; then
                local START_TIME=$(date +%s)
                exec 3>&1
                trap 'exec 3>&-' EXIT
                local STATUS
                if [[ "$FUNC" != *logger* ]] && [ -p "$YWT_OUTPUT_FIFO" ]; then
                    $FUNC "${ARGS[@]}" 1>&3
                else
                    $FUNC "${ARGS[@]}" 1>&3
                fi
                local END_TIME=$(date +%s)
                local ELAPSED_TIME=$((END_TIME - START_TIME))
                STATUS=$?
                [ "$STATUS" -eq 0 ] && STATUS=success || STATUS=error
                __debug "Function $FUNC status: $STATUS, in ${ELAPSED_TIME} seconds" # 1>&2
                exec 3>&-
                return 0
            else
                __log error "Function $FUNC not found"
                return 1
            fi
        }
        case "$1" in
        resolve) __resolve "${@:2}" && return 0 ;;
        inject) __inject "${@:2}" && return 0 ;;
        lib) __lib "${@:2}" && return 0 ;;
        extension) __extension "${@:2}" && return 0 ;;
        nff) __nnf "${@:2}" && return $? ;;
        *) usage "$?" "ioc" "$@" && return 1 ;;
        esac
    }
    __paths() {
        [ -n "$YWT_PATHS" ] && echo "$YWT_PATHS" | jq -c . && return 0
        local CMD && CMD=$(cd "$(dirname "${YWT_SDK_FILE}")" && pwd) && readonly CMD
        local SDK="${CMD}"
        local PROJECT && PROJECT=$(dirname -- "$SDK") && PROJECT=$(realpath -- "$PROJECT") && readonly PROJECT
        local WORKSPACE && WORKSPACE=$(dirname -- "$PROJECT") && WORKSPACE=$(realpath -- "$WORKSPACE") && readonly WORKSPACE
        local TMP="${YWT_CONFIG_PATH_TMP:-"$(dirname -- "$(mktemp -d -u)")"}/${YWT_CMD_NAME}"
        export YWT_PATHS=$(
            {
                echo -n "{"
                echo -n "\"cmd\":\"$CMD\","
                echo -n "\"workspace\":\"$WORKSPACE\","
                echo -n "\"project\":\"$PROJECT\","
                echo -n "\"sdk\":\"$SDK\"",
                echo -n "\"lib\":\"$SDK/lib\"",
                echo -n "\"src\":\"$PROJECT/src\"",
                echo -n "\"extensions\":\"$PROJECT/extensions\"",
                echo -n "\"packages\":\"$PROJECT/packages\"",
                echo -n "\"scripts\":\"$PROJECT/scripts\"",
                echo -n "\"tools\":\"$PROJECT/tools\"",
                echo -n "\"cli\":\"$PROJECT/cli\"",
                echo -n "\"apps\":\"$PROJECT/apps\"",
                echo -n "\"tests\":\"$PROJECT/tests\"",
                echo -n "\"bin\":\"$PROJECT/bin\"",
                echo -n "\"dist\":\"$PROJECT/dist\"",
                echo -n "\"tmp\":\"$TMP\"",
                echo -n "\"logs\":\"${YWT_CONFIG_PATH_LOGS:-"/var/log/$YWT_CMD_NAME"}\"",
                echo -n "\"cache\":\"${YWT_CONFIG_PATH_CACHE:-"/var/cache/${YWT_CMD_NAME}"}\"",
                echo -n "\"data\":\"${YWT_CONFIG_PATH_DATA:-"/var/lib/$YWT_CMD_NAME"}\"",
                echo -n "\"etc\":\"${YWT_CONFIG_PATH_ETC:-"/etc/$YWT_CMD_NAME"}\"",
                echo -n "\"pwd\":\"${YWT_CONFIG_PATH_CWD:-"${PWD}"}\""
                echo -n "}"
                echo ""
            }
        ) && readonly YWT_PATHS
        echo "$YWT_PATHS" | jq -c . #| sed -e 's/\\//g'
    }
    __argv() {
        [ -n "$YWT_FLAGS" ] && echo "$YWT_FLAGS" | jq -c . && return 0
        YWT_POSITIONAL=()
        export YWT_FLAGS=$(
            {
                local JSON="{" && local FIRST=true
                while [[ $# -gt 0 ]]; do
                    local FLAG="$1"
                    [[ "$FLAG" != --* ]] && [[ "$FLAG" != -* ]] && YWT_POSITIONAL+=("$1") && shift && continue
                    local KEY=${FLAG#--} && KEY=${KEY#-} && KEY=${KEY%%=*} && KEY=${KEY%%:*}
                    local VALUE=${FLAG#*=} && VALUE=${VALUE#*:} && VALUE=${VALUE#*=} && VALUE=${VALUE#--} && VALUE=${VALUE#-}
                    [ "$KEY" == "$VALUE" ] && VALUE=true
                    [ -z "$VALUE" ] && VALUE=true
                    [ "$FIRST" == true ] && FIRST=false || JSON+=","
                    JSON+="\"$KEY\":\"$VALUE\"" && shift
                done
                JSON+="}"
                echo "$JSON"
            }
        ) # && readonly YWT_FLAGS
        echo "$YWT_FLAGS" | jq -c .
    }
    __params() {
        [ -n "$YWT_PARAMS" ] && echo "$YWT_PARAMS" | jq -c . && return 0
        YWT_POSITIONAL=()
        export YWT_PARAMS=$({
            local JSON="{" && local FIRST=true
            while [[ $# -gt 0 ]]; do
                local PARAM="$1"
                [[ "$PARAM" != kv=* ]] && YWT_POSITIONAL+=("$1") && shift && continue
                local KEY=${PARAM#kv=} #&& KEY=${KEY#p=} # && KEY=${KEY#param} && KEY=${KEY#p}
                local VALUE=${KEY#*:} && VALUE=${VALUE#*:} && VALUE=${VALUE#=}
                KEY=${KEY%%:*}
                [ "$KEY" == "$VALUE" ] && VALUE=true
                [ -z "$VALUE" ] && VALUE=true
                [ "$FIRST" == true ] && FIRST=false || JSON+=","
                JSON+="\"$KEY\":\"$VALUE\"" && shift
            done
            JSON+="}"
            echo "$JSON"
        }) && readonly YWT_PARAMS
        echo "$YWT_PARAMS" | jq -c .
    }
    __flags() {
        YWT_POSITIONAL=()
        while [[ $# -gt 0 ]]; do
            case "$1" in
            -q | --quiet)
                export YWT_QUIET=true && readonly YWT_QUIET
                shift
                ;;
            -t | --trace)
                local VALUE=$(jq -r '.trace' <<<"$YWT_FLAGS")
                [ "$VALUE" == "null" ] && shift && continue
                [ "$VALUE" == true ] && VALUE="/tmp/ywt.trace"
                [ -p "$VALUE" ] && rm -f "$VALUE"
                export YWT_TRACE_FIFO="$VALUE"
                [ ! -p "$YWT_TRACE_FIFO" ] && mkfifo "$YWT_TRACE_FIFO" && readonly YWT_TRACE_FIFO
                YWT_LOGS+=("Trace FIFO enabled. In another terminal use 'tail -f $YWT_TRACE_FIFO' to watch logs or 'rapd debugger trace watch $YWT_TRACE_FIFO'.")
                YWT_FLAGS=$(jq -n --argjson flags "$YWT_FLAGS" --arg trace "$VALUE" '$flags | .trace=$trace')
                shift
                ;;
            -l | --logger)
                local VALUE=$(jq -r '.logger' <<<"$YWT_FLAGS")
                [ "$VALUE" == "null" ] && shift && continue
                [ "$VALUE" == true ] && VALUE="/tmp/ywt.logger"
                [ -p "$YWT_LOGGER_FIFO" ] && rm -f "$YWT_LOGGER_FIFO"
                export YWT_LOGGER_FIFO="$VALUE"
                [ ! -p "$YWT_LOGGER_FIFO" ] && mkfifo "$YWT_LOGGER_FIFO" && readonly YWT_LOGGER_FIFO
                YWT_LOGS+=("Logger FIFO enabled. In another terminal use 'tail -f $YWT_LOGGER_FIFO' to watch logs or 'rapd logger watch $YWT_LOGGER_FIFO'.")
                YWT_FLAGS=$(jq -n --argjson flags "$YWT_FLAGS" --arg logger "$VALUE" '$flags | .logger=$logger')
                shift
                ;;
            -d | --debug)
                [ "$YWT_DEBUG" == true ] && shift && continue
                YWT_DEBUG=true && readonly YWT_DEBUG
                local VALUE=$(jq -r '.debug' <<<"$YWT_FLAGS")
                [ "$VALUE" == "null" ] && shift && continue
                [ "$VALUE" == true ] && VALUE="/tmp/ywt.debugger"
                [ -p "$YWT_DEBUG_FIFO" ] && rm -f "$YWT_DEBUG_FIFO"
                export YWT_DEBUG_FIFO="$VALUE"
                [ ! -p "$YWT_DEBUG_FIFO" ] && mkfifo "$YWT_DEBUG_FIFO" && readonly YWT_DEBUG_FIFO
                YWT_LOGS+=("Debug enabled. In another terminal use 'tail -f $YWT_DEBUG_FIFO' to watch logs or 'rapd debugger watch $YWT_DEBUG_FIFO'.")
                YWT_FLAGS=$(jq -n --argjson flags "$YWT_FLAGS" --arg debug "$VALUE" '$flags | .debug=$debug')
                shift
                ;;
            -o | --output)
                local VALUE=$(jq -r '.output' <<<"$YWT_FLAGS")
                [ "$VALUE" == "null" ] && shift && continue
                [ "$VALUE" == true ] && VALUE="/tmp/ywt.output"
                [ -p "$VALUE" ] && rm -f "$VALUE"
                export YWT_OUTPUT_FIFO="$VALUE"
                [ ! -p "$YWT_OUTPUT_FIFO" ] && mkfifo "$YWT_OUTPUT_FIFO" && readonly YWT_OUTPUT_FIFO
                YWT_LOGS+=("Output FIFO enabled. In another terminal use 'tail -f $YWT_OUTPUT_FIFO' to watch logs or 'rapd output watch $YWT_OUTPUT_FIFO'.")
                YWT_FLAGS=$(jq -n --argjson flags "$YWT_FLAGS" --arg output "$VALUE" '$flags | .output=$output')
                shift
                ;;
            -p* | --param*)
                shift
                ;;
            *)
                YWT_POSITIONAL+=("$1")
                shift
                ;;
            esac
        done
        readonly YWT_FLAGS
        return 0
    }
    __bootstrap() {
        [ "$YWT_INITIALIZED" == true ] && return 0
        YWT_INITIALIZED=true && readonly YWT_INITIALIZED
        __require jq sed grep sort tr
        __ioc lib "$(jq -r '.lib' <<<"$YWT_PATHS")"
        __ioc extension "$(jq -r '.extensions' <<<"$YWT_PATHS")"
        [ -z "$YWT_APPINFO" ] && local YWT_APPINFO && YWT_APPINFO=$(ywt:info package) && readonly YWT_APPINFO
        [ -z "$YWT_PROCESS" ] && local YWT_PROCESS && YWT_PROCESS=$(process info) && readonly YWT_PROCESS
        local DOTENV_FILE=$(jq -r '.project' <<<"$YWT_PATHS")/.env
        [ -f "$DOTENV_FILE" ] && export YWT_DOTENV && YWT_DOTENV=$(dotenv load "$DOTENV_FILE") && readonly YWT_DOTENV
        [ -z "$YWT_DOTENV" ] && local YWT_DOTENV && YWT_DOTENV="{}" && readonly YWT_DOTENV
        export YWT_CONFIG && YWT_CONFIG=$(
            jq -n \
                --argjson package "$YWT_APPINFO" \
                --argjson path "$YWT_PATHS" \
                --argjson process "$YWT_PROCESS" \
                --argjson env "$YWT_DOTENV" \
                --argjson flags "$YWT_FLAGS" \
                --argjson params "$YWT_PARAMS" \
                '{yellowteam: $package, path: $path, process: $process, env: $env, flags: $flags, params: $params}'
        ) && readonly YWT_CONFIG
        __debug "Package Info $(jq -C .yellowteam <<<"$YWT_CONFIG")"
        __debug "Paths $(jq -C .path <<<"$YWT_CONFIG")"
        __debug "Process $(jq -C .process <<<"$YWT_CONFIG")"
        __debug "Dotenv $(jq -C .env <<<"$YWT_CONFIG")"
        __debug "Flags $(jq -C .flags <<<"$YWT_CONFIG")"
        __debug "Params $(jq -C .params <<<"$YWT_CONFIG")"
        ywt:info welcome
        for LOG in "${YWT_LOGS[@]}"; do logger info "$LOG"; done
        return 0
    }
    inspect() {
        logger info "inspect $#"
        jq -r '.' <<<"$YWT_CONFIG"
        YWT_LOG_CONTEXT="inspect"
        local PARAMS=$({
            param kv -r -n key -- \
                --required --name key2 -- \
                --default value --required --name key3 -- \
                --default value --required --name key4 -- \
                --type number --default "fd1" --required --name key5 -- \
                --message "custom message" --type number --default 1 --required --name key6 -- \
                --required --name flag-value -- \
                --required --name flag -- \
                --default '{}' --type json --required --name jsons -- \
                --default "{}" --type json --required --name jsons2
        })
        if ! param validate "$PARAMS"; then return 1; fi
        echo "$PARAMS" | jq -C .
    }
    usage() {
        local ERROR_CODE=${1:-0} && shift
        local CONTEXT=${1:-} && [ -z "$CONTEXT" ] && CONTEXT=""
        local CONTEXT_PATH=$(jq -r ".lib" <<<"$YWT_PATHS")
        local CONTEX_FILE=$(find "$CONTEXT_PATH" -type f -name "${CONTEXT}.ywt.sh" | head -n 1) && [ ! -f "$CONTEX_FILE" ] && CONTEX_FILE="${YWT_SDK_FILE}"
        local FUNC_LIST="" # && FUNC_LIST=$(__functions "$CONTEX_FILE" true)
        [ -z "$*" ] && return 0
        local ARGS=("${@:2}")
        [ -n "${ARGS[0]}" ] && ARGS[0]="${RED}${UNDERLINE}${ARGS[0]}${NC}${NSTL}"
        __log info "(${RED}$ERROR_CODE${NC}) ${YELLOW}YWT Usage${NC}: ${YELLOW}ydk ${GREEN}$CONTEXT${NC} (${ARGS[*]}${NC}) ${CYAN}${#ARGS[@]} length${NC}"
        __log info "Available functions: " #| logger info # (${YELLOW}${FUNC_LIST}${NC})" | logger info
        for FUNC in $FUNC_LIST; do
            [[ "$FUNC" == bats_* ]] && continue
            [[ "$FUNC" == batslib_* ]] && continue
            [[ "$FUNC" == assert_* ]] && continue
            [[ "$FUNC" == "$CONTEXT" ]] && continue
            [[ "$FUNC" == "ywt" ]] && continue
            [[ "$FUNC" == *"sdk"* ]] && continue
            FUNC=${FUNC%,}
            __log info "${YELLOW}ydk ${GREEN}${CONTEXT} ${BLUE}$FUNC${NC}"
        done
        return 1
    }
    [ -z "$YWT_PATHS" ] && __paths >/dev/null
    [ -z "$YWT_FLAGS" ] && __argv "$@" >/dev/null
    [ -z "$YWT_PARAMS" ] && __params "$@" >/dev/null
    __flags "$@" && set -- "${YWT_POSITIONAL[@]}" && __bootstrap && logger debug "${YELLOW}yw-sh${NC} ${GREEN}$*${NC}"
    [ "${1}" == "usage" ] && usage "0" "" "$@" && return 0
    __nnf "$@" && return 0
    local STATUS=$? && usage "$STATUS" "" "$@" && return 1
}
ydk() {
    [ "$#" -eq 0 ] && return 0
    local FUNC=${1} && [ -z "$FUNC" ] && return 1
    FUNC=${FUNC#_} && FUNC=${FUNC#__}
    local ARGS=("${@:2}")
    sdk "$FUNC" "${ARGS[@]}"
    return 0
}
ywt(){
    ydk "$@"
}
if [ "$#" -gt 0 ]; then
    SDK_FILE="$(realpath -- "${YWT_SDK_FILE}")" && export SDK_FILE
    if ! LC_ALL=C grep -a '[^[:print:][:space:]]' "$SDK_FILE" >/dev/null; then
        ydk "$@"
        exit $?
    else
        ydk "$@"
        exit $?
    fi
fi
# </./sdk/sdk.sh>
